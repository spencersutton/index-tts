"""
This type stub file was generated by pyright.
"""

import weakref
from collections.abc import AsyncIterator, Callable, Sequence, Set
from pathlib import Path
from types import ModuleType
from typing import TYPE_CHECKING, Any, Literal

import fastapi
from gradio.block_function import BlockFunction
from gradio.blocks_events import BlocksEvents, BlocksMeta
from gradio.components.base import Component
from gradio.data_classes import APIInfo, BlocksConfigDict
from gradio.events import EventData, EventListener, EventListenerMethod
from gradio.i18n import I18n, I18nData
from gradio.renderable import Renderable
from gradio.routes import App, Request
from gradio.state_holder import SessionState
from gradio.themes import ThemeClass as Theme
from gradio_client.documentation import document

if TYPE_CHECKING: ...

class Block:
    def __init__(
        self,
        *,
        elem_id: str | None = ...,
        elem_classes: list[str] | str | None = ...,
        render: bool = ...,
        key: int | str | tuple[int | str, ...] | None = ...,
        preserved_by_key: list[str] | str | None = ...,
        visible: bool | Literal["hidden"] = ...,
        proxy_url: str | None = ...,
    ) -> None: ...
    def unique_key(self) -> int | None: ...
    @property
    def stateful(self) -> bool: ...
    @property
    def skip_api(self) -> bool: ...
    @property
    def constructor_args(self) -> dict[str, Any]:
        """Get the arguments passed to the component's initializer.

        Only set classes whose metaclass is ComponentMeta
        """
        ...

    @property
    def events(self) -> list[EventListener]: ...
    def render(self):  # -> Component | Block | Self:
        """
        Adds self into appropriate BlockContext
        """
        ...

    def unrender(self):  # -> Self:
        """
        Removes self from BlockContext if it has been rendered (otherwise does nothing).
        Removes self from the layout and collection of blocks, but does not delete any event triggers.
        """
        ...

    def get_block_name(self) -> str:
        """
        Gets block's class name. If it is template component it gets the parent's class name.
        This is used to identify the Svelte file to use in the frontend. Override this method
        if a component should use a different Svelte file than the default naming convention.
        """
        ...

    def get_block_class(self) -> str:
        """
        Gets block's class name. If it is template component it gets the parent's class name.
        Very similar to the get_block_name method, but this method is used to reconstruct a
        Gradio app that is loaded from a Space using gr.load(). This should generally
        NOT be overridden.
        """
        ...

    def get_expected_parent(self) -> type[BlockContext] | None: ...
    def breaks_grouping(self) -> bool:
        """
        Whether this component breaks FormComponent grouping chains.
        Components that return False will not reset the pseudo_parent
        when encountered during fill_expected_parents grouping.
        """
        ...

    def get_config(self, cls: type[Block] | None = ...) -> dict[str, Any]: ...
    @classmethod
    def recover_kwargs(cls, props: dict[str, Any], additional_keys: list[str] | None = ...):  # -> dict[Any, Any]:
        """
        Recovers kwargs from a dict of props.
        """
        ...

    async def async_move_resource_to_block_cache(self, url_or_file_path: str | Path | None) -> str | None:
        """Moves a file or downloads a file from a url to a block's cache directory, adds
        to to the block's temp_files, and returns the path to the file in cache. This
        ensures that the file is accessible to the Block and can be served to users.

        This async version of the function is used when this is being called within
        a FastAPI route, as this is not blocking.
        """
        ...

    def move_resource_to_block_cache(self, url_or_file_path: str | Path | None) -> str | None:
        """Moves a file or downloads a file from a url to a block's cache directory, adds
        to to the block's temp_files, and returns the path to the file in cache. This
        ensures that the file is accessible to the Block and can be served to users.

        This sync version of the function is used when this is being called outside of
        a FastAPI route, e.g. when examples are being cached.
        """
        ...

    def serve_static_file(self, url_or_file_path: str | Path | dict | None) -> dict | None:
        """If a file is a local file, moves it to the block's cache directory and returns
        a FileData-type dictionary corresponding to the file. If the file is a URL, returns a
        FileData-type dictionary corresponding to the URL. This ensures that the file is
        accessible in the frontend and can be served to users.

        Examples:
        >>> block.serve_static_file("https://gradio.app/logo.png") -> {"path": "https://gradio.app/logo.png", "url": "https://gradio.app/logo.png"}
        >>> block.serve_static_file("logo.png") -> {"path": "logo.png", "url": "/file=logo.png"}
        >>> block.serve_static_file({"path": "logo.png", "url": "/file=logo.png"}) -> {"path": "logo.png", "url": "/file=logo.png"}
        """
        ...

class BlockContext(Block):
    def __init__(
        self,
        elem_id: str | None = ...,
        elem_classes: list[str] | str | None = ...,
        visible: bool | Literal["hidden"] = ...,
        render: bool = ...,
        key: int | str | tuple[int | str, ...] | None = ...,
        preserved_by_key: list[str] | str | None = ...,
    ) -> None:
        """
        Parameters:
            elem_id: An optional string that is assigned as the id of this component in the HTML DOM. Can be used for targeting CSS styles.
            elem_classes: An optional string or list of strings that are assigned as the class of this component in the HTML DOM. Can be used for targeting CSS styles.
            visible: If False, this will be hidden but included in the Blocks config file (its visibility can later be updated).
            render: If False, this will not be included in the Blocks config file at all.
        """
        ...

    TEMPLATE_DIR = ...
    FRONTEND_DIR = ...
    @property
    def skip_api(self):  # -> Literal[True]:
        ...
    @classmethod
    def get_component_class_id(cls) -> str: ...
    @property
    def component_class_id(self):  # -> str:
        ...
    def add_child(self, child: Block):  # -> None:
        ...
    def __enter__(self):  # -> Self:
        ...
    def add(self, child: Block):  # -> None:
        ...
    def fill_expected_parents(self):  # -> None:
        ...
    def __exit__(self, exc_type: type[BaseException] | None = ..., *args):  # -> None:
        ...
    def postprocess(self, y):
        """
        Any postprocessing needed to be performed on a block context.
        """
        ...

def postprocess_update_dict(
    block: Component | BlockContext, update_dict: dict, postprocess: bool = ...
):  # -> dict[Any, Any]:
    """
    Converts a dictionary of updates into a format that can be sent to the frontend to update the component.
    E.g. {"value": "2", "visible": True, "invalid_arg": "hello"}
    Into -> {"__type__": "update", "value": 2.0, "visible": True}
    Parameters:
        block: The Block that is being updated with this update dictionary.
        update_dict: The original update dictionary
        postprocess: Whether to postprocess the "value" key of the update dictionary.
    """
    ...

def convert_component_dict_to_list(outputs_ids: list[int], predictions: dict) -> list | dict:
    """
    Converts a dictionary of component updates into a list of updates in the order of
    the outputs_ids and including every output component. Leaves other types of dictionaries unchanged.
    E.g. {"textbox": "hello", "number": {"__type__": "generic_update", "value": "2"}}
    Into -> ["hello", {"__type__": "generic_update"}, {"__type__": "generic_update", "value": "2"}]
    """
    ...

class BlocksConfig:
    def __init__(self, root_block: Blocks) -> None: ...
    def set_event_trigger(
        self,
        targets: Sequence[EventListenerMethod],
        fn: Callable | None,
        inputs: (Component | BlockContext | Sequence[Component | BlockContext] | Set[Component | BlockContext] | None),
        outputs: (Component | BlockContext | Sequence[Component | BlockContext] | Set[Component | BlockContext] | None),
        preprocess: bool = ...,
        postprocess: bool = ...,
        scroll_to_output: bool = ...,
        show_progress: Literal["full", "minimal", "hidden"] = ...,
        show_progress_on: Component | Sequence[Component] | None = ...,
        api_name: str | None = ...,
        api_description: str | None | Literal[False] = ...,
        js: str | Literal[True] | None = ...,
        no_target: bool = ...,
        queue: bool = ...,
        batch: bool = ...,
        max_batch_size: int = ...,
        cancels: list[int] | None = ...,
        collects_event_data: bool | None = ...,
        trigger_after: int | None = ...,
        trigger_only_on_success: bool = ...,
        trigger_only_on_failure: bool = ...,
        trigger_mode: Literal["once", "multiple", "always_last"] | None = ...,
        concurrency_limit: int | None | Literal["default"] = ...,
        concurrency_id: str | None = ...,
        api_visibility: Literal["public", "private", "undocumented"] = ...,
        renderable: Renderable | None = ...,
        is_cancel_function: bool = ...,
        connection: Literal["stream", "sse"] = ...,
        time_limit: float | None = ...,
        stream_every: float = ...,
        event_specific_args: list[str] | None = ...,
        js_implementation: str | None = ...,
        key: str | int | tuple[int | str, ...] | None = ...,
        validator: Callable | None = ...,
        component_prop_inputs: list[int] | None = ...,
    ) -> tuple[BlockFunction, int]:
        """
        Adds an event to the component's dependencies.
        Parameters:
            targets: a list of EventListenerMethod objects that define the event trigger
            fn: the function to run when the event is triggered
            inputs: the list of input components whose values will be passed to the function
            outputs: the list of output components whose values will be updated by the function
            preprocess: whether to run the preprocess methods of the input components before running the function
            postprocess: whether to run the postprocess methods of the output components after running the function
            scroll_to_output: whether to scroll to output of dependency on trigger
            show_progress: how to show the progress animation while event is running: "full" shows a spinner which covers the output component area as well as a runtime display in the upper right corner, "minimal" only shows the runtime display, "hidden" shows no progress animation at all
            show_progress_on: Component or list of components to show the progress animation on. If None, will show the progress animation on all of the output components.
            api_name: defines how the endpoint appears in the API docs. Can be a string or None. If set to a string, the endpoint will be exposed in the API docs with the given name. If None (default), the name of the function will be used as the API endpoint.
            api_description: Description of the API endpoint. Can be a string, None, or False. If set to a string, the endpoint will be exposed in the API docs with the given description. If None, the function's docstring will be used as the API endpoint description. If False, then no description will be displayed in the API docs.
            js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components
            no_target: if True, sets "targets" to [], used for the Blocks.load() event and .then() events
            queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.
            batch: whether this function takes in a batch of inputs
            max_batch_size: the maximum batch size to send to the function
            cancels: a list of other events to cancel when this event is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method.
            collects_event_data: whether to collect event data for this event
            trigger_after: if set, this event will be triggered after 'trigger_after' function index
            trigger_only_on_success: if True, this event will only be triggered if the previous event was successful (only applies if `trigger_after` is set)
            trigger_only_on_failure: if True, this event will only be triggered if the previous event failed i.e. raised an exception (only applies if `trigger_after` is set)
            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
            concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `queue()`, which itself is 1 by default).
            concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
            api_visibility: controls the visibility and accessibility of this endpoint. Can be "public" (shown in API docs and callable by clients), "private" (hidden from API docs and not callable by clients), or "undocumented" (hidden from API docs but callable by clients and via gr.load). If fn is None, api_visibility will automatically be set to "private".
            is_cancel_function: whether this event cancels another running event.
            connection: The connection format, either "sse" or "stream".
            time_limit: The time limit for the function to run. Parameter only used for the `.stream()` event.
            stream_every: The latency (in seconds) at which stream chunks are sent to the backend. Defaults to 0.5 seconds. Parameter only used for the `.stream()` event.
            validator: a function that takes in the inputs and can optionally return a gr.validate() object for each input.
        Returns: dependency information, dependency index
        """
        ...

    @staticmethod
    def config_for_block(
        _id: int, rendered_ids: list[int], block: Block | Component, renderable: Renderable | None = ...
    ) -> dict: ...
    def get_config(self, renderable: Renderable | None = ...):  # -> dict[str, dict[Any, Any] | list[Any]]:
        ...
    def __copy__(self):  # -> BlocksConfig:
        ...
    def attach_load_events(self, rendered_in: Renderable | None = ...):  # -> None:
        """Add a load event for every component whose initial value requires a function call to set."""
        ...

@document("launch", "queue", "integrate", "load", "unload")
class Blocks(BlockContext, BlocksEvents, metaclass=BlocksMeta):
    """
    Blocks is Gradio's low-level API that allows you to create more custom web
    applications and demos than Interfaces (yet still entirely in Python).


    Compared to the Interface class, Blocks offers more flexibility and control over:
    (1) the layout of components (2) the events that
    trigger the execution of functions (3) data flows (e.g. inputs can trigger outputs,
    which can trigger the next level of outputs). Blocks also offers ways to group
    together related demos such as with tabs.


    The basic usage of Blocks is as follows: create a Blocks object, then use it as a
    context (with the "with" statement), and then define layouts, components, or events
    within the Blocks context. Finally, call the launch() method to launch the demo.

    Example:
        import gradio as gr
        def update(name):
            return f"Welcome to Gradio, {name}!"

        with gr.Blocks() as demo:
            gr.Markdown("Start typing below and then click **Run** to see the output.")
            with gr.Row():
                inp = gr.Textbox(placeholder="What is your name?")
                out = gr.Textbox()
            btn = gr.Button("Run")
            btn.click(fn=update, inputs=inp, outputs=out)

        demo.launch()
    Demos: blocks_hello, blocks_flipper, blocks_kinematics
    Guides: blocks-and-event-listeners, controlling-layout, state-in-blocks, custom-CSS-and-JS, using-blocks-like-functions
    """

    instances: weakref.WeakSet = ...
    @classmethod
    def get_instances(cls) -> list[Blocks]:
        """
        :return: list of all current instances.
        """
        ...

    def __init__(
        self,
        analytics_enabled: bool | None = ...,
        mode: str = ...,
        title: str | I18nData = ...,
        fill_height: bool = ...,
        fill_width: bool = ...,
        delete_cache: tuple[int, int] | None = ...,
        **kwargs,
    ) -> None:
        """
        Parameters:
            analytics_enabled: Whether to allow basic telemetry. If None, will use GRADIO_ANALYTICS_ENABLED environment variable or default to True.
            mode: A human-friendly name for the kind of Blocks or Interface being created. Used internally for analytics.
            title: The tab title to display when this is opened in a browser window.
            fill_height: Whether to vertically expand top-level child components to the height of the window. If True, expansion occurs when the scale value of the child components >= 1.
            fill_width: Whether to horizontally expand to fill container fully. If False, centers and constrains app to a maximum width. Only applies if this is the outermost `Blocks` in your Gradio app.
            delete_cache: A tuple corresponding [frequency, age] both expressed in number of seconds. Every `frequency` seconds, the temporary files created by this Blocks instance will be deleted if more than `age` seconds have passed since the file was created. For example, setting this to (86400, 86400) will delete temporary files every day. The cache will be deleted entirely when the server restarts. If None, no cache deletion will occur.
        """
        ...

    @property
    def blocks(self) -> dict[int, Component | Block]: ...
    @blocks.setter
    def blocks(self, value: dict[int, Component | Block]):  # -> None:
        ...
    @property
    def fns(self) -> dict[int, BlockFunction]: ...
    def get_component(self, id: int) -> Component | BlockContext: ...
    @classmethod
    def from_config(cls, config: BlocksConfigDict, fns: list[Callable], proxy_url: str) -> Blocks:
        """
        Factory method that creates a Blocks from a config and list of functions. Used
        internally by the gradio.external.load() method.

        Parameters:
        config: a dictionary containing the configuration of the Blocks.
        fns: a list of functions that are used in the Blocks. Must be in the same order as the dependencies in the config.
        proxy_url: an external url to use as a root URL when serving files for components in the Blocks.
        """
        ...

    def __str__(self) -> str: ...
    def __repr__(self):  # -> str:
        ...
    @property
    def expects_oauth(self):  # -> bool:
        """Return whether the app expects user to authenticate via OAuth."""
        ...

    def unload(self, fn: Callable[..., Any]) -> None:
        """This listener is triggered when the user closes or refreshes the tab, ending the user session.
        It is useful for cleaning up resources when the app is closed.
        Parameters:
            fn: Callable function to run to clear resources. The function should not take any arguments and the output is not used.
        Example:
            import gradio as gr
            with gr.Blocks() as demo:
                gr.Markdown("# When you close the tab, hello will be printed to the console")
                demo.unload(lambda: print("hello"))
            demo.launch()
        """
        ...

    def render(self):  # -> Self:
        ...
    def is_callable(self, fn_index: int = ...) -> bool:
        """Checks if a particular Blocks function is callable (i.e. not stateful or a generator)."""
        ...

    def __call__(self, *inputs, fn_index: int = ..., api_name: str | None = ...):  # -> Any:
        """
        Allows Blocks objects to be called as functions. Supply the parameters to the
        function as positional arguments. To choose which function to call, use the
        fn_index parameter, which must be a keyword argument.

        Parameters:
        *inputs: the parameters to pass to the function
        fn_index: the index of the function to call (defaults to 0, which for Interfaces, is the default prediction function)
        api_name: The api_name of the dependency to call. Will take precedence over fn_index.
        """
        ...

    async def call_function(
        self,
        block_fn: BlockFunction | int,
        processed_input: list[Any],
        iterator: AsyncIterator[Any] | None = ...,
        requests: Request | list[Request] | None = ...,
        event_id: str | None = ...,
        event_data: EventData | None = ...,
        in_event_listener: bool = ...,
        state: SessionState | None = ...,
    ):  # -> dict[str, Any | tuple[Literal[_Keywords.FINISHED_ITERATING], ...] | _Keywords | float | bool | SyncToAsyncIterator | AsyncIterator[Any] | None]:
        """
        Calls function with given index and preprocessed input, and measures process time.
        Parameters:
            fn_index: index of function to call
            processed_input: preprocessed input to pass to function
            iterator: iterator to use if function is a generator
            requests: requests to pass to function
            event_id: id of event in queue
            event_data: data associated with event trigger
        """
        ...

    def serialize_data(self, fn_index: int, inputs: list[Any]) -> list[Any]: ...
    def deserialize_data(self, fn_index: int, outputs: list[Any]) -> list[Any]: ...
    def validate_inputs(self, block_fn: BlockFunction, inputs: list[Any]):  # -> None:
        ...
    async def preprocess_data(
        self, block_fn: BlockFunction, inputs: list[Any], state: SessionState | None, explicit_call: bool = ...
    ):  # -> list[Any]:
        ...
    def validate_outputs(self, block_fn: BlockFunction, predictions: Any | list[Any]):  # -> None:
        ...
    async def postprocess_data(
        self, block_fn: BlockFunction, predictions: list | dict, state: SessionState | None
    ) -> list[Any]: ...
    async def handle_streaming_outputs(
        self,
        block_fn: BlockFunction,
        data: list,
        session_hash: str | None,
        run: int | None,
        root_path: str | None = ...,
        final: bool = ...,
    ) -> list: ...
    def handle_streaming_diffs(
        self,
        block_fn: BlockFunction,
        data: list,
        session_hash: str | None,
        run: int | None,
        final: bool,
        simple_format: bool = ...,
    ) -> list: ...
    async def process_api(
        self,
        block_fn: BlockFunction | int,
        inputs: list[Any],
        state: SessionState | None = ...,
        request: Request | list[Request] | None = ...,
        iterator: AsyncIterator | None = ...,
        session_hash: str | None = ...,
        event_id: str | None = ...,
        event_data: EventData | None = ...,
        in_event_listener: bool = ...,
        simple_format: bool = ...,
        explicit_call: bool = ...,
        root_path: str | None = ...,
    ) -> dict[str, Any]:
        """
        Processes API calls from the frontend. First preprocesses the data,
        then runs the relevant function, then postprocesses the output.

        Parameters:
            fn_index: Index of function to run.
            inputs: input data received from the frontend
            state: data stored from stateful components for session (key is input block id)
            request: the gr.Request object containing information about the network request (e.g. IP address, headers, query parameters, username)
            iterators: the in-progress iterators for each generator function (key is function index)
            event_id: id of event that triggered this API call
            event_data: data associated with the event trigger itself
            in_event_listener: whether this API call is being made in response to an event listener
            explicit_call: whether this call is being made directly by calling the Blocks function, instead of through an event listener or API route
            root_path: if provided, the root path of the server. All file URLs will be prefixed with this path.

        Returns a dictionary with the following keys:
            - "data": the output data from the function
            - "is_generating": whether the function is generating output
            - "iterator": the iterator for the function
            - "duration": the duration of the function call
            - "average_duration": the average duration of the function call
            - "render_config": the render config for the function
        """
        ...

    def get_state_ids_to_track(self, block_fn: BlockFunction, state: SessionState | None) -> tuple[list[int], list]: ...
    def create_limiter(self):  # -> None:
        ...
    def get_config(self):  # -> dict[str, str]:
        ...
    def get_config_file(self) -> BlocksConfigDict: ...
    def transpile_to_js(self, quiet: bool = ...):  # -> None:
        ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, exc_type: type[BaseException] | None = ..., *args):  # -> None:
        ...
    def clear(self):  # -> Self:
        """Resets the layout of the Blocks object."""
        ...

    @document()
    def queue(
        self,
        status_update_rate: float | Literal["auto"] = ...,
        api_open: bool | None = ...,
        max_size: int | None = ...,
        *,
        default_concurrency_limit: int | None | Literal["not_set"] = ...,
    ):  # -> Self:
        """
        By enabling the queue you can control when users know their position in the queue, and set a limit on maximum number of events allowed.
        Parameters:
            status_update_rate: If "auto", Queue will send status estimations to all clients whenever a job is finished. Otherwise Queue will send status at regular intervals set by this parameter as the number of seconds.
            api_open: If True, the REST routes of the backend will be open, allowing requests made directly to those endpoints to skip the queue.
            max_size: The maximum number of events the queue will store at any given moment. If the queue is full, new events will not be added and a user will receive a message saying that the queue is full. If None, the queue size will be unlimited.
            default_concurrency_limit: The default value of `concurrency_limit` to use for event listeners that don't specify a value. Can be set by environment variable GRADIO_DEFAULT_CONCURRENCY_LIMIT. Defaults to 1 if not set otherwise.
        Example: (Blocks)
            with gr.Blocks() as demo:
                button = gr.Button(label="Generate Image")
                button.click(fn=image_generator, inputs=gr.Textbox(), outputs=gr.Image())
            demo.queue(max_size=10)
            demo.launch()
        Example: (Interface)
            demo = gr.Interface(image_generator, gr.Textbox(), gr.Image())
            demo.queue(max_size=20)
            demo.launch()
        """
        ...

    def validate_queue_settings(self):  # -> None:
        ...
    def validate_navbar_settings(self):  # -> None:
        """Validates that only one Navbar component exists per page."""
        ...

    def launch(
        self,
        inline: bool | None = ...,
        inbrowser: bool = ...,
        share: bool | None = ...,
        debug: bool = ...,
        max_threads: int = ...,
        auth: (Callable[[str, str], bool] | tuple[str, str] | list[tuple[str, str]] | None) = ...,
        auth_message: str | None = ...,
        prevent_thread_lock: bool = ...,
        show_error: bool = ...,
        server_name: str | None = ...,
        server_port: int | None = ...,
        *,
        height: int = ...,
        width: int | str = ...,
        favicon_path: str | Path | None = ...,
        ssl_keyfile: str | None = ...,
        ssl_certfile: str | None = ...,
        ssl_keyfile_password: str | None = ...,
        ssl_verify: bool = ...,
        quiet: bool = ...,
        footer_links: list[Literal["api", "gradio", "settings"] | dict[str, str]] | None = ...,
        allowed_paths: list[str] | None = ...,
        blocked_paths: list[str] | None = ...,
        root_path: str | None = ...,
        app_kwargs: dict[str, Any] | None = ...,
        state_session_capacity: int = ...,
        share_server_address: str | None = ...,
        share_server_protocol: Literal["http", "https"] | None = ...,
        share_server_tls_certificate: str | None = ...,
        auth_dependency: Callable[[fastapi.Request], str | None] | None = ...,
        max_file_size: str | int | None = ...,
        enable_monitoring: bool | None = ...,
        strict_cors: bool = ...,
        node_server_name: str | None = ...,
        node_port: int | None = ...,
        ssr_mode: bool | None = ...,
        pwa: bool | None = ...,
        mcp_server: bool | None = ...,
        _frontend: bool = ...,
        i18n: I18n | None = ...,
        theme: Theme | str | None = ...,
        css: str | None = ...,
        css_paths: str | Path | Sequence[str | Path] | None = ...,
        js: str | Literal[True] | None = ...,
        head: str | None = ...,
        head_paths: str | Path | Sequence[str | Path] | None = ...,
    ) -> tuple[App, str, str]:
        """
        Launches a simple web server that serves the demo. Can also be used to create a
        public link used by anyone to access the demo from their browser by setting share=True.
        Parameters:
            inline: whether to display in the gradio app inline in an iframe. Defaults to True in python notebooks; False otherwise.
            inbrowser: whether to automatically launch the gradio app in a new tab on the default browser.
            share: whether to create a publicly shareable link for the gradio app. Creates an SSH tunnel to make your UI accessible from anywhere. If not provided, it is set to False by default every time, except when running in Google Colab. When localhost is not accessible (e.g. Google Colab), setting share=False is not supported. Can be set by environment variable GRADIO_SHARE=True.
            debug: if True, blocks the main thread from running. If running in Google Colab, this is needed to print the errors in the cell output.
            auth: If provided, username and password (or list of username-password tuples) required to access app. Can also provide function that takes username and password and returns True if valid login.
            auth_message: If provided, HTML message provided on login page.
            prevent_thread_lock: By default, the gradio app blocks the main thread while the server is running. If set to True, the gradio app will not block and the gradio server will terminate as soon as the script finishes.
            show_error: If True, any errors in the gradio app will be displayed in an alert modal and printed in the browser console log. They will also be displayed in the alert modal of downstream apps that gr.load() this app.
            server_port: will start gradio app on this port (if available). Can be set by environment variable GRADIO_SERVER_PORT. If None, will search for an available port starting at 7860.
            server_name: to make app accessible on local network, set this to "0.0.0.0". Can be set by environment variable GRADIO_SERVER_NAME. If None, will use "127.0.0.1".
            max_threads: the maximum number of total threads that the Gradio app can generate in parallel. The default is inherited from the starlette library (currently 40).
            width: The width in pixels of the iframe element containing the gradio app (used if inline=True)
            height: The height in pixels of the iframe element containing the gradio app (used if inline=True)
            favicon_path: If a path to a file (.png, .gif, or .ico) is provided, it will be used as the favicon for the web page.
            ssl_keyfile: If a path to a file is provided, will use this as the private key file to create a local server running on https.
            ssl_certfile: If a path to a file is provided, will use this as the signed certificate for https. Needs to be provided if ssl_keyfile is provided.
            ssl_keyfile_password: If a password is provided, will use this with the ssl certificate for https.
            ssl_verify: If False, skips certificate validation which allows self-signed certificates to be used.
            quiet: If True, suppresses most print statements.
            footer_links: The links to display in the footer of the app. Accepts a list, where each element of the list must be one of "api", "gradio", or "settings" corresponding to the API docs, "built with Gradio", and settings pages respectively. If None, all three links will be shown in the footer. An empty list means that no footer is shown.
            allowed_paths: List of complete filepaths or parent directories that gradio is allowed to serve. Must be absolute paths. Warning: if you provide directories, any files in these directories or their subdirectories are accessible to all users of your app. Can be set by comma separated environment variable GRADIO_ALLOWED_PATHS. These files are generally assumed to be secure and will be displayed in the browser when possible.
            blocked_paths: List of complete filepaths or parent directories that gradio is not allowed to serve (i.e. users of your app are not allowed to access). Must be absolute paths. Warning: takes precedence over `allowed_paths` and all other directories exposed by Gradio by default. Can be set by comma separated environment variable GRADIO_BLOCKED_PATHS.
            root_path: The root path (or "mount point") of the application, if it's not served from the root ("/") of the domain. Often used when the application is behind a reverse proxy that forwards requests to the application. For example, if the application is served at "https://example.com/myapp", the `root_path` should be set to "/myapp". A full URL beginning with http:// or https:// can be provided, which will be used as the root path in its entirety. Can be set by environment variable GRADIO_ROOT_PATH. Defaults to "".
            app_kwargs: Additional keyword arguments to pass to the underlying FastAPI app as a dictionary of parameter keys and argument values. For example, `{"docs_url": "/docs"}`
            state_session_capacity: The maximum number of sessions whose information to store in memory. If the number of sessions exceeds this number, the oldest sessions will be removed. Reduce capacity to reduce memory usage when using gradio.State or returning updated components from functions. Defaults to 10000.
            share_server_address: Use this to specify a custom FRP server and port for sharing Gradio apps (only applies if share=True). If not provided, will use the default FRP server at https://gradio.live. See https://github.com/huggingface/frp for more information.
            share_server_protocol: Use this to specify the protocol to use for the share links. Defaults to "https", unless a custom share_server_address is provided, in which case it defaults to "http". If you are using a custom share_server_address and want to use https, you must set this to "https".
            share_server_tls_certificate: The path to a TLS certificate file to use when connecting to a custom share server. This parameter is not used with the default FRP server at https://gradio.live. Otherwise, you must provide a valid TLS certificate file (e.g. a "cert.pem") relative to the current working directory, or the connection will not use TLS encryption, which is insecure.
            auth_dependency: A function that takes a FastAPI request and returns a string user ID or None. If the function returns None for a specific request, that user is not authorized to access the app (they will see a 401 Unauthorized response). To be used with external authentication systems like OAuth. Cannot be used with `auth`.
            max_file_size: The maximum file size in bytes that can be uploaded. Can be a string of the form "<value><unit>", where value is any positive integer and unit is one of "b", "kb", "mb", "gb", "tb". If None, no limit is set.
            enable_monitoring: Enables traffic monitoring of the app through the /monitoring endpoint. By default is None, which enables this endpoint. If explicitly True, will also print the monitoring URL to the console. If False, will disable monitoring altogether.
            strict_cors: If True, prevents external domains from making requests to a Gradio server running on localhost. If False, allows requests to localhost that originate from localhost but also, crucially, from "null". This parameter should normally be True to prevent CSRF attacks but may need to be False when embedding a *locally-running Gradio app* using web components.
            ssr_mode: If True, the Gradio app will be rendered using server-side rendering mode, which is typically more performant and provides better SEO, but this requires Node 20+ to be installed on the system. If False, the app will be rendered using client-side rendering mode. If None, will use GRADIO_SSR_MODE environment variable or default to False.
            pwa: If True, the Gradio app will be set up as an installable PWA (Progressive Web App). If set to None (default behavior), then the PWA feature will be enabled if this Gradio app is launched on Spaces, but not otherwise.
            i18n: An I18n instance containing custom translations, which are used to translate strings in our components (e.g. the labels of components or Markdown strings). This feature can only be used to translate static text in the frontend, not values in the backend.
            mcp_server: If True, the Gradio app will be set up as an MCP server and documented functions will be added as MCP tools. If None (default behavior), then the GRADIO_MCP_SERVER environment variable will be used to determine if the MCP server should be enabled.
            theme: A Theme object or a string representing a theme. If a string, will look for a built-in theme with that name (e.g. "soft" or "default"), or will attempt to load a theme from the Hugging Face Hub (e.g. "gradio/monochrome"). If None, will use the Default theme.
            css: Custom css as a code string. This css will be included in the demo webpage.
            css_paths: Custom css as a pathlib.Path to a css file or a list of such paths. This css files will be read, concatenated, and included in the demo webpage. If the `css` parameter is also set, the css from `css` will be included first.
            js: Custom js as a code string. The custom js should be in the form of a single js function. This function will automatically be executed when the page loads. For more flexibility, use the head parameter to insert js inside <script> tags.
            head: Custom html code to insert into the head of the demo webpage. This can be used to add custom meta tags, multiple scripts, stylesheets, etc. to the page.
            head_paths: Custom html code as a pathlib.Path to a html file or a list of such paths. This html files will be read, concatenated, and included in the head of the demo webpage. If the `head` parameter is also set, the html from `head` will be included first.
        Returns:
            app: FastAPI app object that is running the demo
            local_url: Locally accessible link to the demo
            share_url: Publicly accessible link to the demo (if share=True, otherwise None)
        Example: (Blocks)
            import gradio as gr
            def reverse(text):
                return text[::-1]
            with gr.Blocks() as demo:
                button = gr.Button(value="Reverse")
                button.click(reverse, gr.Textbox(), gr.Textbox())
            demo.launch(share=True, auth=("username", "password"))
        Example:  (Interface)
            import gradio as gr
            def reverse(text):
                return text[::-1]
            demo = gr.Interface(reverse, "text", "text")
            demo.launch(share=True, auth=("username", "password"))
        """
        ...

    def integrate(self, comet_ml=..., wandb: ModuleType | None = ..., mlflow: ModuleType | None = ...) -> None:
        """
        A catch-all method for integrating with other libraries. This method should be run after launch()
        Parameters:
            comet_ml: If a comet_ml Experiment object is provided, will integrate with the experiment and appear on Comet dashboard
            wandb: If the wandb module is provided, will integrate with it and appear on WandB dashboard
            mlflow: If the mlflow module  is provided, will integrate with the experiment and appear on ML Flow dashboard
        """
        ...

    def close(self, verbose: bool = ...) -> None:
        """
        Closes the Interface that was launched and frees the port.
        """
        ...

    def block_thread(self) -> None:
        """Block main thread until interrupted by user."""
        ...

    def run_startup_events(self):  # -> None:
        """Events that should be run when the app containing this block starts up."""
        ...

    async def run_extra_startup_events(self):  # -> None:
        ...
    def get_api_info(self, all_endpoints: bool = ...) -> APIInfo:
        """
        Gets the information needed to generate the API docs from a Blocks.
        Parameters:
            all_endpoints: If True, returns information about all endpoints, including those with api_visibility="undocumented".
        """
        ...

    @staticmethod
    def get_event_targets(original_mapping: dict[int, Block], _targets: list, trigger: str) -> list: ...
    @document()
    def route(self, name: str, path: str | None = ..., show_in_navbar: bool = ...) -> Blocks:
        """
        Adds a new page to the Blocks app.
        Parameters:
            name: The name of the page as it appears in the nav bar.
            path: The URL suffix appended after your Gradio app's root URL to access this page (e.g. if path="/test", the page may be accessible e.g. at http://localhost:7860/test). If not provided, the path is generated from the name by converting to lowercase and replacing spaces with hyphens. Any leading or trailing forward slashes are stripped.
            show_in_navbar: If True, the page will appear in the navbar. If False, the page will be accessible via URL but not shown in the navbar.
        Example:
            with gr.Blocks() as demo:
                name = gr.Textbox(label="Name")
                ...
            with demo.route("Test", "/test"):
                num = gr.Number()
                ...
        """
        ...
