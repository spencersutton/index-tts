"""
This type stub file was generated by pyright.
"""

import abc
from abc import ABC, abstractmethod
from collections.abc import Callable, Sequence
from enum import Enum
from pathlib import Path
from typing import Any, Literal, TYPE_CHECKING, TypedDict
from gradio.blocks import Block
from gradio.component_meta import ComponentMeta
from gradio.data_classes import FileData, FileDataDict, GradioDataModel, MediaStreamChunk
from gradio.events import EventListener
from gradio.i18n import I18nData
from gradio.layouts import Form
from gradio.components import Timer

"""Contains all of the components that can be used with Gradio Interface / Blocks.
Along with the docs for each component, you can find the names of example demos that use
each component. These demos are located in the `demo` directory."""
if TYPE_CHECKING:
    class DataframeData(TypedDict):
        headers: list[str]
        data: list[list[str | int | bool]]
        ...

class _Keywords(Enum):
    NO_VALUE = ...
    FINISHED_ITERATING = ...

class ComponentBase(ABC, metaclass=ComponentMeta):
    EVENTS: list[EventListener | str] = ...
    @abstractmethod
    def preprocess(self, payload: Any) -> Any:
        """
        Any preprocessing needed to be performed on function input.
        Parameters:
            payload: The input data received by the component from the frontend.
        Returns:
            The preprocessed input data sent to the user's function in the backend.
        """
        ...

    @abstractmethod
    def postprocess(self, value):
        """
        Any postprocessing needed to be performed on function output.
        Parameters:
            value: The output data received by the component from the user's function in the backend.
        Returns:
            The postprocessed output data sent to the frontend.
        """
        ...

    @abstractmethod
    def process_example(self, value):
        """
        Process the input data in a way that can be displayed by the examples dataset component in the front-end.

        For example, only return the name of a file as opposed to a full path. Or get the head of a dataframe.
        The return value must be able to be json-serializable to put in the config.
        """
        ...

    @abstractmethod
    def api_info(self) -> dict[str, list[str]]:
        """
        The typing information for this component as a dictionary whose values are a list of 2 strings: [Python type, language-agnostic description].
        Keys of the dictionary are: raw_input, raw_output, serialized_input, serialized_output
        """
        ...

    @abstractmethod
    def example_inputs(self) -> Any:
        """
        Deprecated and replaced by `example_payload()` and `example_value()`.
        """
        ...

    @abstractmethod
    def flag(self, payload: Any | GradioDataModel, flag_dir: str | Path = ...) -> str:
        """
        Write the component's value to a format that can be stored in a csv or jsonl format for flagging.
        """
        ...

    @abstractmethod
    def read_from_flag(self, payload: Any) -> GradioDataModel | Any:
        """
        Convert the data from the csv or jsonl file into the component state.
        """
        ...

    @property
    @abstractmethod
    def skip_api(self) -> bool:
        """Whether this component should be skipped from the api return value"""
        ...

    @classmethod
    def has_event(cls, event: str | EventListener) -> bool: ...
    @classmethod
    def get_component_class_id(cls) -> str: ...

    if TYPE_CHECKING: ...

def server(fn): ...

class Component(ComponentBase, Block):
    """
    A base class for defining methods that all input/output components should have.
    """
    def __init__(
        self,
        value: Any = ...,
        *,
        label: str | I18nData | None = ...,
        info: str | I18nData | None = ...,
        show_label: bool | None = ...,
        container: bool = ...,
        scale: int | None = ...,
        min_width: int | None = ...,
        interactive: bool | None = ...,
        visible: bool | Literal["hidden"] = ...,
        elem_id: str | None = ...,
        elem_classes: list[str] | str | None = ...,
        render: bool = ...,
        key: int | str | tuple[int | str, ...] | None = ...,
        preserved_by_key: list[str] | str | None = ...,
        load_fn: Callable | None = ...,
        every: Timer | float | None = ...,
        inputs: Component | Sequence[Component] | set[Component] | None = ...,
    ) -> None: ...

    TEMPLATE_DIR = ...
    FRONTEND_DIR = ...
    def get_config(self, cls: type[Block] | None = ...) -> dict[str, Any]: ...
    @property
    def skip_api(self): ...
    @staticmethod
    def get_load_fn_and_initial_value(value, inputs=...): ...
    def attach_load_event(
        self,
        callable: Callable,
        every: Timer | float | None,
        inputs: Component | Sequence[Component] | set[Component] | None = ...,
    ):
        """Add an event that runs `callable`, optionally at interval specified by `every`."""
        ...

    def process_example(self, value):
        """
        Process the input data in a way that can be displayed by the examples dataset component in the front-end.
        By default, this calls the `.postprocess()` method of the component. However, if the `.postprocess()` method is
        computationally intensive, or returns a large payload, a custom implementation may be appropriate.

        For example,  the `process_example()` method of the `gr.Audio()` component only returns the name of the file, not
        the processed audio file. The `.process_example()` method of the `gr.Dataframe()` returns the head of a dataframe
        instead of the full dataframe.

        The return value of this method must be json-serializable to put in the config.
        """
        ...

    def as_example(self, value):
        """Deprecated and replaced by `process_example()`."""
        ...

    def example_inputs(self) -> Any:
        """Deprecated and replaced by `example_payload()` and `example_value()`."""
        ...

    def example_payload(self) -> Any:
        """
        An example input data for this component, e.g. what is passed to this component's preprocess() method.
        This is used to generate the docs for the View API page for Gradio apps using this component.
        """
        ...

    def example_value(self) -> Any:
        """
        An example output data for this component, e.g. what is passed to this component's postprocess() method.
        This is used to generate an example value if this component is used as a template for a custom component.
        """
        ...

    def api_info(self) -> dict[str, Any]:
        """
        The typing information for this component as a dictionary whose values are a list of 2 strings: [Python type, language-agnostic description].
        Keys of the dictionary are: raw_input, raw_output, serialized_input, serialized_output
        """
        ...

    def api_info_as_input(self) -> dict[str, Any]: ...
    def api_info_as_output(self) -> dict[str, Any]: ...
    def flag(self, payload: Any, flag_dir: str | Path = ...) -> str:
        """
        Write the component's value to a format that can be stored in a csv or jsonl format for flagging.
        """
        ...

    def read_from_flag(self, payload: Any):
        """
        Convert the data from the csv or jsonl file into the component state.
        """
        ...

    if TYPE_CHECKING: ...

class FormComponent(Component):
    """
    A base class for components that are typically used in forms (e.g. Textbox, Dropdown). These
    components will be grouped together in the UI to provide a more condensed layout. Components
    that are not rendered in the UI (e.g. State) should also inherit from this class, as it will
    prevent them from breaking the grouping, see: https://github.com/gradio-app/gradio/issues/10330
    """
    def get_expected_parent(self) -> type[Form] | None: ...
    def preprocess(self, payload: Any) -> Any: ...
    def postprocess(self, value): ...

    if TYPE_CHECKING: ...

class StreamingOutput(metaclass=abc.ABCMeta):
    def __init__(self, *args, **kwargs) -> None: ...
    @abc.abstractmethod
    async def stream_output(
        self, value, output_id: str, first_chunk: bool
    ) -> tuple[MediaStreamChunk | None, FileDataDict | dict]: ...
    @abc.abstractmethod
    async def combine_stream(
        self, stream: list[bytes], desired_output_format: str | None = ..., only_file=...
    ) -> GradioDataModel | FileData:
        """Combine all of the stream chunks into a single file.

        This is needed for downloading the stream and for caching examples.
        If `only_file` is True, only the FileData corresponding to the file should be returned (needed for downloading the stream).
        The desired_output_format optionally converts the combined file. Should only be used for cached examples.
        """
        ...

class StreamingInput(metaclass=abc.ABCMeta):
    def __init__(self, *args, **kwargs) -> None: ...
    @abc.abstractmethod
    def check_streamable(self):
        """Used to check if streaming is supported given the input."""
        ...

def component(cls_name: str, render: bool) -> Component: ...
def get_component_instance(comp: str | dict | Component, render: bool = ..., unrender: bool = ...) -> Component:
    """
    Returns a component instance from a string, dict, or Component object.
    Parameters:
        comp: the component to instantiate. If a string, must be the name of a component, e.g. "dropdown". If a dict, must have a "name" key, e.g. {"name": "dropdown", "choices": ["a", "b"]}. If a Component object, will be returned as is.
        render: whether to render the component. If True, renders the component (if not already rendered). If False, does not do anything.
        unrender: whether to unrender the component. If True, unrenders the the component (if already rendered) -- this is useful when constructing an Interface or ChatInterface inside of a Blocks. If False, does not do anything.
    """
    ...
