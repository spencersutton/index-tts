import abc
from abc import ABC, abstractmethod
from collections.abc import Callable, Sequence
from enum import Enum
from pathlib import Path
from typing import TYPE_CHECKING, Any, Literal, TypedDict

from gradio.blocks import Block
from gradio.component_meta import ComponentMeta
from gradio.components import Timer
from gradio.data_classes import FileData, FileDataDict, GradioDataModel, MediaStreamChunk
from gradio.events import EventListener
from gradio.i18n import I18nData
from gradio.layouts import Form

"""Contains all of the components that can be used with Gradio Interface / Blocks.
Along with the docs for each component, you can find the names of example demos that use
each component. These demos are located in the `demo` directory."""
if TYPE_CHECKING:
    class DataframeData(TypedDict):
        headers: list[str]
        data: list[list[str | int | bool]]

class _Keywords(Enum):
    NO_VALUE = ...
    FINISHED_ITERATING = ...

class ComponentBase(ABC, metaclass=ComponentMeta):
    EVENTS: list[EventListener | str] = ...
    @abstractmethod
    def preprocess(self, payload: Any) -> Any: ...
    @abstractmethod
    def postprocess(self, value): ...
    @abstractmethod
    def process_example(self, value): ...
    @abstractmethod
    def api_info(self) -> dict[str, list[str]]: ...
    @abstractmethod
    def example_inputs(self) -> Any: ...
    @abstractmethod
    def flag(self, payload: Any | GradioDataModel, flag_dir: str | Path = ...) -> str: ...
    @abstractmethod
    def read_from_flag(self, payload: Any) -> GradioDataModel | Any: ...
    @property
    @abstractmethod
    def skip_api(self) -> bool: ...
    @classmethod
    def has_event(cls, event: str | EventListener) -> bool: ...
    @classmethod
    def get_component_class_id(cls) -> str: ...

    if TYPE_CHECKING: ...

def server(fn): ...

class Component(ComponentBase, Block):
    def __init__(
        self,
        value: Any = ...,
        *,
        label: str | I18nData | None = ...,
        info: str | I18nData | None = ...,
        show_label: bool | None = ...,
        container: bool = ...,
        scale: int | None = ...,
        min_width: int | None = ...,
        interactive: bool | None = ...,
        visible: bool | Literal["hidden"] = ...,
        elem_id: str | None = ...,
        elem_classes: list[str] | str | None = ...,
        render: bool = ...,
        key: int | str | tuple[int | str, ...] | None = ...,
        preserved_by_key: list[str] | str | None = ...,
        load_fn: Callable | None = ...,
        every: Timer | float | None = ...,
        inputs: Component | Sequence[Component] | set[Component] | None = ...,
    ) -> None: ...

    TEMPLATE_DIR = ...
    FRONTEND_DIR = ...
    def get_config(self, cls: type[Block] | None = ...) -> dict[str, Any]: ...
    @property
    def skip_api(self): ...
    @staticmethod
    def get_load_fn_and_initial_value(value, inputs=...): ...
    def attach_load_event(
        self,
        callable: Callable,
        every: Timer | float | None,
        inputs: Component | Sequence[Component] | set[Component] | None = ...,
    ): ...
    def process_example(self, value): ...
    def as_example(self, value): ...
    def example_inputs(self) -> Any: ...
    def example_payload(self) -> Any: ...
    def example_value(self) -> Any: ...
    def api_info(self) -> dict[str, Any]: ...
    def api_info_as_input(self) -> dict[str, Any]: ...
    def api_info_as_output(self) -> dict[str, Any]: ...
    def flag(self, payload: Any, flag_dir: str | Path = ...) -> str: ...
    def read_from_flag(self, payload: Any): ...

    if TYPE_CHECKING: ...

class FormComponent(Component):
    def get_expected_parent(self) -> type[Form] | None: ...
    def preprocess(self, payload: Any) -> Any: ...
    def postprocess(self, value): ...
    value: Any

    if TYPE_CHECKING: ...

class StreamingOutput(ABC):
    def __init__(self, *args, **kwargs) -> None: ...
    @abc.abstractmethod
    async def stream_output(
        self, value, output_id: str, first_chunk: bool
    ) -> tuple[MediaStreamChunk | None, FileDataDict | dict]: ...
    @abc.abstractmethod
    async def combine_stream(
        self, stream: list[bytes], desired_output_format: str | None = ..., only_file=...
    ) -> GradioDataModel | FileData: ...

class StreamingInput(ABC):
    def __init__(self, *args, **kwargs) -> None: ...
    @abc.abstractmethod
    def check_streamable(self): ...

def component(cls_name: str, render: bool) -> Component: ...
def get_component_instance(comp: str | dict | Component, render: bool = ..., unrender: bool = ...) -> Component: ...
