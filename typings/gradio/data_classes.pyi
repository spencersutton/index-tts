"""
This type stub file was generated by pyright.
"""

import pathlib
from abc import ABC, abstractmethod
from collections.abc import Iterator
from enum import Enum
from typing import Annotated, Any, Literal, NewType, Union
from fastapi import Request
from gradio_client.data_classes import ParameterInfo
from gradio_client.documentation import document
from pydantic import (
    BaseModel,
    GetCoreSchemaHandler,
    GetJsonSchemaHandler,
    JsonValue,
    RootModel,
    ValidationInfo,
    model_validator,
)
from pydantic.json_schema import JsonSchemaValue
from pydantic_core import core_schema
from typing_extensions import NotRequired, TypedDict
from gradio.i18n import I18nData

"""Pydantic data models and other dataclasses. This is the only file that uses Optional[]
typing syntax instead of | None syntax to work with pydantic"""
DeveloperPath = NewType("DeveloperPath", str)
UserProvidedPath = NewType("UserProvidedPath", str)

class CancelBody(BaseModel):
    session_hash: str
    fn_index: int
    event_id: str
    ...

class SimplePredictBody(BaseModel):
    data: list[Any]
    session_hash: str | None = ...

class _StarletteRequestPydanticAnnotation:
    @classmethod
    def __get_pydantic_core_schema__(
        cls, _source_type: Any, _handler: GetCoreSchemaHandler
    ) -> core_schema.CoreSchema: ...
    @classmethod
    def __get_pydantic_json_schema__(
        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler
    ) -> JsonSchemaValue: ...

PydanticStarletteRequest = Annotated[Request, _StarletteRequestPydanticAnnotation]

class PredictBody(BaseModel):
    session_hash: str | None = ...
    event_id: str | None = ...
    data: list[Any]
    event_data: Any | None = ...
    fn_index: int | None = ...
    trigger_id: int | None = ...
    simple_format: bool = ...
    batched: bool | None = ...
    @classmethod
    def __get_pydantic_json_schema__(
        cls, core_schema, handler
    ):  # -> dict[str, str | dict[str, dict[str, str] | dict[str, str | dict[str, str]]] | list[str]]:
        ...

class PredictBodyInternal(PredictBody):
    "Separate class to avoid exposing PydanticStarletteRequest in the API validation"

    request: PydanticStarletteRequest | None = ...

class ResetBody(BaseModel):
    event_id: str
    ...

class VibeEditBody(BaseModel):
    prompt: str
    ...

class VibeCodeBody(BaseModel):
    code: str
    ...

class ComponentServerJSONBody(BaseModel):
    session_hash: str
    component_id: int
    fn_name: str
    data: Any
    ...

class DataWithFiles(BaseModel):
    data: Any
    files: list[tuple[str, bytes]]
    ...

class ComponentServerBlobBody(BaseModel):
    session_hash: str
    component_id: int
    fn_name: str
    data: DataWithFiles
    ...

class InterfaceTypes(Enum):
    STANDARD = ...
    INPUT_ONLY = ...
    OUTPUT_ONLY = ...
    UNIFIED = ...

class GradioBaseModel(ABC):
    def copy_to_dir(self, dir: str | pathlib.Path) -> GradioDataModel: ...
    @classmethod
    @abstractmethod
    def from_json(cls, x) -> GradioDataModel: ...

class JsonData(RootModel):
    """JSON data returned from a component that should not be modified further."""

    root: JsonValue
    ...

class GradioModel(GradioBaseModel, BaseModel):
    @classmethod
    def from_json(cls, x) -> GradioModel: ...

class GradioRootModel(GradioBaseModel, RootModel):
    @classmethod
    def from_json(cls, x) -> GradioRootModel: ...

GradioDataModel = Union[GradioModel, GradioRootModel]

class FileDataDict(TypedDict):
    path: str
    url: NotRequired[str | None]
    size: NotRequired[int | None]
    orig_name: NotRequired[str | None]
    mime_type: NotRequired[str | None]
    is_stream: bool
    meta: NotRequired[dict]
    ...

class FileDataMeta(TypedDict):
    _type: Literal["gradio.FileData"]
    ...

@document()
class FileData(GradioModel):
    """
    The FileData class is a subclass of the GradioModel class that represents a file object within a Gradio interface. It is used to store file data and metadata when a file is uploaded.

    Attributes:
        path: The server file path where the file is stored.
        url: The normalized server URL pointing to the file.
        size: The size of the file in bytes.
        orig_name: The original filename before upload.
        mime_type: The MIME type of the file.
        is_stream: Indicates whether the file is a stream.
        meta: Additional metadata used internally (should not be changed).
    """

    path: str
    url: str | None = ...
    size: int | None = ...
    orig_name: str | None = ...
    mime_type: str | None = ...
    is_stream: bool = ...
    meta: FileDataMeta = ...
    @model_validator(mode="before")
    @classmethod
    def validate_model(cls, v, info: ValidationInfo): ...
    @property
    def is_none(self) -> bool:
        """
        Checks if the FileData object is empty, i.e., all attributes are None.

        Returns:
            bool: True if all attributes (except 'is_stream' and 'meta') are None, False otherwise.
        """
        ...

    @classmethod
    def from_path(cls, path: str) -> FileData:
        """
        Creates a FileData object from a given file path.

        Args:
            path: The file path.

        Returns:
            FileData: An instance of FileData representing the file at the specified path.
        """
        ...

    @classmethod
    def is_file_data(cls, obj: Any) -> bool:
        """
        Checks if an object is a valid FileData instance.

        Args:
            obj: The object to check.

        Returns:
            bool: True if the object is a valid FileData instance, False otherwise.
        """
        ...

class ListFiles(GradioRootModel):
    root: list[FileData]
    def __getitem__(self, index): ...
    def __iter__(self) -> Iterator[FileData]: ...

class _StaticFiles:
    """
    Class to hold all static files for an app
    """

    all_paths = ...
    def __init__(self, paths: list[str | pathlib.Path]) -> None: ...
    @classmethod
    def clear(cls):  # -> None:
        ...

class BodyCSS(TypedDict):
    body_background_fill: str
    body_text_color: str
    body_background_fill_dark: str
    body_text_color_dark: str
    ...

class Layout(TypedDict):
    id: int
    children: NotRequired[list[int | Layout]]
    ...

class Page(TypedDict):
    components: list[int]
    dependencies: list[int]
    layout: Layout
    ...

class BlocksConfigDict(TypedDict):
    version: str
    deep_link_state: NotRequired[Literal["valid", "invalid", "none"]]
    mode: str
    app_id: int
    dev_mode: bool
    vibe_mode: bool
    analytics_enabled: bool
    components: list[dict[str, Any]]
    css: str | None
    connect_heartbeat: bool
    js: str | Literal[True] | None
    head: str | None
    title: str | I18nData
    space_id: str | None
    enable_queue: bool
    show_error: bool
    is_colab: bool
    max_file_size: int | None
    stylesheets: list[str]
    theme: str | None
    protocol: Literal["ws", "sse", "sse_v1", "sse_v2", "sse_v2.1", "sse_v3"]
    body_css: BodyCSS
    fill_height: bool
    fill_width: bool
    theme_hash: str
    layout: NotRequired[Layout]
    dependencies: NotRequired[list[dict[str, Any]]]
    root: NotRequired[str | None]
    username: NotRequired[str | None]
    api_prefix: str
    pwa: NotRequired[bool]
    page: dict[str, Page]
    pages: list[tuple[str, str]]
    current_page: NotRequired[str]
    i18n_translations: NotRequired[dict[str, dict[str, str]] | None]
    mcp_server: NotRequired[bool]
    footer_links: list[str | dict[str, str]]
    ...

class MediaStreamChunk(TypedDict):
    data: bytes
    duration: float
    extension: str
    id: NotRequired[str]
    ...

class ImageData(GradioModel):
    path: str | None = ...
    url: str | None = ...
    size: int | None = ...
    orig_name: str | None = ...
    mime_type: str | None = ...
    is_stream: bool = ...
    meta: dict = ...
    model_config = ...

class Base64ImageData(GradioModel):
    url: str = ...

class APIReturnInfo(TypedDict):
    label: str
    type: dict[str, Any]
    python_type: dict[str, str]
    component: str
    ...

class APIEndpointInfo(TypedDict):
    description: NotRequired[str]
    parameters: list[ParameterInfo]
    returns: list[APIReturnInfo]
    api_visibility: Literal["public", "private", "undocumented"]
    ...

class APIInfo(TypedDict):
    named_endpoints: dict[str, APIEndpointInfo]
    unnamed_endpoints: dict[str, APIEndpointInfo]
    ...
