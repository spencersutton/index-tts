"""
This type stub file was generated by pyright.
"""

import dataclasses
from collections.abc import Callable, Sequence, Set
from typing import TYPE_CHECKING, Any, Literal, Union

from gradio.blocks import Block, BlockContext, Component
from gradio.components import Timer
from gradio.data_classes import FileDataDict
from gradio_client.documentation import document

"""Contains all of the events that can be triggered in a gr.Blocks() app, with the exception
of the on-page-load event, which is defined in gr.Blocks().load()."""
if TYPE_CHECKING: ...

def set_cancel_events(
    triggers: Sequence[EventListenerMethod], cancels: None | dict[str, Any] | list[dict[str, Any]]
):  # -> None:
    ...

@document()
class Dependency(dict):
    def __init__(self, trigger, key_vals, dep_index, fn, associated_timer: Timer | None = ...) -> None:
        """
        The Dependency object is usualy not created directly but is returned when an event listener is set up. It contains the configuration
        data for the event listener, and can be used to set up additional event listeners that depend on the completion of the current event
        listener using .then(), .success(), and .failure().

        Demos: chatbot_consecutive, blocks_chained_events
        """
        ...

    def __call__(self, *args, **kwargs): ...

@document()
class EventData:
    """
    When gr.EventData or one of its subclasses is added as a type hint to an argument of a prediction function, a gr.EventData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener. The gr.EventData object itself contains a `.target` attribute that refers to the component
    that triggered the event, while subclasses of gr.EventData contains additional attributes that are different for each class.

    Example:
        import gradio as gr
        with gr.Blocks() as demo:
            table = gr.Dataframe([[1, 2, 3], [4, 5, 6]])
            gallery = gr.Gallery([("cat.jpg", "Cat"), ("dog.jpg", "Dog")])
            textbox = gr.Textbox("Hello World!")
            statement = gr.Textbox()
            def on_select(value, evt: gr.EventData):
                return f"The {evt.target} component was selected, and its value was {value}."
            table.select(on_select, table, statement)
            gallery.select(on_select, gallery, statement)
            textbox.select(on_select, textbox, statement)
        demo.launch()
    Demos: gallery_selections, tictactoe
    """
    def __init__(self, target: Block | None, _data: Any) -> None:
        """
        Parameters:
            target: The component object that triggered the event. Can be used to distinguish multiple components bound to the same listener.
        """
        ...

    def __getattr__(self, name):  # -> Any:
        ...

@document()
class SelectData(EventData):
    """
    The gr.SelectData class is a subclass of gr.EventData that specifically carries information about the `.select()` event. When gr.SelectData
    is added as a type hint to an argument of an event listener method, a gr.SelectData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.

    Example:
        import gradio as gr
        with gr.Blocks() as demo:
            table = gr.Dataframe([[1, 2, 3], [4, 5, 6]])
            gallery = gr.Gallery([("cat.jpg", "Cat"), ("dog.jpg", "Dog")])
            textbox = gr.Textbox("Hello World!")
            statement = gr.Textbox()
            def on_select(evt: gr.SelectData):
                return f"You selected {evt.value} at {evt.index} from {evt.target}"
            table.select(on_select, table, statement)
            gallery.select(on_select, gallery, statement)
            textbox.select(on_select, textbox, statement)
        demo.launch()
    Demos: gallery_selections, tictactoe
    """
    def __init__(self, target: Block | None, data: Any) -> None: ...

@document()
class KeyUpData(EventData):
    """
    The gr.KeyUpData class is a subclass of gr.EventData that specifically carries information about the `.key_up()` event. When gr.KeyUpData
    is added as a type hint to an argument of an event listener method, a gr.KeyUpData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.

    Example:
        import gradio as gr
        def test(value, key_up_data: gr.KeyUpData):
            return {
                "component value": value,
                "input value": key_up_data.input_value,
                "key": key_up_data.key
            }
        with gr.Blocks() as demo:
            d = gr.Dropdown(["abc", "def"], allow_custom_value=True)
            t = gr.JSON()
            d.key_up(test, d, t)
        demo.launch()
    Demos: dropdown_key_up
    """
    def __init__(self, target: Block | None, data: Any) -> None: ...

@document()
class DeletedFileData(EventData):
    """
    The gr.DeletedFileData class is a subclass of gr.EventData that specifically carries information about the `.delete()` event. When gr.DeletedFileData
    is added as a type hint to an argument of an event listener method, a gr.DeletedFileData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.
    Example:
        import gradio as gr
        def test(delete_data: gr.DeletedFileData):
            return delete_data.file.path
        with gr.Blocks() as demo:
            files = gr.File(file_count="multiple")
            deleted_file = gr.File()
            files.delete(test, None, deleted_file)
        demo.launch()
    Demos: file_component_events
    """
    def __init__(self, target: Block | None, data: FileDataDict) -> None: ...

@document()
class LikeData(EventData):
    """
    The gr.LikeData class is a subclass of gr.EventData that specifically carries information about the `.like()` event. When gr.LikeData
    is added as a type hint to an argument of an event listener method, a gr.LikeData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.
    Example:
        import gradio as gr
        def test(value, like_data: gr.LikeData):
            return {
                "chatbot_value": value,
                "liked_message": like_data.value,
                "liked_index": like_data.index,
                "liked_or_disliked": like_data.liked
            }
        with gr.Blocks() as demo:
            c = gr.Chatbot([("abc", "def")])
            t = gr.JSON()
            c.like(test, c, t)
        demo.launch()
    Demos: chatbot_core_components_simple
    """
    def __init__(self, target: Block | None, data: Any) -> None: ...

@document()
class RetryData(EventData):
    """
    The gr.RetryData class is a subclass of gr.Event data that specifically carries information about the `.retry()` event. When gr.RetryData
    is added as a type hint to an argument of an event listener method, a gr.RetryData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.
    Example:
        import gradio as gr

        def retry(retry_data: gr.RetryData, history: list[gr.MessageDict]):
            history_up_to_retry = history[:retry_data.index]
            new_response = ""
            for token in api.chat_completion(history):
                new_response += token
                yield history + [new_response]

        with gr.Blocks() as demo:
            chatbot = gr.Chatbot()
            chatbot.retry(retry, chatbot, chatbot)
        demo.launch()
    """
    def __init__(self, target: Block | None, data: Any) -> None: ...

@document()
class UndoData(EventData):
    """
    The gr.UndoData class is a subclass of gr.Event data that specifically carries information about the `.undo()` event. When gr.UndoData
    is added as a type hint to an argument of an event listener method, a gr.UndoData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.
    Example:
        import gradio as gr

        def undo(retry_data: gr.UndoData, history: list[gr.MessageDict]):
            history_up_to_retry = history[:retry_data.index]
            return history_up_to_retry

        with gr.Blocks() as demo:
            chatbot = gr.Chatbot()
            chatbot.undo(undo, chatbot, chatbot)
        demo.launch()
    """
    def __init__(self, target: Block | None, data: Any) -> None: ...

@document()
class EditData(EventData):
    """
    The gr.EditData class is a subclass of gr.Event data that specifically carries information about the `.edit()` event. When gr.EditData
    is added as a type hint to an argument of an event listener method, a gr.EditData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.
    Example:
        import gradio as gr

        def edit(edit_data: gr.EditData, history: list[gr.MessageDict]):
            history_up_to_edit = history[:edit_data.index]
            history_up_to_edit[-1] = edit_data.value
            return history_up_to_edit

        with gr.Blocks() as demo:
            chatbot = gr.Chatbot()
            chatbot.undo(edit, chatbot, chatbot)
        demo.launch()
    """
    def __init__(self, target: Block | None, data: Any) -> None: ...

@document()
class DownloadData(EventData):
    """
    The gr.DownloadData class is a subclass of gr.EventData that specifically carries information about the `.download()` event. When gr.DownloadData
    is added as a type hint to an argument of an event listener method, a gr.DownloadData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.
    Example:
        import gradio as gr
        def on_download(download_data: gr.DownloadData):
            return f"Downloaded file: {download_data.file.path}"
        with gr.Blocks() as demo:
            files = gr.File()
            textbox = gr.Textbox()
            files.download(on_download, None, textbox)
        demo.launch()
    """
    def __init__(self, target: Block | None, data: FileDataDict) -> None: ...

@document()
class CopyData(EventData):
    """
    The gr.CopyData class is a subclass of gr.EventData that specifically carries information about the `.copy()` event. When gr.CopyData
    is added as a type hint to an argument of an event listener method, a gr.CopyData object will automatically be passed as the value of that argument.
    The attributes of this object contains information about the event that triggered the listener.
    Example:
        import gradio as gr
        def on_copy(copy_data: gr.CopyData):
            return f"Copied text: {copy_data.value}"
        with gr.Blocks() as demo:
            textbox = gr.Textbox("Hello World!")
            copied = gr.Textbox()
            textbox.copy(on_copy, None, copied)
        demo.launch()
    """
    def __init__(self, target: Block | None, data: Any) -> None: ...

@dataclasses.dataclass
class EventListenerMethod:
    block: Block | None
    event_name: str
    ...

if TYPE_CHECKING:
    EventListenerCallable = Callable[
        [
            Callable[..., Any] | None,
            Component | Sequence[Component] | None,
            Block | Sequence[Block] | Sequence[Component] | Component | None,
            str | None | Literal[False],
            bool,
            Literal["full", "minimal", "hidden"],
            Component | Sequence[Component] | None,
            bool | None,
            bool,
            int,
            bool,
            bool,
            dict[str, Any] | list[dict[str, Any]] | None,
            float | None,
            Literal["once", "multiple", "always_last"] | None,
            str | None,
            int | None | Literal["default"],
            str | None,
            bool,
        ],
        Dependency,
    ]

class EventListener(str):
    def __new__(cls, event_name, *_args, **_kwargs):  # -> Self:
        ...
    def __init__(
        self,
        event_name: str,
        has_trigger: bool = ...,
        config_data: Callable[..., dict[str, Any]] = ...,
        show_progress: Literal["full", "minimal", "hidden"] = ...,
        callback: Callable | None = ...,
        trigger_after: int | None = ...,
        trigger_only_on_success: bool = ...,
        trigger_only_on_failure: bool = ...,
        doc: str = ...,
        connection: Literal["sse", "stream"] = ...,
        event_specific_args: list[dict[str, str]] | None = ...,
    ) -> None: ...
    def set_doc(self, component: str):  # -> None:
        ...
    def copy(self):  # -> EventListener:
        ...

@document()
def on(
    triggers: Sequence[EventListenerCallable] | EventListenerCallable | None = ...,
    fn: Callable[..., Any] | None | Literal["decorator"] = ...,
    inputs: Component | BlockContext | Sequence[Component | BlockContext] | Set[Component | BlockContext] | None = ...,
    outputs: Component | BlockContext | Sequence[Component | BlockContext] | Set[Component | BlockContext] | None = ...,
    *,
    api_visibility: Literal["public", "private", "undocumented"] = ...,
    api_name: str | None = ...,
    api_description: str | None | Literal[False] = ...,
    scroll_to_output: bool = ...,
    show_progress: Literal["full", "minimal", "hidden"] = ...,
    show_progress_on: Component | Sequence[Component] | None = ...,
    queue: bool = ...,
    batch: bool = ...,
    max_batch_size: int = ...,
    preprocess: bool = ...,
    postprocess: bool = ...,
    cancels: dict[str, Any] | list[dict[str, Any]] | None = ...,
    trigger_mode: Literal["once", "multiple", "always_last"] | None = ...,
    js: str | Literal[True] | None = ...,
    concurrency_limit: int | None | Literal["default"] = ...,
    concurrency_id: str | None = ...,
    time_limit: int | None = ...,
    stream_every: float = ...,
    key: int | str | tuple[int | str, ...] | None = ...,
    validator: Callable | None = ...,
) -> Dependency:
    """
    Sets up an event listener that triggers a function when the specified event(s) occur. This is especially
    useful when the same function should be triggered by multiple events. Only a single API endpoint is generated
    for all events in the triggers list.

    Parameters:
        triggers: List of triggers to listen to, e.g. [btn.click, number.change]. If None, will run on app load and changes to any inputs.
        fn: the function to call when this event is triggered. Often a machine learning model's prediction function. Each parameter of the function corresponds to one input component, and the function should return a single value or a tuple of values, with each element in the tuple corresponding to one output component.
        inputs: List of gradio.components to use as inputs. If the function takes no inputs, this should be an empty list.
        outputs: List of gradio.components to use as outputs. If the function returns no outputs, this should be an empty list.
        api_name: defines how the endpoint appears in the API docs. Can be a string or None. If set to a string, the endpoint will be exposed in the API docs with the given name. If None (default), the name of the function will be used as the API endpoint.
        scroll_to_output: If True, will scroll to output component on completion
        show_progress: how to show the progress animation while event is running: "full" shows a spinner which covers the output component area as well as a runtime display in the upper right corner, "minimal" only shows the runtime display, "hidden" shows no progress animation at all,
        show_progress_on: Component or list of components to show the progress animation on. If None, will show the progress animation on all of the output components.
        queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.
        batch: If True, then the function should process a batch of inputs, meaning that it should accept a list of input values for each parameter. The lists should be of equal length (and be up to length `max_batch_size`). The function is then *required* to return a tuple of lists (even if there is only 1 output component), with each list in the tuple corresponding to one output component.
        max_batch_size: Maximum number of inputs to batch together if this is called from the queue (only relevant if batch=True)
        preprocess: If False, will not run preprocessing of component data before running 'fn' (e.g. leaving it as a base64 string if this method is called with the `Image` component).
        postprocess: If False, will not run postprocessing of component data before returning 'fn' output to the browser.
        cancels: A list of other events to cancel when this listener is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method. Functions that have not yet run (or generators that are iterating) will be cancelled, but functions that are currently running will be allowed to finish.
        trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
        js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs', return should be a list of values for output components.
        concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
        concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
        api_visibility: controls the visibility and accessibility of this endpoint. Can be "public" (shown in API docs and callable by clients), "private" (hidden from API docs and not callable by clients), or "undocumented" (hidden from API docs but callable by clients and via gr.load). If fn is None, api_visibility will automatically be set to "private".
        time_limit: The time limit for the function to run. Parameter only used for the `.stream()` event.
        stream_every: The latency (in seconds) at which stream chunks are sent to the backend. Defaults to 0.5 seconds. Parameter only used for the `.stream()` event.
        validator: Optional validation function to run before the main function. If provided, this function will be executed first with queue=False, and only if it completes successfully will the main function be called. The validator receives the same inputs as the main function and should return a `gr.validate()` for each input value.
    Example:
        import gradio as gr
        with gr.Blocks() as demo:
            with gr.Row():
                input = gr.Textbox()
                button = gr.Button("Submit")
            output = gr.Textbox()
            gr.on(
                triggers=[button.click, input.submit],
                fn=lambda x: x,
                inputs=[input],
                outputs=[output]
            )
        demo.launch()
    """
    ...

@document()
def api(
    fn: Callable | Literal["decorator"] = ...,
    *,
    api_name: str | None = ...,
    api_description: str | None = ...,
    queue: bool = ...,
    batch: bool = ...,
    max_batch_size: int = ...,
    concurrency_limit: int | None | Literal["default"] = ...,
    concurrency_id: str | None = ...,
    api_visibility: Literal["public", "private", "undocumented"] = ...,
    time_limit: int | None = ...,
    stream_every: float = ...,
) -> Dependency:
    """
    Sets up an API or MCP endpoint for a generic function without needing define events listeners or components. Derives its typing from type hints in the provided function's signature rather than the components.

    Parameters:
        fn: the function to call when this event is triggered. Often a machine learning model's prediction function. The function should be fully typed, and the type hints will be used to derive the typing information for the API/MCP endpoint.
        api_name: defines how the endpoint appears in the API docs. Can be a string or None. If set to a string, the endpoint will be exposed in the API docs with the given name. If None (default), the name of the function will be used as the API endpoint.
        api_description: Description of the API endpoint. Can be a string, None, or False. If set to a string, the endpoint will be exposed in the API docs with the given description. If None, the function's docstring will be used as the API endpoint description. If False, then no description will be displayed in the API docs.
        queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.
        batch: If True, then the function should process a batch of inputs, meaning that it should accept a list of input values for each parameter. The lists should be of equal length (and be up to length `max_batch_size`). The function is then *required* to return a tuple of lists (even if there is only 1 output component), with each list in the tuple corresponding to one output component.
        max_batch_size: Maximum number of inputs to batch together if this is called from the queue (only relevant if batch=True)
        concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
        concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
        api_visibility: controls the visibility and accessibility of this endpoint. Can be "public" (shown in API docs and callable by clients), "private" (hidden from API docs and not callable by clients), or "undocumented" (hidden from API docs but callable by clients and via gr.load). If fn is None, api_visibility will automatically be set to "private".
        time_limit: The time limit for the function to run. Parameter only used for the `.stream()` event.
        stream_every: The latency (in seconds) at which stream chunks are sent to the backend. Defaults to 0.5 seconds. Parameter only used for the `.stream()` event.
    Example:
        import gradio as gr
        with gr.Blocks() as demo:
            with gr.Row():
                input = gr.Textbox()
                button = gr.Button("Submit")
            output = gr.Textbox()
            def fn(a: int, b: int, c: list[str]) -> tuple[int, str]:
                return a + b, c[a:b]
            gr.api(fn, api_name="add_and_slice")
        _, url, _ = demo.launch()

        from gradio_client import Client
        client = Client(url)
        result = client.predict(
                a=3,
                b=5,
                c=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                api_name="/add_and_slice"
        )
        print(result)
    """
    ...

class Events:
    change = ...
    input = ...
    click = ...
    double_click = ...
    submit = ...
    stop = ...
    edit = ...
    clear = ...
    play = ...
    pause = ...
    stop = ...
    end = ...
    start_recording = ...
    pause_recording = ...
    stop_recording = ...
    focus = ...
    blur = ...
    upload = ...
    release = ...
    select = ...
    stream = ...
    like = ...
    example_select = ...
    option_select = ...
    load = ...
    key_up = ...
    apply = ...
    delete = ...
    tick = ...
    undo = ...
    retry = ...
    expand = ...
    collapse = ...
    download = ...
    copy = ...

all_events = ...
