"""
This type stub file was generated by pyright.
"""

import gradio as gr
from abc import ABC, abstractmethod
from collections.abc import Sequence
from pathlib import Path
from typing import Any, TYPE_CHECKING
from gradio_client.documentation import document
from gradio.events import LikeData
from gradio.components import Component

if TYPE_CHECKING: ...

class FlaggingCallback(ABC):
    """
    An abstract class for defining the methods that any FlaggingCallback should have.
    """
    @abstractmethod
    def setup(self, components: Sequence[Component], flagging_dir: str):  # -> None:
        """
        This method should be overridden and ensure that everything is set up correctly for flag().
        This method gets called once at the beginning of the Interface.launch() method.
        Parameters:
        components: Set of components that will provide flagged data.
        flagging_dir: A string, typically containing the path to the directory where the flagging file should be stored (provided as an argument to Interface.__init__()).
        """
        ...

    @abstractmethod
    def flag(self, flag_data: list[Any], flag_option: str | None = ..., username: str | None = ...) -> int:
        """
        This method should be overridden by the FlaggingCallback subclass and may contain optional additional arguments.
        This gets called every time the <flag> button is pressed.
        Parameters:
        interface: The Interface object that is being used to launch the flagging interface.
        flag_data: The data to be flagged.
        flag_option (optional): In the case that flagging_options are provided, the flag option that is being used.
        username (optional): The username of the user that is flagging the data, if logged in.
        Returns:
        (int) The total number of samples that have been flagged.
        """
        ...

@document()
class SimpleCSVLogger(FlaggingCallback):
    """
    A simplified implementation of the FlaggingCallback abstract class
    provided for illustrative purposes.  Each flagged sample (both the input and output data)
    is logged to a CSV file on the machine running the gradio app.
    Example:
        import gradio as gr
        def image_classifier(inp):
            return {'cat': 0.3, 'dog': 0.7}
        demo = gr.Interface(fn=image_classifier, inputs="image", outputs="label",
                            flagging_callback=SimpleCSVLogger())
    """
    def __init__(self) -> None: ...
    def setup(self, components: Sequence[Component], flagging_dir: str | Path):  # -> None:
        ...
    def flag(self, flag_data: list[Any], flag_option: str | None = ..., username: str | None = ...) -> int: ...

@document()
class ClassicCSVLogger(FlaggingCallback):
    """
    The classic implementation of the FlaggingCallback abstract class in gradio<5.0. Each flagged
    sample (both the input and output data) is logged to a CSV file with headers on the machine running the gradio app.
    Example:
        import gradio as gr
        def image_classifier(inp):
            return {'cat': 0.3, 'dog': 0.7}
        demo = gr.Interface(fn=image_classifier, inputs="image", outputs="label",
                            flagging_callback=ClassicCSVLogger())
    Guides: using-flagging
    """
    def __init__(self, simplify_file_data: bool = ...) -> None: ...
    def setup(self, components: Sequence[Component], flagging_dir: str | Path):  # -> None:
        ...
    def flag(self, flag_data: list[Any], flag_option: str | None = ..., username: str | None = ...) -> int: ...

@document()
class CSVLogger(FlaggingCallback):
    """
    The default implementation of the FlaggingCallback abstract class in gradio>=5.0. Each flagged
    sample (both the input and output data) is logged to a CSV file with headers on the machine running
    the gradio app. Unlike ClassicCSVLogger, this implementation is concurrent-safe and it creates a new
    dataset file every time the headers of the CSV (derived from the labels of the components) change. It also
    only creates columns for "username" and "flag" if the flag_option and username are provided, respectively.

    Example:
        import gradio as gr
        def image_classifier(inp):
            return {'cat': 0.3, 'dog': 0.7}
        demo = gr.Interface(fn=image_classifier, inputs="image", outputs="label",
                            flagging_callback=CSVLogger())
    Guides: using-flagging
    """
    def __init__(
        self, simplify_file_data: bool = ..., verbose: bool = ..., dataset_file_name: str | None = ...
    ) -> None:
        """
        Parameters:
            simplify_file_data: If True, the file data will be simplified before being written to the CSV file. If CSVLogger is being used to cache examples, this is set to False to preserve the original FileData class
            verbose: If True, prints messages to the console about the dataset file creation
            dataset_file_name: The name of the dataset file to be created (should end in ".csv"). If None, the dataset file will be named "dataset1.csv" or the next available number.
        """
        ...

    def setup(self, components: Sequence[Component], flagging_dir: str | Path):  # -> None:
        ...
    def flag(self, flag_data: list[Any], flag_option: str | None = ..., username: str | None = ...) -> int: ...

class ChatCSVLogger:
    """
    Flagging callback for chat conversations.
    Flagged conversations and like/dislike reactions are logged to a CSV file on the machine running the gradio app.
    """
    def __init__(self) -> None: ...
    def setup(self, flagging_dir: str):  # -> None:
        ...
    def flag(self, like_data: LikeData, messages: list):  # -> None:
        ...

class FlagMethod:
    """
    Helper class that contains the flagging options and calls the flagging method. Also
    provides visual feedback to the user when flag is clicked.
    """
    def __init__(
        self, flagging_callback: FlaggingCallback, label: str, value: str | None, visual_feedback: bool = ...
    ) -> None: ...
    def __call__(self, request: gr.Request, *flag_data):  # -> Button | Literal['Error!'] | None:
        ...
    def reset(self):  # -> Button:
        ...
