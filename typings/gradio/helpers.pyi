"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable, Iterable, Sequence
from typing import TYPE_CHECKING, Any, Literal

from gradio import routes
from gradio.components import Component
from gradio.events import EventData
from gradio.i18n import I18nData
from gradio_client.documentation import document

"""
Defines helper methods useful for loading and caching Interface examples.
"""
if TYPE_CHECKING: ...
LOG_FILE = ...

def create_examples(
    examples: list[Any] | list[list[Any]] | str,
    inputs: Component | Sequence[Component],
    outputs: Component | Sequence[Component] | None = ...,
    fn: Callable | None = ...,
    cache_examples: bool | None = ...,
    cache_mode: Literal["eager", "lazy"] | None = ...,
    examples_per_page: int = ...,
    _api_mode: bool = ...,
    label: str | I18nData | None = ...,
    elem_id: str | None = ...,
    run_on_click: bool = ...,
    preprocess: bool = ...,
    postprocess: bool = ...,
    api_visibility: Literal["public", "private", "undocumented"] = ...,
    api_name: str | None = ...,
    api_description: str | None | Literal[False] = ...,
    batch: bool = ...,
    *,
    example_labels: list[str] | None = ...,
    visible: bool | Literal["hidden"] = ...,
    preload: int | Literal[False] = ...,
):  # -> Examples:
    """Top-level synchronous function that creates Examples. Provided for backwards compatibility, i.e. so that gr.Examples(...) can be used to create the Examples component."""
    ...

@document()
class Examples:
    """
    This class is a wrapper over the Dataset component and can be used to create Examples
    for Blocks / Interfaces. Populates the Dataset component with examples and
    assigns event listener so that clicking on an example populates the input/output
    components. Optionally handles example caching for fast inference.

    Demos: calculator_blocks
    Guides: more-on-examples-and-flagging, using-hugging-face-integrations, image-classification-in-pytorch, image-classification-in-tensorflow, image-classification-with-vision-transformers, create-your-own-friends-with-a-gan
    """
    def __init__(
        self,
        examples: list[Any] | list[list[Any]] | str,
        inputs: Component | Sequence[Component],
        outputs: Component | Sequence[Component] | None = ...,
        fn: Callable | None = ...,
        cache_examples: bool | None = ...,
        cache_mode: Literal["eager", "lazy"] | None = ...,
        examples_per_page: int = ...,
        _api_mode: bool = ...,
        label: str | I18nData | None = ...,
        elem_id: str | None = ...,
        run_on_click: bool = ...,
        preprocess: bool = ...,
        postprocess: bool = ...,
        api_visibility: Literal["public", "private", "undocumented"] = ...,
        api_name: str | None = ...,
        api_description: str | None | Literal[False] = ...,
        batch: bool = ...,
        *,
        example_labels: list[str] | None = ...,
        visible: bool | Literal["hidden"] = ...,
        preload: int | Literal[False] = ...,
        _initiated_directly: bool = ...,
    ) -> None:
        """
        Parameters:
            examples: example inputs that can be clicked to populate specific components. Should be nested list, in which the outer list consists of samples and each inner list consists of an input corresponding to each input component. A string path to a directory of examples can also be provided but it should be within the directory with the python file running the gradio app. If there are multiple input components and a directory is provided, a log.csv file must be present in the directory to link corresponding inputs.
            inputs: the component or list of components corresponding to the examples
            outputs: optionally, provide the component or list of components corresponding to the output of the examples. Required if `cache_examples` is not False.
            fn: optionally, provide the function to run to generate the outputs corresponding to the examples. Required if `cache_examples` is not False. Also required if `run_on_click` is True.
            cache_examples: If True, caches examples in the server for fast runtime in examples. If "lazy", then examples are cached (for all users of the app) after their first use (by any user of the app). If None, will use the GRADIO_CACHE_EXAMPLES environment variable, which should be either "true" or "false". In HuggingFace Spaces, this parameter is True (as long as `fn` and `outputs` are also provided). The default option otherwise is False. Note that examples are cached separately from Gradio's queue() so certain features, such as gr.Progress(), gr.Info(), gr.Warning(), etc. will not be displayed in Gradio's UI for cached examples.
            cache_mode: if "lazy", examples are cached after their first use. If "eager", all examples are cached at app launch. If None, will use the GRADIO_CACHE_MODE environment variable if defined, or default to "eager".
            examples_per_page: how many examples to show per page.
            label: the label to use for the examples component (by default, "Examples")
            elem_id: an optional string that is assigned as the id of this component in the HTML DOM.
            run_on_click: if cache_examples is False, clicking on an example does not run the function when an example is clicked. Set this to True to run the function when an example is clicked. Has no effect if cache_examples is True.
            preprocess: if True, preprocesses the example input before running the prediction function and caching the output. Only applies if `cache_examples` is not False.
            postprocess: if True, postprocesses the example output after running the prediction function and before caching. Only applies if `cache_examples` is not False.
            api_visibility: Controls the visibility of the event associated with clicking on the examples. Can be "public" (shown in API docs and callable), "private" (hidden from API docs and not callable), or "undocumented" (hidden from API docs but callable).
            api_name: Defines how the event associated with clicking on the examples appears in the API docs. Can be a string or None. If set to a string, the endpoint will be exposed in the API docs with the given name. If None, an auto-generated name will be used.
            api_description: Description of the event associated with clicking on the examples in the API docs. Can be a string, None, or False. If set to a string, the endpoint will be exposed in the API docs with the given description. If None, the function's docstring will be used as the API endpoint description. If False, then no description will be displayed in the API docs.
            batch: If True, then the function should process a batch of inputs, meaning that it should accept a list of input values for each parameter. Used only if cache_examples is not False.
            example_labels: A list of labels for each example. If provided, the length of this list should be the same as the number of examples, and these labels will be used in the UI instead of rendering the example values.
            visible: If False, the examples component will be hidden in the UI.
            preload: If an integer is provided (and examples are being cached eagerly and none of the input components have a developer-provided `value`), the example at that index in the examples list will be preloaded when the Gradio app is first loaded. If False, no example will be preloaded.
        """
        ...

    def create(self) -> None:
        """Creates the Dataset component to hold the examples"""
        ...

    async def cache(self, example_id: int | None = ...) -> None:
        """
        Caches examples so that their predictions can be shown immediately.
        Parameters:
            example_id: The id of the example to process (zero-indexed). If None, all examples are cached.
        """
        ...

    def load_from_cache(self, example_id: int) -> list[Any]:
        """Loads a particular cached example for the interface.
        Parameters:
            example_id: The id of the example to process (zero-indexed).
        """
        ...

async def merge_generated_values_into_output(
    components: Sequence[Component], generated_values: list, output: list
):  # -> list[Any]:
    ...

class TrackedIterable:
    def __init__(
        self,
        iterable: Iterable | None,
        index: int | float | None,
        length: int | float | None,
        desc: str | None,
        unit: str | None,
        _tqdm=...,
        progress: float | None = ...,
    ) -> None: ...

@document("__call__", "tqdm")
class Progress(Iterable):
    """
    The Progress class provides a custom progress tracker that is used in a function signature.
    To attach a Progress tracker to a function, simply add a parameter right after the input parameters that has a default value set to a `gradio.Progress()` instance.
    The Progress tracker can then be updated in the function by calling the Progress object or using the `tqdm` method on an Iterable.
    Example:
        import gradio as gr
        import time
        def my_function(x, progress=gr.Progress()):
            progress(0, desc="Starting...")
            time.sleep(1)
            for i in progress.tqdm(range(100)):
                time.sleep(0.1)
            return x
        gr.Interface(my_function, gr.Textbox(), gr.Textbox()).launch()
    """
    def __init__(self, track_tqdm: bool = ...) -> None:
        """
        Parameters:
            track_tqdm: If True, the Progress object will track any tqdm.tqdm iterations with the tqdm library in the function.
        """
        ...

    def __len__(self):  # -> int | float | None:
        ...
    def __iter__(self):  # -> Self:
        ...
    def __next__(self):  # -> Self:
        """
        Updates progress tracker with next item in iterable.
        """
        ...

    def __call__(
        self,
        progress: float | tuple[int, int | None] | None,
        desc: str | None = ...,
        total: int | float | None = ...,
        unit: str = ...,
        _tqdm=...,
    ):  # -> float | tuple[int, int | None] | None:
        """
        Updates progress tracker with progress and message text.
        Parameters:
            progress: If float, should be between 0 and 1 representing completion. If Tuple, first number represents steps completed, and second value represents total steps or None if unknown. If None, hides progress bar.
            desc: description to display.
            total: estimated total number of steps.
            unit: unit of iterations.
        """
        ...

    def tqdm(
        self,
        iterable: Iterable | None,
        desc: str | None = ...,
        total: int | float | None = ...,
        unit: str = ...,
        _tqdm=...,
    ):  # -> Self | Iterator[Any]:
        """
        Attaches progress tracker to iterable, like tqdm.
        Parameters:
            iterable: iterable to attach progress tracker to.
            desc: description to display.
            total: estimated total number of steps.
            unit: unit of iterations.
        """
        ...

    def update(self, n: int | float = ...):  # -> None:
        """
        Increases latest iterable with specified number of steps.
        Parameters:
            n: number of steps completed.
        """
        ...

    def close(self, _tqdm):  # -> None:
        """
        Removes iterable with given _tqdm.
        """
        ...

def patch_tqdm() -> None: ...
def create_tracker(
    fn, track_tqdm
):  # -> tuple[Progress, Any] | tuple[Progress, _Wrapped[..., Any, ..., AsyncGenerator[Any, Any]] | _Wrapped[..., Any, ..., CoroutineType[Any, Any, Any]] | _Wrapped[..., Any, ..., Generator[Any, Any, None]] | _Wrapped[..., Any, ..., Any]]:
    ...
def special_args(
    fn: Callable,
    inputs: list[Any] | None = ...,
    request: routes.Request | None = ...,
    event_data: EventData | None = ...,
    component_props: dict[int, dict[str, Any]] | None = ...,
) -> tuple[list, int | None, int | None, list[int]]:
    """
    Checks if function has special arguments Request or EventData (via annotation) or Progress (via default value).
    Also checks if any parameters are type-hinted with gr.Component types, in which case all component props should be passed.
    If inputs is provided, these values will be loaded into the inputs array.
    Parameters:
        fn: function to check.
        inputs: array to load special arguments into.
        request: request to load into inputs.
        event_data: event-related data to load into inputs.
        component_props: dictionary mapping input indices to their full component props.
    Returns:
        updated inputs, progress index, event data index, list of input indices that need component props.
    """
    ...

def update(
    elem_id: str | None = ...,
    elem_classes: list[str] | str | None = ...,
    visible: bool | Literal["hidden"] | None = ...,
    **kwargs: Any,
) -> dict[str, Any]:
    """
    Updates a component's properties. When a function passed into a Gradio Interface or a Blocks
    events returns a value, it typically updates the value of the output component. But it is also possible
    to update the *properties* of an output component (such as the number of lines of a `Textbox` or
    the visibility of an `Row`) by returning a component and passing in the parameters to update in
    the constructor of the component. Alternatively, you can return `gr.update(...)` with any arbitrary
    parameters to update. (This is useful as a shorthand or if the same function can be called with different
    components to update.) This method does not work with the `gr.State` component.

    Parameters:
        elem_id: Use this to update the id of the component in the HTML DOM
        elem_classes: Use this to update the classes of the component in the HTML DOM
        visible: Use this to update the visibility of the component
        kwargs: Any other keyword arguments to update the component's properties.
    Example:
        import gradio as gr
        with gr.Blocks() as demo:
            radio = gr.Radio([1, 2, 4], label="Set the value of the number")
            number = gr.Number(value=2, interactive=True)
            radio.change(fn=lambda value: gr.update(value=value), inputs=radio, outputs=number)
        demo.launch()
    """
    ...

@document()
def validate(is_valid: bool, message: str):  # -> dict[str, str | bool]:
    """
    A special function that can be returned from a Gradio function to set the validation error of an output component.
    """
    ...

@document()
def skip() -> dict:
    """
    A special function that can be returned from a Gradio function to skip updating the output component. This may be useful when
    you want to update the output component conditionally, and in some cases, you want to skip updating the output component.
    If you have multiple output components, you can return `gr.skip()` as part of a tuple to skip updating a specific output component,
    or you can return a single `gr.skip()` to skip updating all output components.
    """
    ...

def log_message(
    message: str,
    title: str,
    level: Literal["info", "warning", "success"] = ...,
    duration: float | None = ...,
    visible: bool = ...,
):  # -> None:
    ...
@document(documentation_group="modals")
def Warning(message: str = ..., duration: float | None = ..., visible: bool = ..., title: str = ...):  # -> None:
    """
    This function allows you to pass custom warning messages to the user. You can do so simply by writing `gr.Warning('message here')` in your function, and when that line is executed the custom message will appear in a modal on the demo. The modal is yellow by default and has the heading: "Warning." Queue must be enabled for this behavior; otherwise, the warning will be printed to the console using the `warnings` library.
    Demos: blocks_chained_events
    Parameters:
        message: The warning message to be displayed to the user. Can be HTML, which will be rendered in the modal.
        duration: The duration in seconds that the warning message should be displayed for. If None or 0, the message will be displayed indefinitely until the user closes it.
        visible: Whether the error message should be displayed in the UI.
        title: The title to be displayed to the user at the top of the modal.
    Example:
        import gradio as gr
        def hello_world():
            gr.Warning('This is a warning message.')
            return "hello world"
        with gr.Blocks() as demo:
            md = gr.Markdown()
            demo.load(hello_world, inputs=None, outputs=[md])
        demo.launch()
    """
    ...

@document(documentation_group="modals")
def Info(message: str = ..., duration: float | None = ..., visible: bool = ..., title: str = ...):  # -> None:
    """
    This function allows you to pass custom info messages to the user. You can do so simply by writing `gr.Info('message here')` in your function, and when that line is executed the custom message will appear in a modal on the demo. The modal is gray by default and has the heading: "Info." Queue must be enabled for this behavior; otherwise, the message will be printed to the console.
    Demos: blocks_chained_events
    Parameters:
        message: The info message to be displayed to the user. Can be HTML, which will be rendered in the modal.
        duration: The duration in seconds that the info message should be displayed for. If None or 0, the message will be displayed indefinitely until the user closes it.
        visible: Whether the error message should be displayed in the UI.
        title: The title to be displayed to the user at the top of the modal.
    Example:
        import gradio as gr
        def hello_world():
            gr.Info('This is some info.')
            return "hello world"
        with gr.Blocks() as demo:
            md = gr.Markdown()
            demo.load(hello_world, inputs=None, outputs=[md])
        demo.launch()
    """
    ...

@document(documentation_group="modals")
def Success(message: str = ..., duration: float | None = ..., visible: bool = ..., title: str = ...):  # -> None:
    """
    This function allows you to pass custom success messages to the user. You can do so simply by writing `gr.Success('message here')` in your function, and when that line is executed the custom message will appear in a modal on the demo. The modal is green by default and has the heading: "Success." Queue must be enabled for this behavior; otherwise, the message will be printed to the console.
    Parameters:
        message: The success message to be displayed to the user. Can be HTML, which will be rendered in the modal.
        duration: The duration in seconds that the success message should be displayed for. If None or 0, the message will be displayed indefinitely until the user closes it.
        visible: Whether the error message should be displayed in the UI.
        title: The title to be displayed to the user at the top of the modal.
    Example:
        def hello_world():
            gr.Success('Operation completed successfully!')
            return "hello world"
        with gr.Blocks() as demo:
            md = gr.Markdown()
            demo.load(hello_world, inputs=None, outputs=[md])
        demo.launch()
    """
    ...
