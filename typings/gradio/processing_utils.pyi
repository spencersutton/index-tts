"""
This type stub file was generated by pyright.
"""

from pathlib import Path
from typing import TYPE_CHECKING, Any, TypeVar

import numpy as np
from gradio.blocks import Block
from gradio.data_classes import JsonData
from PIL import Image

sync_transport = ...
async_transport = ...
sync_client = ...
log = ...
if TYPE_CHECKING: ...

def to_binary(x: str | dict) -> bytes:
    """Converts a base64 string or dictionary to a binary string that can be sent in a POST."""
    ...

def extract_base64_data(x: str) -> str:
    """Just extracts the base64 data from a general base64 string."""
    ...

def encode_plot_to_base64(plt, format: str = ...):  # -> str:
    ...
def get_pil_exif_bytes(pil_image):  # -> None:
    ...
def get_pil_metadata(pil_image):  # -> PngInfo:
    ...
def encode_pil_to_bytes(pil_image, format=...):  # -> bytes:
    ...

hash_seed = ...

def hash_file(file_path: str | Path, chunk_num_blocks: int = ...) -> str: ...
def hash_url(url: str) -> str: ...
def hash_bytes(bytes: bytes):  # -> str:
    ...
def hash_base64(base64_encoding: str, chunk_num_blocks: int = ...) -> str: ...
def save_pil_to_cache(img: Image.Image, cache_dir: str, name: str = ..., format: str = ...) -> str: ...
def save_img_array_to_cache(arr: np.ndarray, cache_dir: str, format: str = ...) -> str: ...
def save_audio_to_cache(data: np.ndarray, sample_rate: int, format: str, cache_dir: str) -> str: ...
def detect_audio_format(data: bytes) -> str:
    """Detect audio format from file header bytes.

    Args:
        data: File content as bytes

    Returns:
        Detected file extension with dot (e.g., ".wav", ".mp3") or empty string if not detected
    """
    ...

def save_bytes_to_cache(data: bytes, file_name: str, cache_dir: str) -> str: ...
def save_file_to_cache(file_path: str | Path, cache_dir: str) -> str:
    """Returns a temporary file path for a copy of the given file path if it does
    not already exist. Otherwise returns the path to the existing temp file."""
    ...

PUBLIC_HOSTNAME_WHITELIST = ...

def is_public_ip(ip: str) -> bool: ...

T = TypeVar("T")

def lru_cache_async(maxsize: int = ...):  # -> Callable[..., Callable[..., Awaitable[T]]]:
    ...
async def async_ssrf_protected_download(url: str, cache_dir: str) -> str: ...
def unsafe_download(url: str, cache_dir: str) -> str: ...
def ssrf_protected_download(url: str, cache_dir: str) -> str: ...

save_url_to_cache = ...

def save_base64_to_cache(base64_encoding: str, cache_dir: str, file_name: str | None = ...) -> str:
    """Converts a base64 encoding to a file and returns the path to the file if
    the file doesn't already exist. Otherwise returns the path to the existing file.
    """
    ...

def move_resource_to_block_cache(url_or_file_path: str | Path | None, block: Block) -> str | None:
    """This method has been replaced by Block.move_resource_to_block_cache(), but is
    left here for backwards compatibility for any custom components created in Gradio 4.2.0 or earlier.
    """
    ...

def check_all_files_in_cache(data: JsonData):  # -> None:
    ...
def move_files_to_cache(
    data: Any, block: Block, postprocess: bool = ..., check_in_upload_folder=..., keep_in_cache=...
):
    """Move any files in `data` to cache and (optionally), adds URL prefixes (/file=...) needed to access the cached file.
    Also handles the case where the file is on an external Gradio app (/proxy=...).

    Runs after .postprocess() and before .preprocess().

    Args:
        data: The input or output data for a component. Can be a dictionary or a dataclass
        block: The component whose data is being processed
        postprocess: Whether its running from postprocessing
        check_in_upload_folder: If True, instead of moving the file to cache, checks if the file is in already in cache (exception if not).
        keep_in_cache: If True, the file will not be deleted from cache when the server is shut down.
    """
    ...

async def async_move_files_to_cache(
    data: Any, block: Block, postprocess: bool = ..., check_in_upload_folder=..., keep_in_cache=...
) -> dict:
    """Move any files in `data` to cache and (optionally), adds URL prefixes (/file=...) needed to access the cached file.
    Also handles the case where the file is on an external Gradio app (/proxy=...).

    Runs after .postprocess() and before .preprocess().

    Args:
        data: The input or output data for a component. Can be a dictionary or a dataclass
        block: The component whose data is being processed
        postprocess: Whether its running from postprocessing
        check_in_upload_folder: If True, instead of moving the file to cache, checks if the file is in already in cache (exception if not).
        keep_in_cache: If True, the file will not be deleted from cache when the server is shut down.
    """
    ...

def add_root_url(data: dict | list, root_url: str, previous_root_url: str | None): ...
def resize_and_crop(img, size, crop_type=...):  # -> Image:
    """
    Resize and crop an image to fit the specified size.
    args:
        size: `(width, height)` tuple. Pass `None` for either width or height
        to only crop and resize the other.
        crop_type: can be 'top', 'middle' or 'bottom', depending on this
            value, the image will cropped getting the 'top/left', 'middle' or
            'bottom/right' of the image to fit the size.
    raises:
        ValueError: if an invalid `crop_type` is provided.
    """
    ...

def audio_from_file(filename: str, crop_min: float = ..., crop_max: float = ...) -> tuple[int, np.ndarray]: ...
def audio_to_file(sample_rate, data, filename, format=...):  # -> None:
    ...
def convert_to_16_bit_wav(data): ...
def ffmpeg_installed() -> bool: ...
def video_is_playable(video_filepath: str) -> bool:
    """Determines if a video is playable in the browser.

    A video is playable if it has a playable container and codec.
        .mp4 -> h264
        .webm -> vp9
        .ogg -> theora
    """
    ...

def convert_video_to_playable_mp4(video_path: str) -> str:
    """Convert the video to mp4. If something goes wrong return the original video."""
    ...

def get_video_length(video_path: str | Path):  # -> float:
    ...
