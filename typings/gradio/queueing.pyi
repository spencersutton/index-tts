from typing import TYPE_CHECKING, Any, Literal

import fastapi
from gradio import routes
from gradio.block_function import BlockFunction
from gradio.blocks import Blocks
from gradio.data_classes import PredictBodyInternal
from gradio.helpers import TrackedIterable
from gradio.server_messages import EstimationMessage, EventMessage

from .block_function import BlockFunction

if TYPE_CHECKING: ...

class Event:
    def __init__(
        self, session_hash: str | None, fn: BlockFunction, request: fastapi.Request, username: str | None
    ) -> None: ...
    @property
    def streaming(self):  # -> bool:
        ...
    @property
    def is_finished(self):  # -> bool:
        ...

class EventQueue:
    def __init__(self, concurrency_id: str, concurrency_limit: int | None) -> None: ...

class ProcessTime:
    def __init__(self) -> None: ...
    def add(self, time: float):  # -> None:
        ...

class Queue:
    def __init__(
        self,
        live_updates: bool,
        concurrency_count: int,
        update_intervals: float,
        max_size: int | None,
        blocks: Blocks,
        default_concurrency_limit: int | None | Literal["not_set"] = ...,
    ) -> None: ...
    def compute_analytics_summary(self, event_analytics):  # -> dict[str, dict[Any, Any]]:
        ...
    def start(self):  # -> None:
        ...
    def create_event_queue_for_fn(self, block_fn: BlockFunction):  # -> None:
        ...
    def close(self):  # -> None:
        ...
    def send_message(self, event: Event, event_message: EventMessage):  # -> None:
        ...
    def __len__(self) -> int:  # -> int:
        ...
    async def push(
        self, body: PredictBodyInternal, request: fastapi.Request, username: str | None
    ) -> tuple[
        bool,
        str | list[dict[str, Any]],
        Literal["success", "error", "queue_full", "validator_error"],
    ]: ...
    def set_server_app(self, app: routes.App):  # -> None:
        ...
    def get_active_worker_count(self) -> int: ...
    def get_events(self) -> tuple[list[Event], bool, str] | None: ...
    async def start_processing(self) -> None: ...
    async def start_progress_updates(self) -> None: ...
    def set_progress(self, event_id: str, iterables: list[TrackedIterable] | None):  # -> None:
        ...
    def log_message(
        self,
        event_id: str,
        log: str,
        title: str,
        level: Literal["info", "warning", "success"],
        duration: float | None = ...,
        visible: bool = ...,
    ):  # -> None:
        ...
    async def clean_events(self, *, session_hash: str | None = ..., event_id: str | None = ...) -> None: ...
    async def notify_clients(self) -> None: ...
    def broadcast_estimations(self, concurrency_id: str, after: int | None = ...) -> None: ...
    def get_status(self) -> EstimationMessage: ...
    @staticmethod
    async def wait_for_event(event: Event) -> str: ...
    @staticmethod
    async def timeout(timeout: float) -> str: ...
    @staticmethod
    async def wait_for_event_or_timeout(event: Event, timeout: float) -> Literal["signal", "timeout"]: ...
    @staticmethod
    async def wait_for_batch(events: list[Event], timeouts: list[float]) -> tuple[list[Event], list[Event]]: ...
    async def process_events(self, events: list[Event], batch: bool, begin_time: float) -> None: ...
    async def reset_iterators(self, event_id: str):  # -> None:
        ...

def process_validation_response(
    validation_response: list[dict[str, Any]] | dict[str, Any], fn: BlockFunction | None = ...
) -> tuple[bool, list[dict[str, Any]]]: ...
