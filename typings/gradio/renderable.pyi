"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable, Sequence
from typing import TYPE_CHECKING, Literal

from gradio.blocks import Block
from gradio.components import Component
from gradio.events import EventListenerCallable
from gradio_client.documentation import document

if TYPE_CHECKING: ...

class Renderable:
    def __init__(
        self,
        fn: Callable,
        inputs: Sequence[Component],
        triggers: list[tuple[Block | None, str]],
        concurrency_limit: int | None | Literal["default"],
        concurrency_id: str | None,
        trigger_mode: Literal["once", "multiple", "always_last"] | None,
        queue: bool,
        show_progress: Literal["full", "minimal", "hidden"],
    ) -> None: ...
    def apply(self, *args, **kwargs):  # -> None:
        ...

@document()
def render(
    inputs: Sequence[Component] | Component | None = ...,
    triggers: Sequence[EventListenerCallable] | EventListenerCallable | None = ...,
    *,
    queue: bool = ...,
    trigger_mode: Literal["once", "multiple", "always_last"] | None = ...,
    concurrency_limit: int | None | Literal["default"] = ...,
    concurrency_id: str | None = ...,
    show_progress: Literal["full", "minimal", "hidden"] = ...,
):  # -> Callable[..., Any]:
    """
    The render decorator allows Gradio Blocks apps to have dynamic layouts, so that the components and event listeners in your app can change depending on custom logic.
    Attaching a @gr.render decorator to a function will cause the function to be re-run whenever the inputs are changed (or specified triggers are activated). The function contains the components and event listeners that will update based on the inputs.

    The basic usage of @gr.render is as follows:\n
    1. Create a function and attach the @gr.render decorator to it.\n
    2. Add the input components to the `inputs=` argument of @gr.render, and create a corresponding argument in your function for each component.\n
    3. Add all components inside the function that you want to update based on the inputs. Any event listeners that use these components should also be inside this function.\n
    Parameters:
        inputs: List of gradio.components to use as inputs. If the function takes no inputs, this should be an empty list.
        triggers: List of triggers to listen to, e.g. [btn.click, number.change]. If None, will listen to changes to any inputs.
        queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.
        trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
        concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
        concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
    Example:
        import gradio as gr

        with gr.Blocks() as demo:
            input_text = gr.Textbox()

            @gr.render(inputs=input_text)
            def show_split(text):
                if len(text) == 0:
                    gr.Markdown("## No Input Provided")
                else:
                    for letter in text:
                        with gr.Row():
                            text = gr.Textbox(letter)
                            btn = gr.Button("Clear")
                            btn.click(lambda: gr.Textbox(value=""), None, text)
    """
    ...
