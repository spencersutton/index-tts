"""
This type stub file was generated by pyright.
"""

from collections import deque
from collections.abc import AsyncGenerator, Callable
from contextlib import AbstractAsyncContextManager
from dataclasses import dataclass as python_dataclass
from typing import TYPE_CHECKING, Any, BinaryIO, Union

import fastapi
import httpx
from gradio.blocks import BlockFunction, Blocks, BlocksConfig
from gradio.data_classes import BlocksConfigDict, MediaStreamChunk, PredictBody, PredictBodyInternal
from gradio.helpers import EventData
from gradio.routes import App
from gradio_client.documentation import document
from starlette.datastructures import FormData, Headers, MutableHeaders, UploadFile
from starlette.responses import Response
from starlette.types import ASGIApp, Receive, Scope, Send

if TYPE_CHECKING: ...
config_lock = ...
API_PREFIX = ...

class Obj:
    """
    Using a class to convert dictionaries into objects. Used by the `Request` class.
    Credit: https://www.geeksforgeeks.org/convert-nested-python-dictionary-to-object/
    """
    def __init__(self, dict_) -> None: ...
    def __getitem__(self, item):  # -> Any:
        ...
    def __setitem__(self, item, value):  # -> None:
        ...
    def __iter__(self):  # -> Generator[tuple[str, dict[str, Any]] | tuple[str, Any], Any, None]:
        ...
    def __contains__(self, item) -> bool: ...
    def get(self, item, default=...):  # -> Any | None:
        ...
    def keys(self):  # -> dict_keys[str, Any]:
        ...
    def values(self):  # -> dict_values[str, Any]:
        ...
    def items(self):  # -> dict_items[str, Any]:
        ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def pop(self, item, default=...):  # -> Any | None:
        ...

@document()
class Request:
    """
    A Gradio request object that can be used to access the request headers, cookies,
    query parameters and other information about the request from within the prediction
    function. The class is a thin wrapper around the fastapi.Request class. Attributes
    of this class include: `headers`, `client`, `query_params`, `session_hash`, and `path_params`. If
    auth is enabled, the `username` attribute can be used to get the logged in user. In some environments,
    the dict-like attributes (e.g. `requests.headers`, `requests.query_params`) of this class are automatically
    converted to dictionaries, so we recommend converting them to dictionaries before accessing
    attributes for consistent behavior in different environments.
    Example:
        import gradio as gr
        def echo(text, request: gr.Request):
            if request:
                print("Request headers dictionary:", dict(request.headers))
                print("Query parameters:", dict(request.query_params))
                print("IP address:", request.client.host)
                print("Gradio session hash:", request.session_hash)
            return text
        io = gr.Interface(echo, "textbox", "textbox").launch()
    Demos: request_ip_headers
    """
    def __init__(
        self,
        request: fastapi.Request | None = ...,
        username: str | None = ...,
        session_hash: str | None = ...,
        **kwargs,
    ) -> None:
        """
        Can be instantiated with either a fastapi.Request or by manually passing in
        attributes (needed for queueing).
        Parameters:
            request: A fastapi.Request
            username: The username of the logged in user (if auth is enabled)
            session_hash: The session hash of the current session. It is unique for each page load.
        """
        ...

    def dict_to_obj(self, d):  # -> Any:
        ...
    def __getattr__(self, name: str):  # -> Any:
        ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __setstate__(self, state: dict[str, Any]):  # -> None:
        ...

@document()
class Header(str):
    """A string that represents a header value in an incoming HTTP request to the Gradio app.

    When you type a function argument of type `Header`, Gradio will automatically extract that header from the request and pass it to the function.
    Note that it's common for header values to use hyphens, e.g. `x-forwarded-host`, and these will automatically be converted to underscores.
    So make sure you use underscores in your function arguments.

    Example:
        import gradio as gr

        def make_api_request_on_behalf_of_user(prompt: str, x_api_token: gr.Header):
            return "Hello from the API" if not x_api_token else "Hello from the API with token!"

        demo = gr.Interface(
            make_api_request_on_behalf_of_user,
            [
                gr.Textbox(label="Prompt"),
            ],
            gr.Textbox(label="Response"),
        )

        demo.launch(mcp_server=True)
    """

    ...

class FnIndexInferError(Exception): ...

def get_fn(blocks: Blocks, api_name: str | None, body: PredictBody) -> BlockFunction: ...
def compile_gr_request(
    body: PredictBodyInternal, fn: BlockFunction, username: str | None, request: fastapi.Request | None
):  # -> list[Request] | Request:
    ...
def restore_session_state(app: App, body: PredictBodyInternal):  # -> tuple[SessionState, AsyncIterator[Any] | None]:
    ...
def prepare_event_data(blocks_config: BlocksConfig, body: PredictBodyInternal) -> EventData: ...
async def call_process_api(
    app: App, body: PredictBodyInternal, gr_request: Request | list[Request], fn: BlockFunction, root_path: str
):  # -> dict[str, Any]:
    ...
def get_first_header_value(request: fastapi.Request, header_name: str):  # -> str | None:
    ...
def get_request_origin(request: fastapi.Request, route_path: str) -> httpx.URL:
    """
    Examines the request headers to determine the origin of the request.
    If the request includes the x-forwarded-host header, it is used directly to determine the origin.
    Otherwise, the request url is used and the route path is stripped off.

    The returned URL is a httpx.URL object without a trailing slash, e.g. "https://example.com"
    """
    ...

def get_api_call_path(request: fastapi.Request) -> str:
    """
    Extracts the API call path from the request URL.

    If the URL (without query parameters) ends with "{API_PREFIX}/queue/join", that exact path is returned.
    Otherwise, if the URL contains "{API_PREFIX}/call", the substring starting from "{API_PREFIX}/call" is returned.
    This allows for dynamic API calls to methods other than "predict".

    Raises:
        ValueError: If the request URL does not match any recognized API call pattern.
    """
    ...

def get_root_url(request: fastapi.Request, route_path: str, root_path: str | None) -> str:
    """
    Gets the root url of the Gradio app (i.e. the public url of the app) without a trailing slash.

    This is how the root_url is resolved:
    1. If a user provides a `root_path` manually that is a full URL, it is returned directly.
    2. If the request has an x-forwarded-host header (e.g. because it is behind a proxy), the root url is
    constructed from the x-forwarded-host header. In this case, `route_path` is not used to construct the root url.
    3. Otherwise, the root url is constructed from the request url. The query parameters and `route_path` are stripped off.
    And if a relative `root_path` is provided, and it is not already the subpath of the URL, it is appended to the root url.

    In cases (2) and (3), We also check to see if the x-forwarded-proto header is present, and if so, convert the root url to https.
    And if there are multiple hosts in the x-forwarded-host or multiple protocols in the x-forwarded-proto, the first one is used.
    """
    ...

class GradioUploadFile(UploadFile):
    """UploadFile with a sha attribute."""
    def __init__(
        self, file: BinaryIO, *, size: int | None = ..., filename: str | None = ..., headers: Headers | None = ...
    ) -> None: ...

@python_dataclass(frozen=True)
class FileUploadProgressUnit:
    filename: str
    chunk_size: int
    ...

@python_dataclass
class FileUploadProgressTracker:
    deque: deque[FileUploadProgressUnit]
    is_done: bool
    ...

class FileUploadProgressNotTrackedError(Exception): ...
class FileUploadProgressNotQueuedError(Exception): ...

class FileUploadProgress:
    def __init__(self) -> None: ...
    def track(self, upload_id: str):  # -> None:
        ...
    async def is_tracked(self, upload_id: str) -> bool: ...
    def append(self, upload_id: str, filename: str, message_bytes: bytes):  # -> None:
        ...
    def set_done(self, upload_id: str):  # -> None:
        ...
    def is_done(self, upload_id: str):  # -> bool:
        ...
    def stop_tracking(self, upload_id: str):  # -> None:
        ...
    def pop(self, upload_id: str) -> FileUploadProgressUnit: ...

class GradioMultiPartParser:
    """Vendored from starlette.MultipartParser.

    Thanks starlette!

    Made the following modifications
        - Use GradioUploadFile instead of UploadFile
        - Use NamedTemporaryFile instead of SpooledTemporaryFile
        - Compute hash of data as the request is streamed

    """

    max_header_size = ...
    def __init__(
        self,
        headers: Headers,
        stream: AsyncGenerator[bytes],
        *,
        max_files: int | float = ...,
        max_fields: int | float = ...,
        upload_id: str | None = ...,
        upload_progress: FileUploadProgress | None = ...,
        max_file_size: int | float,
        max_header_size: int = ...,
    ) -> None: ...
    def on_part_begin(self) -> None: ...
    def on_part_data(self, data: bytes, start: int, end: int) -> None: ...
    def on_part_end(self) -> None: ...
    def on_header_field(self, data: bytes, start: int, end: int) -> None: ...
    def on_header_value(self, data: bytes, start: int, end: int) -> None: ...
    def on_header_end(self) -> None: ...
    def on_headers_finished(self) -> None: ...
    def on_end(self) -> None: ...
    async def parse(self) -> FormData: ...

def move_uploaded_files_to_cache(files: list[str], destinations: list[str]) -> None: ...
def update_root_in_config(config: BlocksConfigDict, root: str) -> BlocksConfigDict:
    """
    Updates the root "key" in the config dictionary to the new root url. If the
    root url has changed, all of the urls in the config that correspond to component
    file urls are updated to use the new root url.
    """
    ...

def update_example_values_to_use_public_url(api_info: dict[str, Any]) -> dict[str, Any]:
    """
    Updates the example values in the api_info dictionary to use a public url
    """
    ...

def compare_passwords_securely(input_password: str, correct_password: str) -> bool: ...
def starts_with_protocol(string: str) -> bool:
    """This regex matches strings that start with a scheme (one or more characters not including colon, slash, or space)
    followed by ://, or start with just //, \\/, /\\, or \\ as they are interpreted as SMB paths on Windows.
    """
    ...

def get_hostname(url: str) -> str:
    """
    Returns the hostname of a given url, or an empty string if the url cannot be parsed.
    Examples:
        get_hostname("https://www.gradio.app") -> "www.gradio.app"
        get_hostname("localhost:7860") -> "localhost"
        get_hostname("127.0.0.1") -> "127.0.0.1"
    """
    ...

class CustomCORSMiddleware:
    def __init__(self, app: ASGIApp, strict_cors: bool = ...) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...
    def preflight_response(self, request_headers: Headers) -> Response: ...
    async def simple_response(self, scope: Scope, receive: Receive, send: Send, request_headers: Headers) -> None: ...
    def is_valid_origin(self, request_headers: Headers) -> bool: ...
    @staticmethod
    def allow_explicit_origin(headers: MutableHeaders, origin: str) -> None: ...

def delete_files_created_by_app(blocks: Blocks, age: int | None) -> None:
    """Delete files that are older than age. If age is None, delete all files."""
    ...

async def delete_files_on_schedule(app: App, frequency: int, age: int) -> None:
    """Startup task to delete files created by the app based on time since last modification."""
    ...

def create_lifespan_handler(
    user_lifespan: Callable[[App], AbstractAsyncContextManager] | None,
    frequency: int | None = ...,
    age: int | None = ...,
) -> Callable[[App], AbstractAsyncContextManager]:
    """Return a context manager that applies _lifespan_handler and user_lifespan if it exists."""
    ...

class MediaStream:
    def __init__(self, desired_output_format: str | None = ...) -> None: ...
    async def add_segment(self, data: MediaStreamChunk | None):  # -> None:
        ...
    def end_stream(self):  # -> None:
        ...

def create_url_safe_hash(data: bytes, digest_size=...):  # -> str:
    """Create a URL-safe short hash of the data. Used to generate unique short deep links."""
    ...

def slugify(value):  # -> str:
    """
    Convert to ASCII. Convert spaces or repeated dashes to single dashes.
    Remove characters that aren't alphanumerics, underscores, or hyphens.
    Convert to lowercase. Also strip leading and trailing whitespace,
    dashes, and underscores.
    """
    ...
