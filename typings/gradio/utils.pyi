"""
This type stub file was generated by pyright.
"""

import asyncio
import threading
from abc import ABC, abstractmethod
from collections import OrderedDict
from collections.abc import Callable, Iterable, MutableMapping, Sequence
from contextlib import contextmanager
from pathlib import Path
from types import ModuleType
from typing import TYPE_CHECKING, Any, Generic, Literal, ParamSpec, TypeVar

from gradio.blocks import BlockContext, Blocks
from gradio.components import Component
from gradio.data_classes import BlocksConfigDict, DeveloperPath, UserProvidedPath
from gradio.routes import App, Request
from gradio.state_holder import SessionState
from gradio.themes import ThemeClass as Theme
from gradio_client.documentation import document

"""Handy utility functions."""
if TYPE_CHECKING: ...
P = ParamSpec("P")
T = TypeVar("T")
BUILT_IN_THEMES: dict[str, Theme] = ...

def get_package_version() -> str: ...
def safe_get_lock() -> asyncio.Lock:
    """Get asyncio.Lock() without fear of getting an Exception.

    Needed because in reload mode we import the Blocks object outside
    the main thread.
    """
    ...

def safe_get_stop_event() -> asyncio.Event: ...

class DynamicBoolean(int):
    def __init__(self, value: int) -> None: ...
    def __bool__(self):  # -> bool:
        ...
    def set(self, value: int):  # -> None:
        ...

NO_RELOAD = ...

class BaseReloader(ABC):
    @property
    @abstractmethod
    def running_app(self) -> App: ...
    def swap_blocks(self, demo: Blocks):  # -> None:
        ...

class ServerReloader(BaseReloader):
    @property
    @abstractmethod
    def stop_event(self) -> threading.Event: ...
    def stop(self) -> None: ...
    def get_demo_name(self, module: ModuleType, default_name: str) -> str: ...

class SpacesReloader(ServerReloader):
    def __init__(
        self, app: App, watch_dirs: list[str], watch_module: ModuleType, stop_event: threading.Event, demo_name: str
    ) -> None: ...
    @property
    def running_app(self) -> App: ...
    @property
    def stop_event(self) -> threading.Event: ...
    def prerun(self, *_args, **_kwargs):  # -> None:
        ...
    def postrun(self, *_args, **_kwargs):  # -> bool:
        ...

class SourceFileReloader(ServerReloader):
    def __init__(
        self,
        app: App,
        watch_dirs: list[str],
        watch_module_name: str,
        demo_file: str,
        watch_module: ModuleType,
        stop_event: threading.Event,
        demo_name: str,
        encoding=...,
    ) -> None: ...
    @property
    def running_app(self) -> App: ...
    @property
    def stop_event(self) -> threading.Event: ...
    def should_watch(self) -> bool: ...
    def alert_change(self, change_type: Literal["reload", "error"] = ...):  # -> None:
        ...
    def swap_blocks(self, demo: Blocks):  # -> None:
        ...

def watchfn_spaces(reloader: SpacesReloader):  # -> None:
    ...
def watchfn(reloader: SourceFileReloader) -> None:
    """Watch python files in a given module.

    get_changes is taken from uvicorn's default file watcher.
    """
    ...

def deep_equal(a: Any, b: Any) -> bool:
    """
    Deep equality check for component values.

    Prefer orjson for performance and compatibility with numpy arrays/dataframes/torch tensors.
    If objects are not serializable by orjson, fall back to regular equality check.
    """
    ...

def reassign_keys(old_blocks: Blocks, new_blocks: Blocks):  # -> None:
    ...
def colab_check() -> bool:
    """
    Check if interface is launching from Google Colab
    :return is_colab (bool): True or False
    """
    ...

def is_hosted_notebook() -> bool:
    """
    Check if Gradio app is launching from a hosted notebook such as Kaggle or Sagemaker.
    """
    ...

def ipython_check() -> bool:
    """
    Check if interface is launching from iPython (not colab)
    :return is_ipython (bool): True or False
    """
    ...

def get_space() -> str | None: ...
def is_zero_gpu_space() -> bool: ...
def get_theme(theme: Theme | str | None) -> Theme: ...
def download_if_url(article: str) -> str: ...

HASH_SEED_PATH = ...

def get_hash_seed() -> str: ...
def get_default_args(func: Callable) -> list[Any]: ...
def safe_deepcopy(obj: Any) -> Any: ...
def assert_configs_are_equivalent_besides_ids(
    config1: BlocksConfigDict, config2: BlocksConfigDict, root_keys: tuple = ...
):  # -> Literal[True]:
    """Allows you to test if two different Blocks configs produce the same demo.

    Parameters:
    config1 (dict): nested dict with config from the first Blocks instance
    config2 (dict): nested dict with config from the second Blocks instance
    root_keys (Tuple): an interable consisting of which keys to test for equivalence at
        the root level of the config. By default, only "mode" is tested,
        so keys like "version" are ignored.
    """
    ...

def delete_none(_dict: dict, skip_value: bool = ..., skip_props: list[str] | None = ...) -> dict:
    """
    Delete keys whose values are None from a dictionary
    """
    ...

def resolve_singleton(_list: list[Any] | Any) -> Any: ...
def get_all_components() -> list[type[Component] | type[BlockContext]]: ...
def core_gradio_components():  # -> list[type[Component] | type[BlockContext]]:
    ...
def component_or_layout_class(cls_name: str) -> type[Component] | type[BlockContext]:
    """
    Returns the component, template, or layout class with the given class name, or
    raises a ValueError if not found.

    Parameters:
    cls_name (str): lower-case string class name of a component
    Returns:
    cls: the component class
    """
    ...

def run_coro_in_background(func: Callable, *args, **kwargs):  # -> Task[Any]:
    """
    Runs coroutines in background.

    Warning, be careful to not use this function in other than FastAPI scope, because the event_loop has not started yet.
    You can use it in any scope reached by FastAPI app.

    correct scope examples: endpoints in routes, Blocks.process_api
    incorrect scope examples: Blocks.launch

    Use startup_events in routes.py if you need to run a coro in background in Blocks.launch().


    Example:
        utils.run_coro_in_background(fn, *args, **kwargs)

    Args:
        func:
        *args:
        **kwargs:

    Returns:

    """
    ...

def run_sync_iterator_async(iterator):
    """Helper for yielding StopAsyncIteration from sync iterators."""
    ...

class SyncToAsyncIterator:
    """Treat a synchronous iterator as async one."""
    def __init__(self, iterator, limiter) -> None: ...
    def __aiter__(self):  # -> Self:
        ...
    async def __anext__(self): ...
    def aclose(self):  # -> None:
        ...

async def async_iteration(iterator): ...
@contextmanager
def set_directory(path: Path | str):  # -> Generator[None, Any, None]:
    """Context manager that sets the working directory to the given path."""
    ...

@contextmanager
def no_raise_exception():  # -> Generator[None, Any, None]:
    """Context manager that suppresses exceptions."""
    ...

def sanitize_value_for_csv(value: str | float) -> str | float:
    """
    Sanitizes a value that is being written to a CSV file to prevent CSV injection attacks.
    Reference: https://owasp.org/www-community/attacks/CSV_Injection
    """
    ...

def sanitize_list_for_csv(values: list[Any]) -> list[Any]:
    """
    Sanitizes a list of values (or a list of list of values) that is being written to a
    CSV file to prevent CSV injection attacks.
    """
    ...

def append_unique_suffix(name: str, list_of_names: list[str]):  # -> str:
    """Appends a numerical suffix to `name` so that it does not appear in `list_of_names`."""
    ...

def validate_url(possible_url: str) -> bool: ...
def is_prop_update(val):  # -> bool:
    ...
def function_wrapper(
    f: Callable,
    before_fn: Callable | None = ...,
    before_args: Iterable | None = ...,
    after_fn: Callable | None = ...,
    after_args: Iterable | None = ...,
):  # -> _Wrapped[..., Any, ..., AsyncGenerator[Any, Any]] | _Wrapped[..., Any, ..., CoroutineType[Any, Any, Any]] | _Wrapped[..., Any, ..., Generator[Any, Any, None]] | _Wrapped[..., Any, ..., Any]:
    ...
def get_function_with_locals(
    fn: Callable,
    blocks: Blocks,
    event_id: str | None,
    in_event_listener: bool,
    request: Request | None,
    state: SessionState | None,
):  # -> _Wrapped[..., Any, ..., AsyncGenerator[Any, Any]] | _Wrapped[..., Any, ..., CoroutineType[Any, Any, Any]] | _Wrapped[..., Any, ..., Generator[Any, Any, None]] | _Wrapped[..., Any, ..., Any]:
    ...
async def cancel_tasks(task_ids: set[str]) -> list[str]: ...
def set_task_name(task, session_hash: str, fn_index: int, event_id: str, batch: bool):  # -> None:
    ...
def get_cancelled_fn_indices(dependencies: list[dict[str, Any]]) -> list[int]: ...
def get_type_hints(fn):  # -> dict[Any, Any] | dict[str, Any]:
    ...
def is_special_typed_parameter(name, parameter_types):  # -> TypeIs[type[Any]] | bool:
    ...
def check_function_inputs_match(fn: Callable, inputs: Sequence, inputs_as_dict: bool):  # -> str | None:
    """
    Checks if the input component set matches the function
    Returns: None if valid or if the function does not have a signature (e.g. is a built in),
    or a string error message if mismatch
    """
    ...

class TupleNoPrint(tuple):
    def __repr__(self):  # -> Literal['']:
        ...
    def __str__(self) -> str: ...

class MatplotlibBackendMananger:
    def __enter__(self):  # -> None:
        ...
    def __exit__(self, exc_type, exc_val, exc_tb):  # -> None:
        ...

def tex2svg(formula, *_args):  # -> str:
    ...
def abspath(path: str | Path) -> Path: ...
def is_in_or_equal(path_1: str | Path, path_2: str | Path) -> bool:
    """
    True if path_1 is a descendant (i.e. located within) path_2 or if the paths are the
    same, returns False otherwise.
    Parameters:
        path_1: str or Path (to file or directory)
        path_2: str or Path (to file or directory)
    """
    ...

@document()
def set_static_paths(paths: str | Path | list[str | Path]) -> None:
    """
    Set the static paths to be served by the gradio app.

    Static files are are served directly from the file system instead of being copied. They are served to users with The Content-Disposition HTTP header set to "inline"
    when sending these files to users. This indicates that the file should be displayed directly in the browser window if possible.
    This function is useful when you want to serve files that you know will not be modified during the lifetime of the gradio app (like files used in gr.Examples).
    By setting static paths, your app will launch faster and it will consume less disk space.
    Calling this function will set the static paths for all gradio applications defined in the same interpreter session until it is called again or the session ends.

    Parameters:
        paths: filepath or list of filepaths or directory names to be served by the gradio app. If it is a directory name, ALL files located within that directory will be considered static and not moved to the gradio cache. This also means that ALL files in that directory will be accessible over the network.
    Example:
        import gradio as gr

        # Paths can be a list of strings or pathlib.Path objects
        # corresponding to filenames or directories.
        gr.set_static_paths(paths=["test/test_files/"])

        # The example files and the default value of the input
        # will not be copied to the gradio cache and will be served directly.
        demo = gr.Interface(
            lambda s: s.rotate(45),
            gr.Image(value="test/test_files/cheetah1.jpg", type="pil"),
            gr.Image(),
            examples=["test/test_files/bus.png"],
        )

        demo.launch()
    """
    ...

def is_static_file(file_path: Any):  # -> bool:
    """Returns True if the file is a static file (and not moved to cache)"""
    ...

HTML_TAG_RE = ...

def remove_html_tags(raw_html: str | None) -> str: ...
def find_user_stack_level() -> int:
    """
    Find the first stack frame not inside Gradio.
    """
    ...

class NamedString(str):
    """
    Subclass of str that includes a .name attribute equal to the value of the string itself. This class is used when returning
    a value from the `.preprocess()` methods of the File and UploadButton components. Before Gradio 4.0, these methods returned a file
    object which was then converted to a string filepath using the `.name` attribute. In Gradio 4.0, these methods now return a str
    filepath directly, but to maintain backwards compatibility, we use this class instead of a regular str.
    """
    def __init__(self, *args) -> None: ...

def default_input_labels():  # -> Generator[str, Any, Never]:
    """
    A generator that provides default input labels for components when the user's function
    does not have named parameters. The labels are of the form "input 0", "input 1", etc.
    """
    ...

def get_extension_from_file_path_or_url(file_path_or_url: str) -> str:
    """
    Returns the file extension (without the dot) from a file path or URL. If the file path or URL does not have a file extension, returns an empty string.
    For example, "https://example.com/avatar/xxxx.mp4?se=2023-11-16T06:51:23Z&sp=r" would return "mp4".
    """
    ...

K = TypeVar("K")
V = TypeVar("V")

class LRUCache[K, V](OrderedDict):
    def __init__(self, max_size: int = ...) -> None: ...
    def __setitem__(self, key: K, value: V) -> None: ...
    def __getitem__(self, key: K) -> V: ...

def get_cache_folder() -> Path: ...
def diff(old, new):  # -> list[Any]:
    ...
def get_upload_folder() -> str: ...
def get_function_params(func: Callable) -> list[tuple[str, bool, Any, Any]]:
    """
    Gets the parameters of a function as a list of tuples of the form (name, has_default, default_value, type_hint).
    Excludes *args and **kwargs, as well as args that are Gradio-specific, such as gr.Request, gr.EventData, gr.OAuthProfile, and gr.OAuthToken.
    """
    ...

def get_return_types(func: Callable) -> list: ...
def simplify_file_data_in_str(s):  # -> str:
    """
    If a FileData dictionary has been dumped as part of a string, this function will replace the dict with just the str filepath
    """
    ...

def sync_fn_to_generator(fn):  # -> Callable[..., Generator[Any, Any, None]]:
    ...
def async_fn_to_generator(fn):  # -> Callable[..., AsyncGenerator[Any, Any]]:
    ...
def async_lambda(f: Callable) -> Callable:
    """Turn a function into an async function.
    Useful for internal event handlers defined as lambda functions used in the codebase
    """
    ...

class FileSize:
    B = ...
    KB = ...
    MB = ...
    GB = ...
    TB = ...

def connect_heartbeat(config: BlocksConfigDict, blocks) -> bool:
    """
    Determines whether a heartbeat is required for a given config.
    """
    ...

def deep_hash(obj):  # -> str:
    """Compute a hash for a deeply nested data structure."""
    ...

def error_payload(error: BaseException | None, show_error: bool) -> dict[str, bool | str | float | None]: ...

class UnhashableKeyDict(MutableMapping):
    """
    Essentially a list of key-value tuples that allows for keys that are not hashable,
    but acts like a dictionary for convenience.
    """
    def __init__(self) -> None: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value):  # -> None:
        ...
    def __delitem__(self, key):  # -> None:
        ...
    def __iter__(self):  # -> Generator[Any, None, None]:
        ...
    def __len__(self):  # -> int:
        ...
    def as_list(self):  # -> list[Any]:
        ...

def safe_join(directory: DeveloperPath, path: UserProvidedPath) -> str:
    """Safely path to a base directory to avoid escaping the base directory.
    Borrowed from: werkzeug.security.safe_join"""
    ...

def is_allowed_file(
    path: Path,
    blocked_paths: Sequence[str | Path],
    allowed_paths: Sequence[str | Path],
    created_paths: Sequence[str | Path],
) -> tuple[bool, Literal["in_blocklist", "allowed", "created", "not_created_or_allowed"]]: ...
def get_node_path():  # -> str | None:
    ...
def none_or_singleton_to_list(value: Any) -> list: ...
def get_icon_path(icon_name: str) -> str:
    """Get the path to an icon file in the "gradio/icons/" directory
    and return it as a static file path so that it can be used by components.

    Parameters:
        icon_name: Name of the icon file (e.g. "plus.svg")
    Returns:
        str: Full path to the icon file served as a static file
    """
    ...

def dict_factory(items):  # -> dict[Any, Any]:
    """
    A utility function to convert a dataclass that includes pydantic fields to a dictionary.
    """
    ...

def get_function_description(fn: Callable) -> tuple[str, dict[str, str], list[str]]:
    """
    Get the description of a function, its parameters, and return values by parsing the docstring.
    The docstring should be formatted as follows: first lines are the description
    of the function, then a line starts with "Args:", "Parameters:", or "Arguments:",
    followed by lines of the form "param_name: description", then optionally lines
    that starts with "Returns:" followed by descriptions of return values. All lines
    after the "Returns:" line are added in the `returns` list (including e.g. "Examples").

    Parameters:
        fn: The function to get the docstring for.

    Returns:
        - The docstring of the function
        - A dictionary of parameter names and their descriptions
        - A list of return value descriptions
    """
    ...

async def safe_aclose_iterator(iterator, timeout=..., retry_interval=...):  # -> None:
    """
    Safely close generators by calling the aclose method.
    Sync generators are tricky because if you call `aclose` while the loop is running
    then you get a ValueError and the generator will not shut down gracefully.
    So the solution is to retry calling the aclose method until we succeed (with timeout).
    """
    ...
