import asyncio
import threading
from abc import ABC, abstractmethod
from collections import OrderedDict, UserString
from collections.abc import Callable, Iterable, MutableMapping, Sequence
from contextlib import contextmanager
from pathlib import Path
from types import ModuleType
from typing import Any, Literal, ParamSpec, TypeVar

from gradio.blocks import BlockContext, Blocks
from gradio.components import Component
from gradio.data_classes import BlocksConfigDict, DeveloperPath, UserProvidedPath
from gradio.routes import App, Request
from gradio.state_holder import SessionState
from gradio.themes import ThemeClass as Theme
from gradio_client.documentation import document

"""Handy utility functions."""

P = ParamSpec("P")
T = TypeVar("T")
BUILT_IN_THEMES: dict[str, Theme] = ...

def get_package_version() -> str: ...
def safe_get_lock() -> asyncio.Lock: ...
def safe_get_stop_event() -> asyncio.Event: ...

class DynamicBoolean(int):
    def __init__(self, value: int) -> None: ...
    def __bool__(self) -> bool:  # -> bool:
        ...
    def set(self, value: int):  # -> None:
        ...

NO_RELOAD = ...

class BaseReloader(ABC):
    @property
    @abstractmethod
    def running_app(self) -> App: ...
    def swap_blocks(self, demo: Blocks):  # -> None:
        ...

class ServerReloader(BaseReloader):
    @property
    @abstractmethod
    def stop_event(self) -> threading.Event: ...
    def stop(self) -> None: ...
    def get_demo_name(self, module: ModuleType, default_name: str) -> str: ...

class SpacesReloader(ServerReloader):
    def __init__(
        self, app: App, watch_dirs: list[str], watch_module: ModuleType, stop_event: threading.Event, demo_name: str
    ) -> None: ...
    @property
    def running_app(self) -> App: ...
    @property
    def stop_event(self) -> threading.Event: ...
    def prerun(self, *_args, **_kwargs):  # -> None:
        ...
    def postrun(self, *_args, **_kwargs):  # -> bool:
        ...

class SourceFileReloader(ServerReloader):
    def __init__(
        self,
        app: App,
        watch_dirs: list[str],
        watch_module_name: str,
        demo_file: str,
        watch_module: ModuleType,
        stop_event: threading.Event,
        demo_name: str,
        encoding=...,
    ) -> None: ...
    @property
    def running_app(self) -> App: ...
    @property
    def stop_event(self) -> threading.Event: ...
    def should_watch(self) -> bool: ...
    def alert_change(self, change_type: Literal["reload", "error"] = ...):  # -> None:
        ...
    def swap_blocks(self, demo: Blocks):  # -> None:
        ...

def watchfn_spaces(reloader: SpacesReloader):  # -> None:
    ...
def watchfn(reloader: SourceFileReloader) -> None: ...
def deep_equal(a: Any, b: Any) -> bool: ...
def reassign_keys(old_blocks: Blocks, new_blocks: Blocks):  # -> None:
    ...
def colab_check() -> bool: ...
def is_hosted_notebook() -> bool: ...
def ipython_check() -> bool: ...
def get_space() -> str | None: ...
def is_zero_gpu_space() -> bool: ...
def get_theme(theme: Theme | str | None) -> Theme: ...
def download_if_url(article: str) -> str: ...

HASH_SEED_PATH = ...

def get_hash_seed() -> str: ...
def get_default_args(func: Callable) -> list[Any]: ...
def safe_deepcopy(obj: Any) -> Any: ...
def assert_configs_are_equivalent_besides_ids(
    config1: BlocksConfigDict, config2: BlocksConfigDict, root_keys: tuple = ...
):  # -> Literal[True]:

    ...
def delete_none(_dict: dict, skip_value: bool = ..., skip_props: list[str] | None = ...) -> dict: ...
def resolve_singleton(_list: list[Any] | Any) -> Any: ...
def get_all_components() -> list[type[Component | BlockContext]]: ...
def core_gradio_components():  # -> list[type[Component] | type[BlockContext]]:
    ...
def component_or_layout_class(cls_name: str) -> type[Component | BlockContext]: ...
def run_coro_in_background(func: Callable, *args, **kwargs):  # -> Task[Any]:

    ...
def run_sync_iterator_async(iterator): ...

class SyncToAsyncIterator:
    def __init__(self, iterator, limiter) -> None: ...
    def __aiter__(self):  # -> Self:
        ...
    async def __anext__(self): ...
    def aclose(self):  # -> None:
        ...

async def async_iteration(iterator): ...
@contextmanager
def set_directory(path: Path | str):  # -> Generator[None, Any, None]:

    ...
@contextmanager
def no_raise_exception():  # -> Generator[None, Any, None]:

    ...
def sanitize_value_for_csv(value: str | float) -> str | float: ...
def sanitize_list_for_csv(values: list[Any]) -> list[Any]: ...
def append_unique_suffix(name: str, list_of_names: list[str]):  # -> str:

    ...
def validate_url(possible_url: str) -> bool: ...
def is_prop_update(val):  # -> bool:
    ...
def function_wrapper(
    f: Callable,
    before_fn: Callable | None = ...,
    before_args: Iterable | None = ...,
    after_fn: Callable | None = ...,
    after_args: Iterable | None = ...,
):  # -> _Wrapped[..., Any, ..., AsyncGenerator[Any, Any]] | _Wrapped[..., Any, ..., CoroutineType[Any, Any, Any]] | _Wrapped[..., Any, ..., Generator[Any, Any, None]] | _Wrapped[..., Any, ..., Any]:
    ...
def get_function_with_locals(
    fn: Callable,
    blocks: Blocks,
    event_id: str | None,
    in_event_listener: bool,
    request: Request | None,
    state: SessionState | None,
):  # -> _Wrapped[..., Any, ..., AsyncGenerator[Any, Any]] | _Wrapped[..., Any, ..., CoroutineType[Any, Any, Any]] | _Wrapped[..., Any, ..., Generator[Any, Any, None]] | _Wrapped[..., Any, ..., Any]:
    ...
async def cancel_tasks(task_ids: set[str]) -> list[str]: ...
def set_task_name(task, session_hash: str, fn_index: int, event_id: str, batch: bool):  # -> None:
    ...
def get_cancelled_fn_indices(dependencies: list[dict[str, Any]]) -> list[int]: ...
def get_type_hints(fn):  # -> dict[Any, Any] | dict[str, Any]:
    ...
def is_special_typed_parameter(name, parameter_types):  # -> TypeIs[type[Any]] | bool:
    ...
def check_function_inputs_match(fn: Callable, inputs: Sequence, inputs_as_dict: bool):  # -> str | None:

    ...

class TupleNoPrint(tuple): ...

class MatplotlibBackendMananger:
    def __enter__(self):  # -> None:
        ...
    def __exit__(self, exc_type, exc_val, exc_tb):  # -> None:
        ...

def tex2svg(formula, *_args):  # -> str:
    ...
def abspath(path: str | Path) -> Path: ...
def is_in_or_equal(path_1: str | Path, path_2: str | Path) -> bool: ...
@document()
def set_static_paths(paths: str | Path | list[str | Path]) -> None: ...
def is_static_file(file_path: Any):  # -> bool:

    ...

HTML_TAG_RE = ...

def remove_html_tags(raw_html: str | None) -> str: ...
def find_user_stack_level() -> int: ...

class NamedString(UserString):
    def __init__(self, *args) -> None: ...

def default_input_labels():  # -> Generator[str, Any, Never]:

    ...
def get_extension_from_file_path_or_url(file_path_or_url: str) -> str: ...

K = TypeVar("K")
V = TypeVar("V")

class LRUCache[K, V](OrderedDict):
    def __init__(self, max_size: int = ...) -> None: ...
    def __setitem__(self, key: K, value: V) -> None: ...
    def __getitem__(self, key: K) -> V: ...

def get_cache_folder() -> Path: ...
def diff(old, new):  # -> list[Any]:
    ...
def get_upload_folder() -> str: ...
def get_function_params(func: Callable) -> list[tuple[str, bool, Any, Any]]: ...
def get_return_types(func: Callable) -> list: ...
def simplify_file_data_in_str(s):  # -> str:

    ...
def sync_fn_to_generator(fn):  # -> Callable[..., Generator[Any, Any, None]]:
    ...
def async_fn_to_generator(fn):  # -> Callable[..., AsyncGenerator[Any, Any]]:
    ...
def async_lambda(f: Callable) -> Callable: ...

class FileSize:
    B = ...
    KB = ...
    MB = ...
    GB = ...
    TB = ...

def connect_heartbeat(config: BlocksConfigDict, blocks) -> bool: ...
def deep_hash(obj):  # -> str:

    ...
def error_payload(error: BaseException | None, show_error: bool) -> dict[str, bool | str | float | None]: ...

class UnhashableKeyDict(MutableMapping):
    def __init__(self) -> None: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None:  # -> None:
        ...
    def __delitem__(self, key) -> None:  # -> None:
        ...
    def __iter__(self):  # -> Generator[Any, None, None]:
        ...
    def __len__(self) -> int:  # -> int:
        ...
    def as_list(self):  # -> list[Any]:
        ...

def safe_join(directory: DeveloperPath, path: UserProvidedPath) -> str: ...
def is_allowed_file(
    path: Path,
    blocked_paths: Sequence[str | Path],
    allowed_paths: Sequence[str | Path],
    created_paths: Sequence[str | Path],
) -> tuple[bool, Literal["in_blocklist", "allowed", "created", "not_created_or_allowed"]]: ...
def get_node_path():  # -> str | None:
    ...
def none_or_singleton_to_list(value: Any) -> list: ...
def get_icon_path(icon_name: str) -> str: ...
def dict_factory(items):  # -> dict[Any, Any]:

    ...
def get_function_description(fn: Callable) -> tuple[str, dict[str, str], list[str]]: ...
async def safe_aclose_iterator(iterator, timeout=..., retry_interval=...):  # -> None:

    ...
