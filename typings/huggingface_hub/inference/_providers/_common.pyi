"""
This type stub file was generated by pyright.
"""

from typing import Any, Dict, List, Optional, Union, overload
from huggingface_hub.hf_api import InferenceProviderMapping
from huggingface_hub.inference._common import RequestParameters

logger = ...
HARDCODED_MODEL_INFERENCE_MAPPING: dict[str, dict[str, InferenceProviderMapping]] = ...

@overload
def filter_none(obj: dict[str, Any]) -> dict[str, Any]: ...
@overload
def filter_none(obj: list[Any]) -> list[Any]: ...
def filter_none(obj: dict[str, Any] | list[Any]) -> dict[str, Any] | list[Any]: ...

class TaskProviderHelper:
    """Base class for task-specific provider helpers."""
    def __init__(self, provider: str, base_url: str, task: str) -> None: ...
    def prepare_request(
        self,
        *,
        inputs: Any,
        parameters: dict[str, Any],
        headers: dict,
        model: str | None,
        api_key: str | None,
        extra_payload: dict[str, Any] | None = ...,
    ) -> RequestParameters:
        """
        Prepare the request to be sent to the provider.

        Each step (api_key, model, headers, url, payload) can be customized in subclasses.
        """
        ...

    def get_response(self, response: bytes | dict, request_params: RequestParameters | None = ...) -> Any:
        """
        Return the response in the expected format.

        Override this method in subclasses for customized response handling."""
        ...

class BaseConversationalTask(TaskProviderHelper):
    """
    Base class for conversational (chat completion) tasks.
    The schema follows the OpenAI API format defined here: https://platform.openai.com/docs/api-reference/chat
    """
    def __init__(self, provider: str, base_url: str) -> None: ...

class BaseTextGenerationTask(TaskProviderHelper):
    """
    Base class for text-generation (completion) tasks.
    The schema follows the OpenAI API format defined here: https://platform.openai.com/docs/api-reference/completions
    """
    def __init__(self, provider: str, base_url: str) -> None: ...

def recursive_merge(dict1: dict, dict2: dict) -> dict: ...
