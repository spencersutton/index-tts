if __package__ or "." in __name__: ...

class _SwigNonDynamicMeta(type):
    __setattr__ = ...

class ImmutableSentencePieceText_ImmutableSentencePiece:
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    piece = ...
    piece_as_bytes = ...
    surface = ...
    surface_as_bytes = ...
    id = ...
    begin = ...
    end = ...

    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class ImmutableSentencePieceText:
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    def SerializeAsString(self): ...

    text = ...
    text_as_bytes = ...
    score = ...
    class ImmutableSentencePieceIterator:
        def __init__(self, proto) -> None: ...
        def __len__(self) -> int: ...
        def __getitem__(self, index):  # -> list[Any]:
            ...

        __repr__ = ...

    @property
    def pieces(self):  # -> ImmutableSentencePieceIterator:
        ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class ImmutableNBestSentencePieceText:
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    def SerializeAsString(self): ...

    class ImmutableSentencePieceTextIterator:
        def __init__(self, proto) -> None: ...
        def __len__(self) -> int: ...
        def __getitem__(self, index):  # -> list[Any]:
            ...

        __repr__ = ...

    @property
    def nbests(self):  # -> ImmutableSentencePieceTextIterator:
        ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class SentencePieceProcessor:
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    def LoadFromSerializedProto(self, serialized: bytes): ...
    def SetEncodeExtraOptions(self, extra_option: str): ...
    def SetDecodeExtraOptions(self, extra_option: str): ...
    def SetVocabulary(self, valid_vocab: str): ...
    def ResetVocabulary(self): ...
    def LoadVocabulary(self, filename: str, threshold: int): ...
    def CalculateEntropy(self, *args): ...
    def GetPieceSize(self): ...
    def PieceToId(self, piece: str) -> int: ...
    def IdToPiece(self, id: int) -> str: ...
    def GetScore(self, id: int) -> float: ...
    def IsUnknown(self, id: int) -> bool: ...
    def IsControl(self, id: int) -> bool: ...
    def IsUnused(self, id: int) -> bool: ...
    def IsByte(self, id: int) -> bool: ...
    def unk_id(self) -> int: ...
    def bos_id(self) -> int: ...
    def eos_id(self) -> int: ...
    def pad_id(self) -> int: ...
    def serialized_model_proto(self): ...
    def LoadFromFile(self, arg): ...
    def Init(
        self,
        model_file=...,
        model_proto=...,
        out_type=...,
        add_bos=...,
        add_eos=...,
        reverse=...,
        emit_unk_piece=...,
        enable_sampling=...,
        nbest_size=...,
        alpha=...,
        num_threads=...,
    ):  # -> None:

        ...
    def Encode(
        self,
        input: str | list[str],
        out_type: type = ...,
        add_bos: bool = ...,
        add_eos: bool = ...,
        reverse: bool = ...,
        emit_unk_piece: bool = ...,
        enable_sampling: bool = ...,
        nbest_size: int = ...,
        alpha: float = ...,
        num_threads: int = ...,
    ) -> list[str]: ...
    def EncodeAsPieces(self, input, **kwargs): ...
    def EncodeAsIds(self, input, **kwargs): ...
    def EncodeAsSerializedProto(self, input, **kwargs): ...
    def EncodeAsImmutableProto(self, input, **kwargs): ...
    def SampleEncodeAsPieces(self, input, nbest_size=..., alpha=..., **kwargs): ...
    def SampleEncodeAsIds(self, input, nbest_size=..., alpha=..., **kwargs): ...
    def SampleEncodeAsSerializedProto(self, input, nbest_size=..., alpha=..., **kwargs): ...
    def SampleEncodeAsImmutableProto(self, input, nbest_size=..., alpha=..., **kwargs): ...
    def NBestEncode(
        self,
        input,
        out_type=...,
        add_bos=...,
        add_eos=...,
        reverse=...,
        emit_unk_piece=...,
        nbest_size=...,
    ):  # -> list[Any]:

        ...
    def NBestEncodeAsPieces(self, input, nbest_size=..., **kwargs):  # -> list[Any]:
        ...
    def NBestEncodeAsIds(self, input, nbest_size=..., **kwargs):  # -> list[Any]:
        ...
    def NBestEncodeAsSerializedProto(self, input, nbest_size=..., **kwargs):  # -> list[Any]:
        ...
    def NBestEncodeAsImmutableProto(self, input, nbest_size=..., **kwargs):  # -> list[Any]:
        ...
    def SampleEncodeAndScore(
        self,
        input,
        out_type=...,
        add_bos=...,
        add_eos=...,
        reverse=...,
        emit_unk_piece=...,
        num_samples=...,
        alpha=...,
        wor=...,
        include_best=...,
    ):  # -> list[Any]:

        ...
    def SampleEncodeAndScoreAsPieces(self, input, num_samples=..., alpha=..., **kwargs):  # -> list[Any]:
        ...
    def SampleEncodeAndScoreAsIds(self, input, num_samples=..., alpha=..., **kwargs):  # -> list[Any]:
        ...
    def SampleEncodeAndScoreAsSerializedProto(self, input, num_samples=..., alpha=..., **kwargs):  # -> list[Any]:
        ...
    def SampleEncodeAndScoreAsImmutableProto(self, input, num_samples=..., alpha=..., **kwargs):  # -> list[Any]:
        ...
    def Decode(self, input, out_type=..., num_threads=...): ...
    def DecodePieces(self, input, out_type=..., **kwargs): ...
    def DecodeIds(self, input, out_type=..., **kwargs): ...
    def DecodePiecesAsSerializedProto(self, input, out_type=..., **kwargs): ...
    def DecodeIdsAsSerializedProto(self, input, out_type=..., **kwargs): ...
    def DecodePiecesAsImmutableProto(self, input, out_type=..., **kwargs): ...
    def DecodeIdsAsImmutableProto(self, input, out_type=..., **kwargs): ...
    def CalculateEntropy(self, input, alpha, num_threads=...): ...
    def Normalize(self, input, with_offsets=...):  # -> list[Any]:
        ...
    def OverrideNormalizerSpec(self, **kwargs): ...
    def piece_size(self): ...
    def vocab_size(self): ...
    def __getstate__(self): ...
    def __setstate__(self, serialized_model_proto):  # -> None:
        ...
    def __len__(self) -> int: ...
    def __getitem__(self, piece): ...
    def Load(self, model_file: str | None = ..., model_proto: bytes | None = ...) -> None: ...

def SetRandomGeneratorSeed(seed): ...
def SetMinLogLevel(v): ...

class SentencePieceTrainer:
    thisown = ...
    def __init__(self, *args, **kwargs) -> None: ...

    __repr__ = ...
    @staticmethod
    def Train(arg=..., logstream=..., **kwargs):  # -> None:
        ...

class SentencePieceNormalizer:
    thisown = ...
    __repr__ = ...
    def __init__(self) -> None: ...

    __swig_destroy__ = ...
    def LoadFromSerializedProto(self, serialized): ...
    def LoadFromRuleTSV(self, filename): ...
    def LoadFromRuleName(self, name): ...
    def serialized_model_proto(self): ...
    def LoadFromFile(self, arg): ...
    def Init(
        self,
        model_file=...,
        model_proto=...,
        rule_tsv=...,
        rule_name=...,
        add_dummy_prefix=...,
        escape_whitespaces=...,
        remove_extra_whitespaces=...,
    ):  # -> None:

        ...
    def Normalize(self, input, with_offsets=...):  # -> list[Any]:
        ...
    def __getstate__(self): ...
    def __setstate__(self, serialized_model_proto):  # -> None:
        ...

def SetDataDir(data_dir): ...

_sentencepiece_processor_init_native = ...
_sentencepiece_normalizer_init_native = ...
set_random_generator_seed = ...
set_min_log_level = ...

class _LogStream:
    def __init__(self, ostream=...) -> None: ...
    def __enter__(self):  # -> None:
        ...
    def __exit__(self, type, value, traceback):  # -> None:
        ...
