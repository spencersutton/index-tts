import dataclasses
import inspect
import typing

from torchgen.model import FunctionSchema, OperatorName

__all__ = ["custom_op", "CustomOp", "get_ctx"]
SUPPORTED_DEVICE_TYPE_TO_KEY = ...
RESERVED_NS = ...

def warn_deprecated():  # -> None:
    ...
def custom_op(qualname: str, manual_schema: str | None = ...) -> typing.Callable: ...

global_registry: dict[str, CustomOp] = ...

class CustomOp:
    def __init__(self, lib, cpp_ns, schema, operator_name, ophandle, *, _private_access=...) -> None: ...
    def __repr__(self):  # -> str:
        ...
    def __call__(self, *args, **kwargs):  # -> Any:
        ...
    def impl(self, device_types: str | typing.Iterable[str], _stacklevel=...) -> typing.Callable: ...
    def impl_factory(self) -> typing.Callable: ...
    def impl_abstract(self, _stacklevel=...) -> typing.Callable: ...
    def impl_save_for_backward(self, _stacklevel=...):  # -> Callable[..., None]:

        ...
    def impl_backward(self, output_differentiability=..., _stacklevel=...):  # -> Callable[..., None]:

        ...

@dataclasses.dataclass
class FuncAndLocation:
    func: typing.Callable
    location: str

def find_ophandle_or_throw(cpp_ns: str, operator_name: OperatorName):  # -> _DispatchOperatorHandle:
    ...
def validate_namespace(ns: str) -> None: ...
def validate_schema(schema: FunctionSchema) -> None: ...
def parse_qualname(qualname: str) -> tuple[str, str]: ...
def validate_device_type(device_type: str) -> None: ...
def supported_param(param: inspect.Parameter) -> bool: ...
def validate_function_matches_schema(schema: FunctionSchema, func: typing.Callable) -> None: ...
def report_error_callback(custom_op: typing.Any, key: str) -> None: ...
def custom_op_from_existing(op):  # -> CustomOp:
    ...
def get_op(qualname):  # -> Any:
    ...
def get_abstract_impl(qualname):  # -> None:
    ...
