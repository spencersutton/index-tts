from collections.abc import Callable

import torch
from torch._ops import OpOverload

aten = ...
rng_decompositions: dict[str, dict[OpOverload, Callable]] = ...

def register_rng_decomposition(aten_op):  # -> Callable[[Callable[_P, _T]], Callable[_P, _T]]:
    ...
def throw_on_non_cuda(device): ...
@register_rng_decomposition(aten.rand)
def rand(shape, dtype=..., layout=..., device=..., pin_memory=...):  # -> Any:
    ...
@register_rng_decomposition(aten.rand_like)
def rand_like(x: torch.Tensor, dtype=..., layout=..., device=..., pin_memory=..., memory_format=...):  # -> Any:
    ...

class PhiloxState:
    def __init__(self) -> None: ...
    def reset(self):  # -> None:
        ...
    def validate_state(self):  # -> None:
        ...
    def advance_offset(self, consumed_offset):  # -> None:
        ...
    def set_state(self, seed, base_offset, relative_offset=...):  # -> None:
        ...
    def get_state_as_tuple(self):  # -> tuple[Tensor | Any, Tensor | Any]:
        ...
    def get_state_as_tensor(self):  # -> Tensor:
        ...
    def set_state_from_tensor(self, state):  # -> None:
        ...

class PhiloxStateTracker:
    running_state: PhiloxState
    fwd_state: PhiloxState
    bwd_state: PhiloxState
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, exc_type, exc_cal, exc_tb):  # -> None:
        ...
    @classmethod
    def reset(cls):  # -> None:
        ...
    @classmethod
    def mark_beginning_of_forward(cls):  # -> None:
        ...
    @classmethod
    def mark_beginning_of_backward(cls):  # -> None:
        ...
    @classmethod
    def record_state(cls, seed, offset, mode):  # -> None:
        ...
    @classmethod
    def get_state_as_tensor(cls):  # -> Tensor:
        ...
    @classmethod
    def get_state_as_tuple(cls):  # -> tuple[Tensor | Any, Tensor | Any]:
        ...
    @classmethod
    def set_state_from_tensor(cls, x):  # -> None:
        ...
    @classmethod
    def advance_offset(cls, consumed_offset):  # -> None:
        ...
    @classmethod
    def get_current_relative_offset(cls):  # -> int:
        ...
    @staticmethod
    def multiple_of_4(offset): ...
    @classmethod
    def get_updated_fwd_offset(cls):  # -> Tensor:
        ...
    @classmethod
    def get_updated_bwd_offset(cls):  # -> Tensor:
        ...

extra_random_decomps = ...
register_extra_random_decomp = ...

@register_extra_random_decomp([aten.bernoulli_])
def bernoulli_(self, p=...):  # -> _NotImplementedType:
    ...
@register_extra_random_decomp([aten.bernoulli.p])
def bernoulli_p(self, p=..., *, generator=...):  # -> _NotImplementedType | Tensor:
    ...
