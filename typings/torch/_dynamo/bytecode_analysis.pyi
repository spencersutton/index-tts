import dataclasses
import sys
from typing import Any, TYPE_CHECKING, Union
from .bytecode_transformation import Instruction

"""
This module provides utilities for analyzing and optimizing Python bytecode.
Key functionality includes:
- Dead code elimination
- Jump instruction optimization
- Stack size analysis and verification
- Live variable analysis
- Line number propagation and cleanup
- Exception table handling for Python 3.11+

The utilities in this module are used to analyze and transform bytecode
for better performance while maintaining correct semantics.
"""
if TYPE_CHECKING: ...
TERMINAL_OPCODES = ...
if sys.version_info >= (3, 11): ...
else: ...
if (3, 12) <= sys.version_info < (3, 14): ...
if sys.version_info >= (3, 13): ...
JUMP_OPCODES = ...
JUMP_OPNAMES = ...
HASLOCAL = ...
HASFREE = ...
stack_effect = ...

def get_indexof(insts: list[Instruction]) -> dict[Instruction, int]: ...
def remove_dead_code(instructions: list[Instruction]) -> list[Instruction]: ...
def remove_pointless_jumps(instructions: list[Instruction]) -> list[Instruction]: ...
def propagate_line_nums(instructions: list[Instruction]) -> None: ...
def remove_extra_line_nums(instructions: list[Instruction]) -> None: ...

@dataclasses.dataclass
class ReadsWrites:
    reads: set[Any]
    writes: set[Any]
    visited: set[Any]

def livevars_analysis(instructions: list[Instruction], instruction: Instruction) -> set[Any]: ...

@dataclasses.dataclass
class FixedPointBox:
    value: bool = ...

@dataclasses.dataclass
class StackSize:
    low: int | float
    high: int | float
    fixed_point: FixedPointBox
    def zero(self) -> None: ...
    def offset_of(self, other: StackSize, n: int) -> None: ...
    def exn_tab_jump(self, depth: int) -> None: ...

def stacksize_analysis(instructions: list[Instruction]) -> int | float: ...
