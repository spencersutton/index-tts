import dataclasses
import dis
import functools
import sys
import types
from collections.abc import Iterable, Iterator, Mapping, Sequence
from typing import Any, Optional, TYPE_CHECKING, Union
from collections.abc import Callable
from ..utils._backport_slots import dataclass_slots
from .output_graph import DynamoTracerOutput

"""
This module provides utilities for analyzing, transforming and manipulating Python bytecode.
It includes functionality for:
- Converting between different bytecode formats and versions
- Virtualizing jumps and managing jump targets
- Handling exception tables and their entries
- Managing instruction offsets and extended arguments
- Providing a clean API for bytecode modification and transformation
- Supporting Python version-specific bytecode features
- Generating bytecode from template functions

The module is designed to work across different Python versions (3.7+) and handles
version-specific bytecode differences transparently.
"""
if TYPE_CHECKING: ...

@dataclass_slots
@dataclasses.dataclass
class InstructionExnTabEntry:
    start: Instruction
    end: Instruction
    target: Instruction
    depth: int
    lasti: bool

    def __eq__(self, o: object) -> bool: ...

@dataclass_slots
@dataclasses.dataclass
class Instruction:
    opcode: int
    opname: str
    arg: int | None
    argval: Any
    offset: int | None = ...
    starts_line: int | None = ...
    is_jump_target: bool = ...
    positions: dis.Positions | None = ...
    target: Instruction | None = ...
    exn_tab_entry: InstructionExnTabEntry | None = ...
    argrepr: str | None = ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def short_inst_repr(self) -> str: ...
    def copy_positions(self, other: Instruction) -> None: ...

if sys.version_info >= (3, 13):
    def convert_instruction(i: dis.Instruction) -> Instruction: ...

else: ...

class _NotProvided: ...

if sys.version_info >= (3, 12):
    def inst_has_op_bits(name: str) -> bool: ...

else: ...

def create_instruction(
    name: str, *, arg: int | None = ..., argval: Any | None = ..., target: Instruction | None = ...
) -> Instruction: ...
def create_jump_absolute(target: Instruction) -> Instruction: ...
def is_jump_absolute(target: Instruction) -> bool: ...
def create_load_const(val: Any, checked: bool = ...) -> Instruction: ...
def create_dup_top() -> Instruction: ...
def create_rot_n(n: int) -> list[Instruction]: ...
def add_push_null(inst_or_insts: Instruction | list[Instruction]) -> list[Instruction]: ...
def add_push_null_call_function_ex(inst_or_insts: Instruction | list[Instruction]) -> list[Instruction]: ...
def create_call_function(nargs: int, push_null: bool) -> list[Instruction]: ...
def create_call_method(nargs: int) -> list[Instruction]: ...
def create_load_method(name: str) -> Instruction: ...
def create_setup_with(target: Instruction) -> Instruction: ...
def create_swap(n: int) -> list[Instruction]: ...
def create_binary_slice(start: int | None, end: int | None, store: bool = ...) -> list[Instruction]: ...
def create_copy(i: int) -> list[Instruction]: ...
def create_print_on_stack(depth: int) -> list[Instruction]: ...
def create_print_value(value: Any) -> list[Instruction]: ...
def lnotab_writer(lineno: int, byteno: int = ...) -> tuple[list[int], Callable[[int, int], None]]: ...
def linetable_310_writer(first_lineno: int) -> tuple[list[int], Callable[[int, int], None], Callable[[int], None]]: ...
def encode_varint(n: int) -> list[int]: ...
def linetable_311_writer(first_lineno: int) -> tuple[list[int], Callable[[dis.Positions | None, int], None]]: ...

@dataclass_slots
@dataclasses.dataclass
class ExceptionTableEntry:
    start: int
    end: int
    target: int
    depth: int
    lasti: bool

def encode_exception_table_varint(n: int) -> list[int]: ...
def decode_exception_table_varint(bytes_iter: Iterator[int]) -> int: ...
def check_exception_table(tab: list[ExceptionTableEntry]) -> None: ...
def parse_exception_table(exntab: bytes) -> list[ExceptionTableEntry]: ...
def assemble_exception_table(tab: list[ExceptionTableEntry]) -> bytes: ...
def assemble(instructions: list[Instruction], firstlineno: int) -> tuple[bytes, bytes]: ...
def virtualize_jumps(instructions: Iterable[Instruction]) -> None: ...

_REL_JUMPS = ...

def flip_jump_direction(instruction: Instruction) -> None: ...
def devirtualize_jumps(instructions: list[Instruction]) -> None: ...
def virtualize_exception_table(exn_tab_bytes: bytes, instructions: list[Instruction]) -> None: ...
def compute_exception_table(instructions: list[Instruction]) -> list[ExceptionTableEntry]: ...
def check_inst_exn_tab_entries_nested(tab: list[InstructionExnTabEntry], indexof: dict[Instruction, int]) -> None: ...
def propagate_inst_exn_table_entries(instructions: list[Instruction]) -> None: ...
def check_inst_exn_tab_entries_valid(instructions: list[Instruction]) -> None: ...
def strip_extended_args(instructions: list[Instruction]) -> None: ...
def overwrite_instruction(old_inst: Instruction, new_insts: list[Instruction]) -> list[Instruction]: ...
def remove_load_call_method(instructions: list[Instruction]) -> list[Instruction]: ...
def remove_jump_if_none(instructions: list[Instruction]) -> None: ...
def remove_binary_store_slice(instructions: list[Instruction]) -> None: ...

FUSED_INSTS = ...

def remove_fused_load_store(instructions: list[Instruction]) -> None: ...
def add_graph_break_if_leaf_instructions(instructions: list[Instruction]) -> None: ...
def remove_graph_break_if_leaf_instructions(instructions: list[Instruction]) -> None: ...
def explicit_super(code: types.CodeType, instructions: list[Instruction]) -> None: ...
def fix_extended_args(instructions: list[Instruction]) -> int: ...
def instruction_size(inst: Instruction) -> int: ...
def check_offsets(instructions: Sequence[Instruction]) -> None: ...
def update_offsets(instructions: Sequence[Instruction]) -> None: ...
def debug_bytes(*args: bytes) -> str: ...
def debug_checks(code: types.CodeType) -> None: ...

HAS_LOCAL = ...
HAS_NAME = ...
HAS_FREE = ...
HAS_CONST = ...

def get_const_index(code_options: dict[str, Any], val: Any) -> int: ...
def fix_vars(
    instructions: list[Instruction],
    code_options: dict[str, Any],
    varname_from_oparg: Callable[..., Any] | None = ...,
) -> None: ...
def clear_instruction_args(instructions: list[Instruction]) -> None: ...
@functools.lru_cache
def get_code_keys() -> list[str]: ...
def transform_code_object(
    code: types.CodeType,
    transformations: Callable[[list[Instruction], dict[str, Any]], DynamoTracerOutput | None],
    safe: bool = ...,
) -> tuple[types.CodeType, DynamoTracerOutput | None]: ...
def clean_and_assemble_instructions(
    instructions: list[Instruction], keys: list[str], code_options: dict[str, Any]
) -> tuple[list[Instruction], types.CodeType]: ...
def populate_kw_names_argval(instructions: Sequence[Instruction], consts: Any) -> None: ...
def cleaned_instructions(code: types.CodeType, safe: bool = ...) -> list[Instruction]: ...

_unique_id_counter = ...

def unique_id(name: str, with_uuid: bool = ...) -> str: ...
def is_generator(code: types.CodeType) -> bool: ...
def bytecode_from_template(
    fn: Callable[..., Any], varname_map: Mapping[Any, Any] | None = ..., noreturn: bool = ..., noprefix: bool = ...
) -> list[Instruction]: ...
