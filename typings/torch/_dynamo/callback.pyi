import enum
import threading
from collections.abc import Callable, Generator
from contextlib import contextmanager
from dataclasses import dataclass
from typing import Any

class CallbackTrigger(enum.Enum):
    DYNAMO = ...
    LAZY_BACKWARD = ...
    TRITON_AUTOTUNING = ...
    CUDAGRAPH_RECORDING = ...

@dataclass
class CallbackArgs:
    callback_trigger: CallbackTrigger
    compile_id: str

@dataclass
class CompilationCallbackHandler:
    start_callbacks: list[Callable[[CallbackArgs], None]] = ...
    end_callbacks: list[Callable[[CallbackArgs], None]] = ...
    __pending_callbacks_counter: int = ...
    __pending_callbacks_counter_lock: threading.Lock = ...
    def register_start_callback(self, callback: Callable[[CallbackArgs], None]) -> Callable[[CallbackArgs], None]: ...
    def register_end_callback(self, callback: Callable[[CallbackArgs], None]) -> Callable[[CallbackArgs], None]: ...
    def remove_start_callback(self, callback: Callable[[CallbackArgs], None]) -> None: ...
    def remove_end_callback(self, callback: Callable[[CallbackArgs], None]) -> None: ...
    def run_start_callbacks(self, args: CallbackArgs) -> None: ...
    def run_end_callbacks(self, args: CallbackArgs) -> None: ...
    @contextmanager
    def install_callbacks(self, trigger: CallbackTrigger, compile_id: str) -> Generator[None, Any, Any]: ...
    def clear(self) -> None: ...

callback_handler = ...

def on_compile_start(callback: Callable[[CallbackArgs], None]) -> Callable[[CallbackArgs], None]: ...
def on_compile_end(callback: Callable[[CallbackArgs], None]) -> Callable[[CallbackArgs], None]: ...
