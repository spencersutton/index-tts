import dataclasses
import types
from collections.abc import Callable, Iterable
from typing import TYPE_CHECKING, Any, Optional, Union

import torch.nn
from torch._dynamo.variables.builder import GraphArg

from .bytecode_transformation import Instruction
from .source import Source
from .symbolic_convert import InstructionTranslatorBase
from .variables.base import VariableTracker

"""
This module provides utilities for generating Python bytecode in PyTorch's Dynamo system.
It includes functionality for:
- Constructing bytecode sequences for Python operations
- Managing stack operations and variable tracking
- Handling graph outputs and their conversions
- Supporting different Python versions (3.11+, 3.12+, 3.13+)
- Converting high-level operations to low-level bytecode instructions
- Managing constant loading and attribute access
- Supporting function creation and closure handling
"""
if TYPE_CHECKING: ...

@dataclasses.dataclass
class GraphOutputEntry:
    index: int
    variable: VariableTracker

class PyCodegen:
    def __init__(
        self,
        tx: InstructionTranslatorBase,
        root: torch.nn.Module | None = ...,
        graph_output_var: str | None = ...,
        tempvars: dict[VariableTracker | Source, Any] | None = ...,
        overridden_sources: dict[Source, Source] | None = ...,
    ) -> None: ...
    def restore_stack(self, stack_values: list[Any], *, value_from_source: bool = ...) -> None: ...
    def graph_output_vars(self) -> list[VariableTracker]: ...
    def call_reconstruct(self, value: VariableTracker | Source | GraphArg) -> None: ...
    def add_push_null(self, gen_fn: Callable[[], None], call_function_ex: bool = ...) -> None: ...
    def __call__(self, value: VariableTracker | Source, allow_cache: bool = ...) -> None: ...
    def add_graph_output(self, value: VariableTracker) -> int: ...
    def load_graph_output(self, index: int) -> None: ...
    def add_cache(self, value: VariableTracker | Source) -> None: ...
    def foreach(self, items: Iterable[VariableTracker | Source]) -> None: ...
    def create_binary_subscr(self) -> Instruction: ...
    def setup_globally_cached(self, name: str, value: Any) -> list[Instruction]: ...
    def clear_tos(self) -> None: ...
    def append_output(self, inst: Instruction) -> None: ...
    def extend_output(self, insts: list[Instruction]) -> None: ...
    def get_instructions(self) -> list[Instruction]: ...
    def create_load(self, name: str) -> Instruction: ...
    def create_load_closure(self, name: str) -> Instruction: ...
    def create_load_deref(self, name: str) -> Instruction: ...
    def create_store(self, name: str) -> Instruction: ...
    def create_store_deref(self, name: str) -> Instruction: ...
    def create_load_global(self, name: str, add: bool = ...) -> Instruction: ...
    def create_load_const(self, value: Any) -> Instruction: ...
    def create_load_const_unchecked(self, value: Any) -> Instruction: ...
    def load_method(self, name: str) -> None: ...
    def call_method(self, nargs: int) -> None: ...
    def create_load_attr(self, name: str) -> Instruction: ...
    def load_attr(self, name: str) -> None: ...
    def create_load_attrs(self, names: str) -> list[Instruction]: ...
    def create_store_attr(self, name: str) -> Instruction: ...
    def store_attr(self, name: str) -> None: ...
    def load_function_name(self, fn_name: str, push_null: bool, num_on_stack: int = ...) -> list[Instruction]: ...
    def rot_n(self, n: int) -> list[Instruction]: ...
    def pop_top(self) -> None: ...
    def call_function(self, nargs: int, push_null: bool) -> None: ...
    def dup_top(self) -> None: ...
    def store(self, varname: str) -> None: ...
    def load_deref(self, varname: str) -> None: ...
    def make_function_with_closure(
        self,
        tx: InstructionTranslatorBase,
        fn_name: str,
        code: types.CodeType,
        push_null: bool,
        num_on_stack: int = ...,
    ) -> None: ...
    def create_load_python_module(self, mod: types.ModuleType) -> Instruction: ...
    def mark_source_temp(self, source: Source) -> None: ...
    def make_call_generated_code(self, fn_name: str) -> None: ...
    def create_import_name(self, module_name: str) -> Instruction: ...
    def load_import_from(self, module_name: str, object_name: str) -> None: ...
    def create_call_function_kw(self, nargs: int, kw_names: Iterable[str], push_null: bool) -> list[Instruction]: ...
    def create_delete(self, value: object) -> Instruction: ...
