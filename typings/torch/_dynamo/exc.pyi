import typing
import types
from enum import Enum
from traceback import StackSummary
from typing import Any, NoReturn, Optional, TYPE_CHECKING
from torch._guards import CompileId
from .symbolic_convert import InstructionTranslatorBase
from .types import DynamoFrameType

if TYPE_CHECKING: ...

def exportdb_error_message(case_name: str) -> str: ...

log = ...
graph_breaks_log = ...

class TorchDynamoException(RuntimeError):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class InternalTorchDynamoError(TorchDynamoException): ...
class ResumePrologueTracingError(TorchDynamoException): ...

class RestartAnalysis(TorchDynamoException):
    restart_reason: str | None
    def __init__(self, *args: Any, restart_reason: str | None = ...) -> None: ...

class SpeculationRestartAnalysis(RestartAnalysis): ...
class UnspecializeRestartAnalysis(RestartAnalysis): ...
class CompileCollectiveRestartAnalysis(RestartAnalysis): ...
class TensorifyScalarRestartAnalysis(RestartAnalysis): ...
class SkipFrame(TorchDynamoException): ...
class TorchRuntimeError(TorchDynamoException): ...

class InvalidBackend(TorchDynamoException):
    def __init__(self, name: str) -> None: ...

class ResetRequired(TorchDynamoException):
    def __init__(self) -> None: ...

class ShortenTraceback(TorchDynamoException):
    def __init__(self, *args: Any, first_useful_frame: types.FrameType | None, **kwargs: Any) -> None: ...
    def remove_dynamo_frames(self) -> typing.Self: ...

class BackendCompilerFailed(ShortenTraceback):
    def __init__(
        self, backend_fn: Any, inner_exception: Exception, first_useful_frame: types.FrameType | None
    ) -> None: ...

class Unsupported(TorchDynamoException):
    def __init__(self, msg: str, *, case_name: str | None = ...) -> None: ...
    def remove_from_stats(self) -> None: ...
    def add_to_stats(self, category: str = ...) -> None: ...

class UnknownPropertiesDuringBackwardTrace(Unsupported): ...
class RecompileError(TorchDynamoException): ...

class ArgsMismatchError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class AttributeMutationError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class InfiniteGeneratorError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class SideEffectsError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class CondOpArgsMismatchError(ArgsMismatchError):
    def __init__(self, msg: str) -> None: ...

class UserErrorType(Enum):
    DYNAMIC_CONTROL_FLOW = ...
    ANTI_PATTERN = ...
    STANDARD_LIBRARY = ...
    CONSTRAINT_VIOLATION = ...
    DYNAMIC_DIM = ...
    INVALID_INPUT = ...
    INVALID_OUTPUT = ...
    UNSUPPORTED_ALIASED_MUTATED_DYNAMIC_INPUTS = ...

class UserError(Unsupported):
    def __init__(self, error_type: UserErrorType, msg: str, case_name: str | None = ...) -> None: ...

class SkipCodeRecursiveException(TorchDynamoException): ...
class RecompileLimitExceeded(Unsupported): ...
class UnsafeScriptObjectError(TorchDynamoException): ...

class UncapturedHigherOrderOpError(TorchDynamoException):
    def __init__(self, msg: str, real_stack: StackSummary | None = ...) -> None: ...

class IncorrectUsage(Exception): ...
class FailOnRecompileLimitHit(Exception): ...
class PackageError(TorchDynamoException): ...
class ObservedException(TorchDynamoException): ...

class ObservedUserStopIteration(ObservedException):
    value: Any | None
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class ObservedLookupError(ObservedException): ...
class ObservedIndexError(ObservedLookupError): ...
class ObservedKeyError(ObservedLookupError): ...
class ObservedGeneratorExit(ObservedException): ...
class ObservedAttributeError(ObservedException): ...
class ObservedRuntimeError(ObservedException): ...
class ObservedNotImplementedError(ObservedException): ...
class ObservedTypeError(ObservedException): ...

observed_exception_map = ...

def get_dynamo_observed_exception(exc_type: type[Exception]) -> type[ObservedException]: ...
def raise_observed_exception(
    exc_type: type[Exception],
    tx: InstructionTranslatorBase,
    *,
    args: list[Any] | None = ...,
    kwargs: dict[str, Any] | None = ...,
) -> NoReturn: ...
def handle_observed_exception(tx: Any) -> None: ...

exceptions_allowed_to_be_fallback = ...

def unimplemented_with_warning(e: Exception, code: types.CodeType, msg: str) -> NoReturn: ...

_NOTHING = ...

def unimplemented(msg: str, *, from_exc: Any = ..., case_name: str | None = ...) -> NoReturn: ...
def unimplemented_v2_with_warning(
    e: Exception, code: types.CodeType, gb_type: str, context: str, explanation: str, hints: list[str]
) -> NoReturn: ...
def format_graph_break_message(gb_type: str, context: str, explanation: str, hints: list[str]) -> str: ...
def get_gbid_documentation_link(gb_type: str) -> str | None: ...
def unimplemented_v2(
    gb_type: str, context: str, explanation: str, hints: list[str], *, from_exc: Any = ..., log_warning: bool = ...
) -> NoReturn: ...

class KeyErrorMsg:
    def __init__(self, value: Any) -> None: ...

def augment_exc_message(exc: Exception, msg: str = ..., export: bool = ...) -> None: ...
def get_exc_message(e: Exception, compile_id: CompileId) -> tuple[str | None, int | None]: ...
def get_stack_above_dynamo() -> StackSummary: ...
def get_real_stack(exc: Exception, frame: DynamoFrameType | None = ...) -> StackSummary | None: ...
def filter_stack(stack: StackSummary) -> StackSummary: ...
def remove_resume_prefix(name: str) -> str | None: ...
def collapse_resume_frames(stack: StackSummary) -> StackSummary: ...
def format_error_msg_verbose(
    exc: Exception, code: types.CodeType, record_filename: str | None = ..., frame: DynamoFrameType | None = ...
) -> str: ...
def format_error_msg(
    exc: Exception, code: types.CodeType, record_filename: str | None = ..., frame: DynamoFrameType | None = ...
) -> str: ...
