import typing
import types
from enum import Enum
from traceback import StackSummary
from typing import Any, NoReturn, Optional, TYPE_CHECKING
from torch._guards import CompileId
from .symbolic_convert import InstructionTranslatorBase
from .types import DynamoFrameType

if TYPE_CHECKING: ...

def exportdb_error_message(case_name: str) -> str: ...

log = ...
graph_breaks_log = ...

class TorchDynamoException(RuntimeError):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class InternalTorchDynamoError(TorchDynamoException): ...
class ResumePrologueTracingError(TorchDynamoException): ...

class RestartAnalysis(TorchDynamoException):
    restart_reason: Optional[str]
    def __init__(self, *args: Any, restart_reason: Optional[str] = ...) -> None: ...

class SpeculationRestartAnalysis(RestartAnalysis): ...
class UnspecializeRestartAnalysis(RestartAnalysis): ...
class CompileCollectiveRestartAnalysis(RestartAnalysis): ...
class TensorifyScalarRestartAnalysis(RestartAnalysis): ...
class SkipFrame(TorchDynamoException): ...
class TorchRuntimeError(TorchDynamoException): ...

class InvalidBackend(TorchDynamoException):
    def __init__(self, name: str) -> None: ...

class ResetRequired(TorchDynamoException):
    def __init__(self) -> None: ...

class ShortenTraceback(TorchDynamoException):
    def __init__(self, *args: Any, first_useful_frame: Optional[types.FrameType], **kwargs: Any) -> None: ...
    def remove_dynamo_frames(self) -> typing.Self: ...

class BackendCompilerFailed(ShortenTraceback):
    def __init__(
        self, backend_fn: Any, inner_exception: Exception, first_useful_frame: Optional[types.FrameType]
    ) -> None: ...

class Unsupported(TorchDynamoException):
    def __init__(self, msg: str, *, case_name: Optional[str] = ...) -> None: ...
    def remove_from_stats(self) -> None: ...
    def add_to_stats(self, category: str = ...) -> None: ...

class UnknownPropertiesDuringBackwardTrace(Unsupported): ...
class RecompileError(TorchDynamoException): ...

class ArgsMismatchError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class AttributeMutationError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class InfiniteGeneratorError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class SideEffectsError(Unsupported):
    def __init__(self, msg: str) -> None: ...

class CondOpArgsMismatchError(ArgsMismatchError):
    def __init__(self, msg: str) -> None: ...

class UserErrorType(Enum):
    DYNAMIC_CONTROL_FLOW = ...
    ANTI_PATTERN = ...
    STANDARD_LIBRARY = ...
    CONSTRAINT_VIOLATION = ...
    DYNAMIC_DIM = ...
    INVALID_INPUT = ...
    INVALID_OUTPUT = ...
    UNSUPPORTED_ALIASED_MUTATED_DYNAMIC_INPUTS = ...

class UserError(Unsupported):
    def __init__(self, error_type: UserErrorType, msg: str, case_name: Optional[str] = ...) -> None: ...

class SkipCodeRecursiveException(TorchDynamoException): ...
class RecompileLimitExceeded(Unsupported): ...
class UnsafeScriptObjectError(TorchDynamoException): ...

class UncapturedHigherOrderOpError(TorchDynamoException):
    def __init__(self, msg: str, real_stack: Optional[StackSummary] = ...) -> None: ...

class IncorrectUsage(Exception): ...
class FailOnRecompileLimitHit(Exception): ...
class PackageError(TorchDynamoException): ...
class ObservedException(TorchDynamoException): ...

class ObservedUserStopIteration(ObservedException):
    value: Optional[Any]
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class ObservedLookupError(ObservedException): ...
class ObservedIndexError(ObservedLookupError): ...
class ObservedKeyError(ObservedLookupError): ...
class ObservedGeneratorExit(ObservedException): ...
class ObservedAttributeError(ObservedException): ...
class ObservedRuntimeError(ObservedException): ...
class ObservedNotImplementedError(ObservedException): ...
class ObservedTypeError(ObservedException): ...

observed_exception_map = ...

def get_dynamo_observed_exception(exc_type: type[Exception]) -> type[ObservedException]: ...
def raise_observed_exception(
    exc_type: type[Exception],
    tx: InstructionTranslatorBase,
    *,
    args: Optional[list[Any]] = ...,
    kwargs: Optional[dict[str, Any]] = ...,
) -> NoReturn: ...
def handle_observed_exception(tx: Any) -> None: ...

exceptions_allowed_to_be_fallback = ...

def unimplemented_with_warning(e: Exception, code: types.CodeType, msg: str) -> NoReturn: ...

_NOTHING = ...

def unimplemented(msg: str, *, from_exc: Any = ..., case_name: Optional[str] = ...) -> NoReturn: ...
def unimplemented_v2_with_warning(
    e: Exception, code: types.CodeType, gb_type: str, context: str, explanation: str, hints: list[str]
) -> NoReturn: ...
def format_graph_break_message(gb_type: str, context: str, explanation: str, hints: list[str]) -> str: ...
def get_gbid_documentation_link(gb_type: str) -> Optional[str]: ...
def unimplemented_v2(
    gb_type: str, context: str, explanation: str, hints: list[str], *, from_exc: Any = ..., log_warning: bool = ...
) -> NoReturn: ...

class KeyErrorMsg:
    def __init__(self, value: Any) -> None: ...

def augment_exc_message(exc: Exception, msg: str = ..., export: bool = ...) -> None: ...
def get_exc_message(e: Exception, compile_id: CompileId) -> tuple[Optional[str], Optional[int]]: ...
def get_stack_above_dynamo() -> StackSummary: ...
def get_real_stack(exc: Exception, frame: Optional[DynamoFrameType] = ...) -> Optional[StackSummary]: ...
def filter_stack(stack: StackSummary) -> StackSummary: ...
def remove_resume_prefix(name: str) -> Optional[str]: ...
def collapse_resume_frames(stack: StackSummary) -> StackSummary: ...
def format_error_msg_verbose(
    exc: Exception, code: types.CodeType, record_filename: Optional[str] = ..., frame: Optional[DynamoFrameType] = ...
) -> str: ...
def format_error_msg(
    exc: Exception, code: types.CodeType, record_filename: Optional[str] = ..., frame: Optional[DynamoFrameType] = ...
) -> str: ...
