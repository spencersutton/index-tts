import ast
import dataclasses
import enum
import functools
import pickle
import types
import weakref
import torch
import torch.overrides
from typing import Any, Callable, LiteralString, NoReturn, Optional, TYPE_CHECKING, Union
from typing_extensions import TypeAliasType, TypeVar
from torch._C._dynamo.guards import DictGuardManager, GuardDebugInfo, GuardManager, LeafGuard, RootGuardManager
from torch._guards import CompileId, Guard, GuardBuilderBase, Source
from torch._inductor.utils import IndentedBuffer
from torch.fx.experimental.symbolic_shapes import _CppShapeGuardsHelper, _ShapeGuardsHelper
from torch.utils._ordered_set import OrderedSet
from .source import AttrSource, DictGetItemSource, DictSubclassGetItemSource
from .types import CacheEntry, DynamoFrameType, GuardFail, GuardFilterEntry, GuardFn
from collections.abc import Generator, KeysView, Sequence
from torch._C import DispatchKeySet
from torch._dynamo.output_graph import OutputGraph, OutputGraphGuardsState

"""
Core guard system for Dynamo that detects when compiled code needs to be recompiled due to
changes in program state. Guards are conditions that must remain true for previously-compiled
code to be valid for reuse.

This module provides the infrastructure for creating, managing and checking guards, including:
- Guard creation and composition
- Guard state management and invalidation
- Guard checking and failure handling
- Utilities for guard optimization and debugging
- Integration with Dynamo's compilation caching

The guard system is critical for Dynamo's ability to efficiently reuse compiled code while
maintaining correctness by detecting when recompilation is necessary due to changes in
program state, tensor properties, or control flow.
"""
guard_manager_testing_hook_fn: Optional[Callable[[Any, Any, Any], Any]] = ...
if TYPE_CHECKING: ...
T = TypeVar("T")
log = ...
guards_log = ...
recompiles_log = ...
recompiles_verbose_log = ...
verbose_guards_log = ...
dunder_attrs_assumed_constants = ...

class IndentedBufferWithPrefix(IndentedBuffer):
    def prefix(self) -> str: ...
    def writeline(self, line: str, skip_prefix: bool = ...) -> None: ...

class GuardManagerWrapper:
    def __init__(self, root: Optional[RootGuardManager] = ...) -> None: ...
    def collect_diff_guard_sources(self) -> OrderedSet[str]: ...
    def finalize(self) -> None: ...
    def prepare_diff_guard_manager(self) -> None: ...
    def find_tag_safe_roots(self) -> None: ...
    def populate_diff_guard_manager(self) -> None: ...
    def clone_with_chosen_sources(self, chosen_sources: OrderedSet[str]) -> RootGuardManager: ...
    def get_guard_lines(self, guard: LeafGuard) -> list[str]: ...
    def get_manager_line(self, guard_manager: GuardManager, accessor_str: Optional[str] = ...) -> str: ...
    def construct_dict_manager_string(self, mgr: DictGuardManager, body: IndentedBufferWithPrefix) -> None: ...
    def construct_manager_string(self, mgr: GuardManager, body: IndentedBufferWithPrefix) -> None: ...
    def check(self, x: Any) -> bool: ...
    def check_verbose(self, x: Any) -> GuardDebugInfo: ...
    def populate_code_parts_for_debugging(self) -> None: ...

def from_numpy(a: Any) -> torch.Tensor: ...
@functools.cache
def uninteresting_files() -> set[str]: ...

_CLOSURE_VARS: Optional[dict[str, object]] = ...
strip_function_call = ...

def get_verbose_code_part(code_part: str, guard: Optional[Guard]) -> str: ...
def get_verbose_code_parts(
    code_parts: Union[str, list[str]], guard: Optional[Guard], recompile_hint: Optional[str] = ...
) -> list[str]: ...
def convert_int_to_concrete_values(dim: Any) -> Optional[int]: ...
def convert_to_concrete_values(size_or_stride: list[Any]) -> list[Optional[int]]: ...
def get_tensor_guard_code_part(
    value: torch.Tensor,
    name: str,
    sizes: list[Optional[int]],
    strides: list[Optional[int]],
    pytype: type,
    dispatch_keys: DispatchKeySet,
) -> str: ...
def get_key_index(dct: dict[Any, Any], key: Any) -> int: ...
def get_key_index_source(source: Any, index: Any) -> str: ...
def raise_local_type_error(obj: Any) -> NoReturn: ...
def should_optimize_getattr_on_nn_module(value: Any) -> bool: ...

@dataclasses.dataclass(frozen=True)
class NNModuleAttrAccessorInfo:
    present_in_generic_dict: bool = ...
    l1_key: Optional[str] = ...
    l2_key: Optional[str] = ...

def getitem_on_dict_manager(
    source: Union[DictGetItemSource, DictSubclassGetItemSource],
    base_guard_manager: DictGuardManager,
    base_example_value: Any,
    example_value: Any,
    guard_manager_enum: GuardManagerType,
) -> GuardManager: ...
def match_on_id_for_tensor(guard: Guard) -> bool: ...

@dataclasses.dataclass
class GuardCodeList:
    code_list: list[str]
    guard: Guard

class GuardManagerType(enum.Enum):
    GUARD_MANAGER = ...
    DICT_GUARD_MANAGER = ...

@functools.cache
def code_framelocals_names_reversed_cached(code: types.CodeType) -> list[str]: ...

class GuardBuilder(GuardBuilderBase):
    def __init__(
        self,
        f_code: types.CodeType,
        id_ref: Callable[[object, str], int],
        source_ref: Callable[[Source], str],
        lookup_weakrefs: Callable[[object], Optional[weakref.ref[object]]],
        local_scope: dict[str, object],
        global_scope: dict[str, object],
        guard_manager: GuardManagerWrapper,
        check_fn_manager: CheckFunctionManager,
        save_guards: bool = ...,
        runtime_global_scope: Optional[dict[str, object]] = ...,
    ) -> None: ...
    def guard_on_dict_keys_and_ignore_order(self, example_value: dict[Any, Any], guard: Guard) -> None: ...
    def guard_on_dict_keys_and_order(self, value: dict[Any, Any], guard: Guard) -> None: ...
    def getattr_on_nn_module(
        self,
        source: AttrSource,
        base_guard_manager: GuardManager,
        base_example_value: Any,
        example_value: Any,
        base_source_name: str,
        source_name: str,
        guard_manager_enum: GuardManagerType,
    ) -> GuardManager: ...
    def requires_key_order_guarding(self, source: Source) -> bool: ...
    def get_guard_manager_type(
        self, source: Source, example_value: Optional[Union[KeysView[Any], set[Any], frozenset[Any], dict[Any, Any]]]
    ) -> GuardManagerType: ...
    def manager_guards_on_keys(self, mgr_enum: GuardManagerType) -> bool: ...
    def get_global_guard_manager(self) -> GuardManager: ...
    def get_guard_manager_from_source(self, source: Source) -> GuardManager: ...
    def get_guard_manager(self, guard: Guard) -> GuardManager: ...
    def add_python_lambda_leaf_guard_to_root(
        self,
        code_parts: list[str],
        verbose_code_parts: list[str],
        closure_vars: Optional[dict[str, object]] = ...,
        is_epilogue: bool = ...,
    ) -> None: ...
    def get(self, name: str, closure_vars: Optional[dict[str, Any]] = ...) -> Any: ...
    def arg_ref(self, guard: Union[str, Guard]) -> str: ...
    def HASATTR(self, guard: Guard) -> None: ...
    def NOT_PRESENT_IN_GENERIC_DICT(self, guard: Guard, attr: Optional[Any] = ...) -> None: ...
    def TYPE_MATCH(self, guard: Guard) -> None: ...
    def DICT_VERSION(self, guard: Guard) -> None: ...
    def DICT_CONTAINS(self, guard: Guard, key: str, invert: bool) -> None: ...
    def SET_CONTAINS(self, guard: Guard, key: Any, invert: bool) -> None: ...
    def BOOL_MATCH(self, guard: Guard) -> None: ...
    def NONE_MATCH(self, guard: Guard) -> None: ...
    def ID_MATCH(self, guard: Guard, recompile_hint: Optional[str] = ...) -> None: ...
    def id_match_unchecked(self, guard: Guard, recompile_hint: Optional[str] = ...) -> None: ...
    def NOT_NONE_MATCH(self, guard: Guard, value: Optional[Any] = ...) -> None: ...
    def DISPATCH_KEY_SET_MATCH(self, guard: Guard) -> None: ...
    def NAME_MATCH(self, guard: Guard) -> None: ...
    def DUAL_LEVEL(self, guard: Guard) -> None: ...
    def FUNCTORCH_STACK_MATCH(self, guard: Guard) -> None: ...
    def AUTOGRAD_SAVED_TENSORS_HOOKS(self, guard: Guard) -> None: ...
    def TENSOR_SUBCLASS_METADATA_MATCH(self, guard: Guard) -> None: ...
    def EQUALS_MATCH(self, guard: Guard, recompile_hint: Optional[str] = ...) -> None: ...
    def CONSTANT_MATCH(self, guard: Guard) -> None: ...
    def NN_MODULE(self, guard: Guard) -> None: ...
    def FUNCTION_MATCH(self, guard: Guard) -> None: ...
    def CLOSURE_MATCH(self, guard: Guard) -> None: ...
    def BUILTIN_MATCH(self, guard: Guard) -> None: ...
    def SEQUENCE_LENGTH(self, guard: Guard) -> None: ...
    def TUPLE_ITERATOR_LEN(self, guard: Guard) -> None: ...
    def RANGE_ITERATOR_MATCH(self, guard: Guard) -> None: ...
    def DUPLICATE_INPUT(self, guard: Guard, source_b: Source) -> None: ...
    def WEAKREF_ALIVE(self, guard: Guard) -> None: ...
    def MAPPING_KEYS_CHECK(self, guard: Guard) -> None: ...
    def DICT_KEYS_MATCH(self, guard: Guard) -> None: ...
    def EMPTY_NN_MODULE_HOOKS_DICT(self, guard: Guard) -> None: ...
    def GRAD_MODE(self, guard: Guard) -> None: ...
    def DETERMINISTIC_ALGORITHMS(self, guard: Guard) -> None: ...
    def TORCH_FUNCTION_STATE(self, guard: Guard) -> None: ...
    def FSDP_TRAINING_STATE(self, guard: Guard) -> None: ...
    def DEFAULT_DEVICE(self, guard: Guard) -> None: ...
    def SHAPE_ENV(self, guard: Guard) -> None: ...
    def TENSOR_MATCH(self, guard: Guard, value: Optional[Any] = ...) -> None: ...

class PyExprCSEPass:
    USE_THRESHOLD = ...
    ALLOWED_NODE_TYPES = ...
    @dataclasses.dataclass
    class Config:
        expr_count: dict[str, int]
        expr_to_name: dict[str, str]

    class ExprCounter(ast.NodeVisitor):
        def __init__(self, config: PyExprCSEPass.Config) -> None: ...
        def visit(self, node: ast.AST) -> None: ...

    class Replacer(ast.NodeTransformer):
        def __init__(self, config: PyExprCSEPass.Config, gen_name: Callable[[], str]) -> None: ...
        def visit(self, node: ast.AST) -> Any: ...

    def __init__(self) -> None: ...
    def count(self, exprs: list[str]) -> None: ...
    def replace(self, expr: str) -> tuple[list[str], str]: ...

def must_add_nn_module_guards(guard: Guard) -> bool: ...

class DeletedGuardManagerWrapper(GuardManagerWrapper):
    def __init__(self, reason: str) -> None: ...
    def populate_diff_guard_manager(self) -> None: ...

@dataclasses.dataclass
class ShapeCodeParts:
    python_code_parts: _ShapeGuardsHelper
    verbose_code_parts: _ShapeGuardsHelper
    cpp_code_parts: Optional[_CppShapeGuardsHelper]
    python_fallback: bool
    shape_env_sources: list[Source]

@dataclasses.dataclass
class GuardsState:
    output_graph: OutputGraphGuardsState
    shape_code_parts: Optional[ShapeCodeParts]

class _Missing: ...

class GuardsStatePickler(pickle.Pickler):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def reducer_override(self, obj: Any) -> Union[tuple[Callable[..., Any], tuple[Any, ...]], Any]: ...

def pickle_guards_state(state: GuardsState) -> bytes: ...

class CheckFunctionManager:
    def __init__(
        self,
        f_code: types.CodeType,
        output_graph: OutputGraphGuardsState,
        cache_entry: Optional[CacheEntry] = ...,
        guard_fail_fn: Optional[Callable[[GuardFail], None]] = ...,
        guard_filter_fn: Optional[Callable[[list[GuardFilterEntry]], list[bool]]] = ...,
        shape_code_parts: Optional[ShapeCodeParts] = ...,
        runtime_global_scope: Optional[dict[str, Any]] = ...,
        save_guards: bool = ...,
        strict_error: bool = ...,
    ) -> None: ...

    UNSUPPORTED_SERIALIZATION_GUARD_TYPES: tuple[LiteralString, ...] = ...
    def serialize_guards(
        self, builder: GuardBuilder, sorted_guards: list[Guard], output_graph: OutputGraph
    ) -> bytes: ...
    def build_guards(
        self,
        sorted_guards: list[Guard],
        existing_diff_guard_sources: OrderedSet[str],
        f_code: types.CodeType,
        output_graph: OutputGraphGuardsState,
        save_guards: bool,
    ) -> tuple[GuardBuilder, GuardManagerWrapper]: ...
    def compile_check_fn(
        self, builder: GuardBuilder, guards_out: list[Guard], guard_fail_fn: Optional[Callable[[GuardFail], None]]
    ) -> None: ...
    def invalidate(self, obj_str: str) -> None: ...
    def id_ref(self, obj: object, obj_str: str) -> int: ...
    def lookup_weakrefs(self, obj: object) -> Optional[weakref.ref[object]]: ...

def build_guard_function(code_parts: list[str], closure_args: str) -> tuple[str, str]: ...
def is_recompiles_enabled() -> bool: ...
def is_recompiles_verbose_enabled() -> bool: ...
def make_torch_function_mode_stack_guard(
    initial_stack: list[torch.overrides.TorchFunctionMode],
) -> Callable[[], bool]: ...

Scope = TypeAliasType("Scope", dict[str, object])

def recompilation_reason_for_no_tensor_aliasing_guard(
    guard_manager: GuardManagerWrapper, scope: Scope
) -> list[str]: ...
def strip_local_scope(s: str) -> str: ...
def get_guard_fail_reason_helper(
    guard_manager: GuardManagerWrapper, f_locals: dict[str, object], compile_id: Optional[CompileId]
) -> str: ...
def get_guard_fail_reason(
    guard_manager: GuardManagerWrapper,
    code: types.CodeType,
    f_locals: dict[str, object],
    compile_id: CompileId,
    skip_logging: bool = ...,
) -> str: ...
def get_and_maybe_log_recompilation_reasons(
    cache_entry: Optional[CacheEntry], frame: DynamoFrameType, skip_logging: bool = ...
) -> list[str]: ...
def update_diff_guard_managers_for_existing_cache_entries(cache_entry: Optional[CacheEntry]) -> OrderedSet[str]: ...
def guard_error_hook(
    guard_manager: GuardFn, code: types.CodeType, f_locals: dict[str, object], index: int, last: bool
) -> None: ...
def unique(seq: Sequence[T]) -> Generator[T, None, None]: ...
def make_dupe_guard(obj_source: Source, dupe_source: Source) -> Optional[functools.partial[Any]]: ...
def install_guard(*guards: Guard, skip: int = ...) -> None: ...
