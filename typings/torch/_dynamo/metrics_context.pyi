from collections.abc import Callable, Iterator
from typing import Any, Self

log = ...

class TopN:
    def __init__(self, at_most: int = ...) -> None: ...
    def add(self, key: Any, val: int) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[tuple[Any, int]]: ...

type OnExitType = Callable[[int, int, dict[str, Any], type[BaseException] | None, BaseException | None], None]

class MetricsContext:
    def __init__(self, on_exit: OnExitType) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, _traceback: Any
    ) -> None: ...
    def in_progress(self) -> bool: ...
    def increment(self, metric: str, value: int) -> None: ...
    def set(self, metric: str, value: Any, overwrite: bool = ...) -> None: ...
    def set_key_value(self, metric: str, key: str, value: Any) -> None: ...
    def update(self, values: dict[str, Any], overwrite: bool = ...) -> None: ...
    def update_outer(self, values: dict[str, Any]) -> None: ...
    def add_to_set(self, metric: str, value: Any) -> None: ...
    def add_top_n(self, metric: str, key: Any, val: int) -> None: ...

class RuntimeMetricsContext:
    def __init__(self, on_exit: OnExitType) -> None: ...
    def increment(self, metric: str, value: int, extra: dict[str, Any] | None = ...) -> None: ...
    def finish(self) -> None: ...
