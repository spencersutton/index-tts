from collections.abc import Callable, Iterator
from typing import TYPE_CHECKING, Any, Optional, Self, TypeAlias

"""Metrics collection and management system for Dynamo.

This module provides context managers for gathering and reporting metrics during
compilation and runtime.

It includes two main components:
- MetricsContext: A context manager for collecting metrics during compilation, supporting
  nested contexts and various metric types (counters, sets, key-value pairs)
- RuntimeMetricsContext: A specialized context for runtime metrics collection that doesn't
  require explicit context management

The metrics system enables comprehensive monitoring and analysis of both compilation and
execution performance.
"""
if TYPE_CHECKING: ...
log = ...

class TopN:
    def __init__(self, at_most: int = ...) -> None: ...
    def add(self, key: Any, val: int) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[tuple[Any, int]]: ...

type OnExitType = Callable[
    [int, int, dict[str, Any], type[BaseException] | None, BaseException | None],
    None,
]

class MetricsContext:
    def __init__(self, on_exit: OnExitType) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, _traceback: Any
    ) -> None: ...
    def in_progress(self) -> bool: ...
    def increment(self, metric: str, value: int) -> None: ...
    def set(self, metric: str, value: Any, overwrite: bool = ...) -> None: ...
    def set_key_value(self, metric: str, key: str, value: Any) -> None: ...
    def update(self, values: dict[str, Any], overwrite: bool = ...) -> None: ...
    def update_outer(self, values: dict[str, Any]) -> None: ...
    def add_to_set(self, metric: str, value: Any) -> None: ...
    def add_top_n(self, metric: str, key: Any, val: int) -> None: ...

class RuntimeMetricsContext:
    def __init__(self, on_exit: OnExitType) -> None: ...
    def increment(self, metric: str, value: int, extra: dict[str, Any] | None = ...) -> None: ...
    def finish(self) -> None: ...
