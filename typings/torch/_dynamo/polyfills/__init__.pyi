import types
from collections import OrderedDict
from collections.abc import Callable, Hashable, Iterable, MutableMapping, Sequence
from itertools import repeat as _repeat
from typing import TYPE_CHECKING, Any

import torch
from torch.overrides import BaseTorchFunctionMode

from ..utils import dict_keys
from . import (
    _collections as _collections,
)
from . import (
    builtins as builtins,
)
from . import (
    functools as functools,
)
from . import (
    itertools as itertools,
)
from . import (
    operator as operator,
)
from . import (
    os as os,
)
from . import (
    pytree as pytree,
)
from . import (
    struct as struct,
)
from . import (
    sys as sys,
)

"""
Python polyfills for common builtins.
"""
if TYPE_CHECKING: ...

class NoEnterTorchFunctionMode(BaseTorchFunctionMode):
    def __enter__(self):  # -> None:
        ...

def index(iterator, item, start=..., end=...):  # -> int:
    ...
def repeat(item, count):  # -> Generator[Any, Any, None]:
    ...
def radians(x): ...
def impl_CONTAINS_OP_fallback(a, b):  # -> bool:
    ...
def accumulate_grad(x, new_grad):  # -> None:
    ...
def list_cmp(op: Callable[[Any, Any], bool], left: Sequence[Any], right: Sequence[Any]):  # -> bool:

    ...
def dict___eq__(d, other):  # -> bool:
    ...
def set_symmetric_difference(set1, set2):  # -> set[Any]:
    ...
def set_symmetric_difference_update(set1, set2):  # -> None:
    ...
def set_isdisjoint(set1, set2):  # -> bool:
    ...
def set_intersection(set1, *others):  # -> set[Any]:
    ...
def set_intersection_update(set1, *others):  # -> None:
    ...
def set_union(set1, *others):  # -> Any:
    ...
def set_update(set1, *others):  # -> None:
    ...
def set_difference(set1, *others):  # -> set[Any]:
    ...
def set_difference_update(set1, *others):  # -> None:
    ...
def assert_dict_equal(self_, d1, d2, msg=...):  # -> None:
    ...
def assert_multi_line_equal(self_, first, second, msg=...): ...
def assert_sequence_equal(self_, seq1, seq2, msg=..., seq_type=...): ...
def getattr_and_trace(*args, **kwargs):  # -> Any:
    ...
def mapping_get(obj, key, value=...):  # -> None:
    ...
def instantiate_user_defined_class_object(cls, /, *args, **kwargs): ...
def construct_dict(cls, /, *args, **kwargs): ...
def foreach_map_fn(*args):  # -> list[Any]:
    ...
def foreach_lerp_inplace(self, end, weight):  # -> None:
    ...
def foreach_pow_scalar(scalar, exps):  # -> tuple[Tensor, ...]:
    ...
def addcmul_inplace(self, tensor1, tensor2, value): ...
def predicate(obj: Any) -> bool: ...
def cmp_eq(a, b):  # -> Literal[False]:
    ...
def cmp_ne(a, b):  # -> bool:
    ...
def cmp_lt(a, b): ...
def cmp_le(a, b): ...
def cmp_gt(a, b): ...
def cmp_ge(a, b): ...
