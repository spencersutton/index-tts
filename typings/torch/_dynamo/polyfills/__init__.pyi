from collections.abc import Callable, Sequence
from typing import Any

from torch.overrides import BaseTorchFunctionMode

from . import _collections as _collections
from . import builtins as builtins
from . import functools as functools
from . import itertools as itertools
from . import operator as operator
from . import os as os
from . import pytree as pytree
from . import struct as struct
from . import sys as sys

class NoEnterTorchFunctionMode(BaseTorchFunctionMode):
    def __enter__(self): ...

def index(iterator, item, start=..., end=...): ...
def repeat(item, count): ...
def radians(x): ...
def impl_CONTAINS_OP_fallback(a, b): ...
def accumulate_grad(x, new_grad): ...
def list_cmp(op: Callable[[Any, Any], bool], left: Sequence[Any], right: Sequence[Any]): ...
def dict___eq__(d, other): ...
def set_symmetric_difference(set1, set2): ...
def set_symmetric_difference_update(set1, set2): ...
def set_isdisjoint(set1, set2): ...
def set_intersection(set1, *others): ...
def set_intersection_update(set1, *others): ...
def set_union(set1, *others): ...
def set_update(set1, *others): ...
def set_difference(set1, *others): ...
def set_difference_update(set1, *others): ...
def assert_dict_equal(self_, d1, d2, msg=...): ...
def assert_multi_line_equal(self_, first, second, msg=...): ...
def assert_sequence_equal(self_, seq1, seq2, msg=..., seq_type=...): ...
def getattr_and_trace(*args, **kwargs): ...
def mapping_get(obj, key, value=...): ...
def instantiate_user_defined_class_object(cls, /, *args, **kwargs): ...
def construct_dict(cls, /, *args, **kwargs): ...
def foreach_map_fn(*args): ...
def foreach_lerp_inplace(self, end, weight): ...
def foreach_pow_scalar(scalar, exps): ...
def addcmul_inplace(self, tensor1, tensor2, value): ...
def predicate(obj: Any) -> bool: ...
def cmp_eq(a, b): ...
def cmp_ne(a, b): ...
def cmp_lt(a, b): ...
def cmp_le(a, b): ...
def cmp_gt(a, b): ...
def cmp_ge(a, b): ...
