"""Python polyfills for torch.utils.pytree"""

import builtins
from collections import UserString
from collections.abc import Callable, Iterable
from dataclasses import dataclass
from typing import Any, Literal, Self

import optree._C
import torch.utils._cxx_pytree as cxx_pytree
import torch.utils._pytree as python_pytree

from ..decorators import substitute_in_graph

__all__: list[str] = ...
if python_pytree._cxx_pytree_dynamo_traceable:
    @substitute_in_graph(optree._C.is_dict_insertion_ordered, can_constant_fold_through=True)
    def _(*args: Any, **kwargs: Any) -> bool: ...

    __name = ...
    @substitute_in_graph(cxx_pytree.tree_is_leaf, can_constant_fold_through=True)
    def tree_is_leaf(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> bool: ...
    @substitute_in_graph(cxx_pytree.tree_iter, can_constant_fold_through=False)
    def tree_iter(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> Iterable[Any]: ...
    @substitute_in_graph(cxx_pytree.tree_leaves, can_constant_fold_through=True)
    def tree_leaves(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> list[Any]: ...

    class _Asterisk(UserString):
        __slots__ = ...
        def __new__(cls) -> Self: ...

    _asterisk = ...
    @dataclass(frozen=True)
    class PyTreeSpec:
        _children: tuple[PyTreeSpec, ...]
        _type: builtins.type | None
        _metadata: Any
        _entries: tuple[Any, ...]
        _unflatten_func: Callable[[Any | None, Iterable[PyTree]], PyTree] | None
        num_nodes: int = ...
        num_leaves: int = ...
        num_children: int = ...
        none_is_leaf: Literal[True] = ...
        namespace: Literal["torch"] = ...
        def __post_init__(self) -> None: ...
        def __len__(self) -> int: ...
        @property
        def type(self) -> builtins.type | None: ...
        def is_leaf(self) -> bool: ...
        def children(self) -> list[PyTreeSpec]: ...
        def child(self, index: int) -> PyTreeSpec: ...
        def entries(self) -> list[Any]: ...
        def entry(self, index: int) -> Any: ...
        def flatten_up_to(self, tree: PyTree) -> list[PyTree]: ...
        def unflatten(self, leaves: Iterable[Any]) -> PyTree: ...

    _LEAF_SPEC = ...
    @substitute_in_graph(cxx_pytree.tree_flatten, can_constant_fold_through=False)
    def tree_flatten(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> tuple[list[Any], PyTreeSpec]: ...
    @substitute_in_graph(cxx_pytree.tree_structure, can_constant_fold_through=False)
    def tree_structure(tree: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...) -> PyTreeSpec: ...
    @substitute_in_graph(cxx_pytree.tree_unflatten, can_constant_fold_through=False)
    def tree_unflatten(leaves: Iterable[Any], treespec: PyTreeSpec) -> PyTree: ...
    @substitute_in_graph(cxx_pytree.tree_map, can_constant_fold_through=True)
    def tree_map(
        func: Callable[..., Any], tree: PyTree, *rests: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...
    ) -> PyTree: ...
    @substitute_in_graph(cxx_pytree.tree_map_, can_constant_fold_through=True)
    def tree_map_(
        func: Callable[..., Any], tree: PyTree, *rests: PyTree, is_leaf: Callable[[PyTree], bool] | None = ...
    ) -> PyTree: ...
