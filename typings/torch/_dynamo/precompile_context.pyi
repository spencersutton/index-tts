from abc import abstractmethod
from collections.abc import Callable
from typing import Any, TypeVar, override

from torch.compiler._cache import CacheArtifact, CacheArtifactManager, CacheArtifactsResult, CacheInfo
from torch.utils._appending_byte_serializer import AppendingByteSerializer
from torch.utils._ordered_set import OrderedSet

T = TypeVar("T")
logger = ...

class PrecompileCacheArtifact[T](CacheArtifact):
    @override
    def populate_cache(self) -> None: ...
    @override
    def precompile_compatible(self) -> bool: ...
    @abstractmethod
    def after_deserialization(self) -> T: ...

class EditablePrecompileCacheArtifact[T]:
    def __init__(self, artifact_type: str, content: Any, key: str) -> None: ...
    def real_encode(self) -> PrecompileCacheArtifact[T]: ...
    def edit_contents(self, edit_fn: Callable[..., Any]) -> None: ...

class PrecompileContext(CacheArtifactManager):
    _new_cache_artifacts_by_key: dict[str, EditablePrecompileCacheArtifact[object] | CacheArtifact] = ...
    _new_cache_artifacts: CacheArtifactsResult = ...
    _seen_artifacts: OrderedSet[CacheArtifact] = ...
    _serializer: AppendingByteSerializer[tuple[str, list[CacheArtifact]]] = ...
    _cache_info: CacheInfo = ...
    @classmethod
    def clear(cls) -> None: ...
    @override
    @classmethod
    def record_artifact(cls, artifact_type: str, key: str, content: Any, editable: bool = ...) -> None: ...
    @classmethod
    def edit_artifact(cls, key: str, edit_fn: Callable[..., Any]) -> None: ...
    @classmethod
    def serialize_artifact_by_key(cls, key: str) -> CacheArtifact | None: ...
    @classmethod
    def serialize(cls) -> tuple[bytes, CacheInfo] | None: ...
    @staticmethod
    def populate_caches(artifacts: CacheArtifactsResult) -> CacheInfo: ...
