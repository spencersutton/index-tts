import dataclasses
from io import BufferedReader, BufferedWriter
from types import CellType, CodeType, ModuleType
from typing import IO, Any, Self

dill = ...

@dataclasses.dataclass
class ModuleRecord:
    module: ModuleType
    accessed_attrs: dict[str, Any] = ...

@dataclasses.dataclass
class DummyModule:
    name: str
    is_torch: bool = ...
    value: object = ...
    @property
    def __name__(self) -> str: ...

@dataclasses.dataclass
class ExecutionRecord:
    code: CodeType
    closure: tuple[CellType]
    globals: dict[str, Any] = ...
    locals: dict[str, Any] = ...
    builtins: dict[str, Any] = ...
    code_options: dict[str, Any] = ...
    def dump(self, f: IO[str] | BufferedWriter) -> None: ...
    @classmethod
    def load(cls, f: IO[bytes] | BufferedReader) -> Self: ...

@dataclasses.dataclass
class ExecutionRecorder:
    LOCAL_MOD_PREFIX = ...
    code: CodeType
    closure: tuple[CellType]
    globals: dict[str, Any] = ...
    locals: dict[str, Any] = ...
    builtins: dict[str, Any] = ...
    code_options: dict[str, Any] = ...
    name_to_modrec: dict[str, ModuleRecord] = ...
    def add_local_var(self, name: str, var: Any) -> None: ...
    def add_global_var(self, name: str, var: Any) -> None: ...
    def add_local_mod(self, name: str, mod: ModuleType) -> None: ...
    def record_module_access(self, mod: ModuleType, name: str, val: Any) -> None: ...
    def get_record(self) -> ExecutionRecord: ...
