import dataclasses
import functools
import sys
import types
import torch
import torch.distributed
import numpy as np
from typing import Any, Callable, Optional, Union
from .variables import SkipFunctionVariable, TorchInGraphFunctionVariable, UserFunctionVariable
from .variables.base import VariableTracker

"""
Tracing rules and policies for TorchDynamo compilation decisions.

This module defines the rules that govern what code TorchDynamo should trace and compile
versus what should be executed eagerly. It contains functions and classes that determine:

- Which modules, functions, and objects should be skipped during tracing
- Which parts of the code should cause graph breaks
- How to handle different Python libraries and third-party packages
- Rules for determining when to inline functions vs calling them eagerly

Key components:
- Skip rules: Functions that return True if an object should be skipped during tracing
- Inlining rules: Policies for when to inline function calls during compilation
- Library-specific handling: Special cases for popular Python packages
- Performance heuristics: Rules that balance compilation overhead vs runtime benefits

These rules are critical for TorchDynamo's ability to automatically determine
compilation boundaries and optimize PyTorch programs effectively.
"""
np: Optional[types.ModuleType] = ...
manual_torch_name_rule_map: dict[
    str,
    type[Union[TorchInGraphFunctionVariable, SkipFunctionVariable, UserFunctionVariable]],
] = ...
torch_c_binding_in_graph_functions = ...
if sys.version_info >= (3, 11): ...
torch_non_c_binding_in_graph_functions = ...
torch_name_rule_map = ...

@functools.cache
def get_torch_obj_rule_map() -> dict[Any, type[VariableTracker]]: ...
def load_object(name: str) -> Any: ...
@functools.cache
def get_tensor_method() -> frozenset[Any]: ...
def is_aten_op_or_tensor_method(obj: Any) -> bool: ...

class FunctionIdSet:
    function_ids: Optional[set[int]] = ...
    function_names: Optional[dict[int, str]] = ...
    def __init__(self, lazy_initializer: Callable[[], Union[dict[int, str], set[int]]]) -> None: ...
    def __call__(self) -> set[int]: ...
    def get_name(self, idx: int, default: str) -> str: ...
    def add(self, idx: int) -> None: ...
    def remove(self, idx: int) -> None: ...
    def __contains__(self, idx: int) -> bool: ...

_lazy_module_init: dict[str, list[Callable[[], None]]] = ...

def add_module_init_func(name: str, init_func: Callable[[], None]) -> None: ...
def is_callable_allowed(obj: Any) -> bool: ...
def is_nonstrict_trace_callable(obj: Any) -> bool: ...
def is_callable_disallowed(obj: Any) -> bool: ...
def is_forbidden(obj: Any) -> bool: ...
def is_builtin_callable(obj: Any) -> bool: ...
def is_builtin_constant(obj: Any) -> bool: ...
def is_polyfilled_callable(obj: Any) -> bool: ...
def is_numpy(obj: Any) -> bool: ...
def is_numpy_dtype(obj: Any) -> bool: ...
def is_numpy_type_info(obj: Any) -> bool: ...

BUILTIN_SKIPLIST = ...
THIRDPARTY_SKIPLIST = ...
LEGACY_MOD_INLINELIST = ...
if torch.distributed.is_available(): ...
MOD_INLINELIST = ...
MOD_INLINELIST = ...
if torch.distributed.is_available(): ...
MOD_SKIPLIST = ...
MOD_SKIPLIST = ...

@functools.cache
def get_legacy_mod_inlinelist() -> set[str]: ...
@functools.cache
def get_mod_inlinelist() -> set[str]: ...
@functools.cache
def get_mod_skiplist() -> set[str]: ...

SKIP_DIRS = ...
SKIP_DIRS_RE = ...
FBCODE_SKIP_DIRS: set[str] = ...
FBCODE_SKIP_DIRS_RE = ...
FBCODE_SKIP_TORCHREC_DIRS = ...
FBCODE_SKIP_TORCHREC_DIRS_RE = ...
FBCODE_INLINE_FILES_IN_SKIPPED_DIRS = ...
FBCODE_INLINE_FILES_IN_SKIPPED_DIRS_RE = ...
FORCE_SKIP_FILES = ...

def add(import_name: str) -> None: ...

@dataclasses.dataclass
class SkipResult:
    skipped: bool
    reason: Optional[str]

def check_file(filename: Optional[str], is_inlined_call: bool = ...) -> SkipResult: ...

@dataclasses.dataclass
class FunctionInfo:
    py_obj: Optional[object]
    name: Optional[str]
    filename: str
    code: Optional[types.CodeType]

def check_verbose(obj: Any, is_inlined_call: bool = ...) -> SkipResult: ...
def check(obj: Any, is_inlined_call: bool = ...) -> bool: ...
def is_torch_inline_allowed(filename: str) -> bool: ...
@functools.cache
def dynamo_dir() -> Optional[str]: ...
def is_torch(filename: str) -> bool: ...
def lookup_callable(obj: Callable[..., Any]) -> Optional[type[VariableTracker]]: ...
def lookup(obj: Any) -> Optional[type[VariableTracker]]: ...
def lookup_inner(
    obj: Any,
    name: Optional[str] = ...,
    filename: Optional[str] = ...,
    is_direct_call: bool = ...,
    reasons: Union[None, set[str]] = ...,
) -> Optional[type[VariableTracker]]: ...
def clear_lru_cache() -> None: ...
