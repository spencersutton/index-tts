import dataclasses
import functools
import types
from collections.abc import Callable
from typing import Any

import numpy as np
import torch.distributed

from .variables import SkipFunctionVariable, TorchInGraphFunctionVariable, UserFunctionVariable
from .variables.base import VariableTracker

np: types.ModuleType | None = ...
manual_torch_name_rule_map: dict[
    str, type[TorchInGraphFunctionVariable | SkipFunctionVariable | UserFunctionVariable]
] = ...
torch_c_binding_in_graph_functions = ...
torch_non_c_binding_in_graph_functions = ...
torch_name_rule_map = ...

@functools.cache
def get_torch_obj_rule_map() -> dict[Any, type[VariableTracker]]: ...
def load_object(name: str) -> Any: ...
@functools.cache
def get_tensor_method() -> frozenset[Any]: ...
def is_aten_op_or_tensor_method(obj: Any) -> bool: ...

class FunctionIdSet:
    function_ids: set[int] | None = ...
    function_names: dict[int, str] | None = ...
    def __init__(self, lazy_initializer: Callable[[], dict[int, str] | set[int]]) -> None: ...
    def __call__(self) -> set[int]: ...
    def get_name(self, idx: int, default: str) -> str: ...
    def add(self, idx: int) -> None: ...
    def remove(self, idx: int) -> None: ...
    def __contains__(self, idx: int) -> bool: ...

_lazy_module_init: dict[str, list[Callable[[], None]]] = ...

def add_module_init_func(name: str, init_func: Callable[[], None]) -> None: ...
def is_callable_allowed(obj: Any) -> bool: ...
def is_nonstrict_trace_callable(obj: Any) -> bool: ...
def is_callable_disallowed(obj: Any) -> bool: ...
def is_forbidden(obj: Any) -> bool: ...
def is_builtin_callable(obj: Any) -> bool: ...
def is_builtin_constant(obj: Any) -> bool: ...
def is_polyfilled_callable(obj: Any) -> bool: ...
def is_numpy(obj: Any) -> bool: ...
def is_numpy_dtype(obj: Any) -> bool: ...
def is_numpy_type_info(obj: Any) -> bool: ...

BUILTIN_SKIPLIST = ...
THIRDPARTY_SKIPLIST = ...
LEGACY_MOD_INLINELIST = ...
if torch.distributed.is_available(): ...
MOD_INLINELIST = ...
MOD_INLINELIST = ...
if torch.distributed.is_available(): ...
MOD_SKIPLIST = ...
MOD_SKIPLIST = ...

@functools.cache
def get_legacy_mod_inlinelist() -> set[str]: ...
@functools.cache
def get_mod_inlinelist() -> set[str]: ...
@functools.cache
def get_mod_skiplist() -> set[str]: ...

SKIP_DIRS = ...
SKIP_DIRS_RE = ...
FBCODE_SKIP_DIRS: set[str] = ...
FBCODE_SKIP_DIRS_RE = ...
FBCODE_SKIP_TORCHREC_DIRS = ...
FBCODE_SKIP_TORCHREC_DIRS_RE = ...
FBCODE_INLINE_FILES_IN_SKIPPED_DIRS = ...
FBCODE_INLINE_FILES_IN_SKIPPED_DIRS_RE = ...
FORCE_SKIP_FILES = ...

def add(import_name: str) -> None: ...

@dataclasses.dataclass
class SkipResult:
    skipped: bool
    reason: str | None

def check_file(filename: str | None, is_inlined_call: bool = ...) -> SkipResult: ...

@dataclasses.dataclass
class FunctionInfo:
    py_obj: object | None
    name: str | None
    filename: str
    code: types.CodeType | None

def check_verbose(obj: Any, is_inlined_call: bool = ...) -> SkipResult: ...
def check(obj: Any, is_inlined_call: bool = ...) -> bool: ...
def is_torch_inline_allowed(filename: str) -> bool: ...
@functools.cache
def dynamo_dir() -> str | None: ...
def is_torch(filename: str) -> bool: ...
def lookup_callable(obj: Callable[..., Any]) -> type[VariableTracker] | None: ...
def lookup(obj: Any) -> type[VariableTracker] | None: ...
def lookup_inner(
    obj: Any,
    name: str | None = ...,
    filename: str | None = ...,
    is_direct_call: bool = ...,
    reasons: None | set[str] = ...,
) -> type[VariableTracker] | None: ...
def clear_lru_cache() -> None: ...
