from collections.abc import Callable, Sequence
from enum import Enum
from typing import Any

from ..codegen import PyCodegen
from ..source import Source
from ..symbolic_convert import InstructionTranslator, InstructionTranslatorBase

class SourceType(Enum):
    Existing = ...
    New = ...

class MutationType:
    def __init__(self, typ: SourceType) -> None: ...

class ValueMutationNew(MutationType):
    def __init__(self) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...

class ValueMutationExisting(MutationType):
    is_modified: bool
    def __init__(self, is_modified: bool = ...) -> None: ...

class AttributeMutation(MutationType):
    def __init__(self, typ: SourceType) -> None: ...

class AttributeMutationExisting(AttributeMutation):
    def __init__(self) -> None: ...

class AttributeMutationNew(AttributeMutation):
    def __init__(self, cls_source: Source | None = ...) -> None: ...

def is_side_effect_safe(m: MutationType): ...

class AsPythonConstantNotImplementedError(NotImplementedError):
    vt: VariableTracker
    def __init__(self, vt: VariableTracker) -> None: ...

class VariableTrackerMeta(type):
    all_subclasses = ...
    def __instancecheck__(cls, instance) -> bool: ...
    def __init__(cls, name, bases, attrs) -> None: ...

class VariableTracker(metaclass=VariableTrackerMeta):
    _nonvar_fields = ...
    def clone(self, **kwargs): ...
    @classmethod
    def visit(cls, fn: Callable[[VariableTracker], None], value: Any, cache: dict[int, Any] | None = ...) -> None: ...
    def debug_repr(self): ...
    def python_type(self): ...
    def python_type_name(self): ...
    def as_python_constant(self): ...
    def guard_as_python_constant(self): ...
    def is_python_constant(self): ...
    def make_guard(self, fn): ...
    def const_getattr(self, tx: InstructionTranslator, name: str) -> Any: ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def is_proxy(self): ...
    def as_proxy(self): ...
    def maybe_fx_node(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def has_unpack_var_sequence(self, tx) -> bool: ...
    def has_force_unpack_var_sequence(self, tx) -> bool: ...
    def force_apply_to_var_sequence(self, tx, fn) -> None: ...
    def inspect_parameter_names(self) -> list[str]: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_function(
        self, tx: InstructionTranslator, args: Sequence[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def set_name_hint(self, name): ...
    def realize(self) -> VariableTracker: ...
    def unwrap(self) -> VariableTracker: ...
    def is_realized(self): ...
    def next_variable(self, tx): ...
    def is_strict_mode(self, tx): ...
    def is_mutable(self): ...
    def is_immutable(self): ...
    @staticmethod
    def build(tx: InstructionTranslatorBase, value: Any, source: Source | None = ...) -> Any: ...
    def __init__(self, *, source: Source = ..., mutation_type: MutationType = ...) -> None: ...

def typestr(*objs): ...
