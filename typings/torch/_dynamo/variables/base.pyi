from collections.abc import Sequence
from enum import Enum
from typing import Any, Callable, Optional, TYPE_CHECKING
from ..source import Source
from ..codegen import PyCodegen
from ..symbolic_convert import InstructionTranslator, InstructionTranslatorBase

"""
Core variable tracking functionality for Dynamo. This module defines the fundamental
classes and systems used to track and manage variables during Dynamo's operation.

The module provides:
1. VariableTracker - The base class for tracking variables during compilation
2. MutationType system - Classes for tracking and managing mutations to variables
3. Source type management - Utilities for tracking variable origins and scope
4. Variable state management - Tools for managing variable state and transformations

These components form the foundation of Dynamo's variable handling system,
enabling accurate tracking and transformation of Python code into optimized
computations.
"""
if TYPE_CHECKING: ...

class SourceType(Enum):
    Existing = ...
    New = ...

class MutationType:
    def __init__(self, typ: SourceType) -> None: ...

class ValueMutationNew(MutationType):
    def __init__(self) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...

class ValueMutationExisting(MutationType):
    is_modified: bool
    def __init__(self, is_modified: bool = ...) -> None: ...

class AttributeMutation(MutationType):
    def __init__(self, typ: SourceType) -> None: ...

class AttributeMutationExisting(AttributeMutation):
    def __init__(self) -> None: ...

class AttributeMutationNew(AttributeMutation):
    def __init__(self, cls_source: Optional[Source] = ...) -> None: ...

def is_side_effect_safe(m: MutationType):  # -> bool:
    ...

class AsPythonConstantNotImplementedError(NotImplementedError):
    vt: VariableTracker
    def __init__(self, vt: VariableTracker) -> None: ...

class VariableTrackerMeta(type):
    all_subclasses = ...
    def __instancecheck__(cls, instance) -> bool: ...
    def __init__(cls, name, bases, attrs) -> None: ...

class VariableTracker(metaclass=VariableTrackerMeta):
    _nonvar_fields = ...
    def clone(self, **kwargs):  # -> Self:

        ...
    @classmethod
    def visit(
        cls, fn: Callable[[VariableTracker], None], value: Any, cache: Optional[dict[int, Any]] = ...
    ) -> None: ...
    def debug_repr(self):  # -> str:
        ...
    def python_type(self):  # -> type[Any]:

        ...
    def python_type_name(self):  # -> str:
        ...
    def as_python_constant(self): ...
    def guard_as_python_constant(self): ...
    def is_python_constant(self):  # -> bool:
        ...
    def make_guard(self, fn):  # -> DataclassInstance:
        ...
    def const_getattr(self, tx: InstructionTranslator, name: str) -> Any: ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def is_proxy(self):  # -> bool:
        ...
    def as_proxy(self): ...
    def maybe_fx_node(self):  # -> Attribute | None:
        ...
    def reconstruct(self, codegen: PyCodegen): ...
    def unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def has_unpack_var_sequence(self, tx) -> bool: ...
    def has_force_unpack_var_sequence(self, tx) -> bool: ...
    def force_apply_to_var_sequence(self, tx, fn) -> None: ...
    def inspect_parameter_names(self) -> list[str]: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_function(
        self, tx: InstructionTranslator, args: Sequence[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def set_name_hint(self, name):  # -> None:
        ...
    def realize(self) -> VariableTracker: ...
    def unwrap(self) -> VariableTracker: ...
    def is_realized(self):  # -> Literal[True]:

        ...
    def next_variable(self, tx): ...
    def is_strict_mode(self, tx): ...
    def is_mutable(self):  # -> bool:

        ...
    def is_immutable(self):  # -> bool:

        ...
    @staticmethod
    def build(tx: InstructionTranslatorBase, value: Any, source: Optional[Source] = ...) -> Any: ...
    def __init__(self, *, source: Source = ..., mutation_type: MutationType = ...) -> None: ...

def typestr(*objs):  # -> str | LiteralString:
    ...
