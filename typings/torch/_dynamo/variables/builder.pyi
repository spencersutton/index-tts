import dataclasses
import re
import weakref
from typing import Any, NamedTuple, Union

import torch
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator
from torch.fx.experimental.symbolic_shapes import DimDynamic, SymIntSymbolicContext
from torch.utils.weak import TensorWeakRef

from ..pgo import FrameStateSizeEntry
from ..source import Source
from ..utils import odict_values, range_iterator, tuple_iterator
from .base import VariableTracker

log = ...
static_inputs_log = ...
DimList = list

def safe_has_grad(t): ...

class _missing: ...

@dataclasses.dataclass
class GraphArg:
    source: Source
    _example: TensorWeakRef | torch.SymInt
    pass_arg_as_tensor: bool
    fake_tensor: torch._subclasses.fake_tensor.FakeTensor | None
    is_tensor: bool = ...
    example_strong_ref: torch.Tensor | None = ...
    @property
    def example(self): ...
    def __post_init__(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def erase(self): ...
    def __eq__(self, other) -> bool: ...

class BackwardStateGraphArg(GraphArg):
    def __init__(self) -> None: ...
    def reconstruct(self, codegen: PyCodegen): ...

ITERTOOLS_TYPE_IDS: frozenset[int] = ...
ITERTOOLS_POLYFILLED_TYPE_IDS: set[int] = ...
og_module_named_buffers_fn_ptr = ...
og_module_named_parameters_fn_ptr = ...

class VariableBuilder:
    def __init__(self, tx, source: Source) -> None: ...
    def __call__(self, value): ...
    def get_source(self): ...
    def install_guards(self, *guards): ...
    def wrap_regex_pattern(self, value: re.Pattern): ...
    def wrap_weakref(self, value: weakref.ReferenceType): ...
    def wrap_removable_handle(self, value): ...
    def wrap_jit_function(self, value): ...
    def wrap_mapping_proxy(self, value): ...
    def wrap_user_defined(self, value: Any): ...
    def wrap_listlike(self, value: Union[tuple, list, odict_values, NamedTuple]): ...
    def wrap_tuple_iterator(self, value: tuple_iterator): ...
    def wrap_range_iterator(self, value: range_iterator): ...
    def wrap_slice_range(self, value: slice | range): ...
    def mark_static_input(self, value: torch.Tensor, guard: bool): ...
    def wrap_module(self, value: torch.nn.Module): ...
    def wrap_literal(self, value): ...
    def assert_not_wrapped_by_this_graph(self, value: torch.Tensor): ...
    def wrap_tensor(self, value: torch.Tensor): ...
    def wrap_numpy_ndarray(self, value): ...
    def wrap_symint(self, value, dynamism: DimDynamic | None = ..., context: SymIntSymbolicContext | None = ...): ...
    def wrap_symfloat(self, value): ...
    def wrap_unspecialized_primitive(self, value): ...

def wrap_fx_proxy(tx, proxy, example_value=..., subclass_type=..., **options) -> VariableTracker: ...
def cache_real_value_when_export(tx, proxy, example_value): ...
def wrap_fx_proxy_cls(target_cls, tx, proxy, example_value=..., subclass_type=..., **options): ...
def handle_traced_output(example_value, tx, proxy, options, subclass_type, target_cls): ...
def infer_subclass_type(value): ...
def get_specialized_props(target_cls, tx, example_value, subclass_type): ...
def construct_tensor_variable(target_cls, tx, proxy, example_value, subclass_type, options): ...
def get_automatic_dynamic_shapes_mark_as(): ...

_DYNAMIC_SOURCES: set[str] | None = ...
_DYNAMIC_SOURCES_CONFIG_HASH: int | None = ...

def get_dynamic_sources() -> set[str]: ...
def is_dynamic_source(source_name: str) -> bool: ...
def record_automatic_dynamic(tx: InstructionTranslator, name: str, e: torch.Tensor) -> FrameStateSizeEntry: ...

_UNBACKED_SOURCES: set[str] | None = ...
_UNBACKED_SOURCES_CONFIG_HASH: int | None = ...

def get_unbacked_sources() -> set[str]: ...
def is_unbacked_source(source_name: str) -> bool: ...
def wrap_to_fake_tensor_and_record(e, tx, *, source: Source | None, is_tensor: bool, parent_context=...): ...

class SourcelessBuilder:
    def __init__(self) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, value) -> VariableTracker: ...
    @staticmethod
    def wrap_constant_literal(value): ...
    @staticmethod
    def make_type_handlers(): ...

class SourcelessUserDefinedObjectBuilder:
    def __init__(self) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, value) -> VariableTracker: ...
