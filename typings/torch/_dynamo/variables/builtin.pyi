import contextlib
import typing
from collections.abc import Sequence
from typing import Any, Callable, TYPE_CHECKING, Union
from torch.overrides import BaseTorchFunctionMode
from .base import VariableTracker
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
Built-in function and type variable tracking for TorchDynamo's symbolic execution.

This module contains variable tracker classes for Python built-in functions, types,
and operations during graph compilation. It handles symbolic execution of:

- Built-in functions (len, getattr, isinstance, etc.)
- Type constructors (int, float, str, list, dict, etc.)
- Built-in operators and methods
- Special Python constructs (super, hasattr, etc.)

Key classes:
- BuiltinVariable: Tracks built-in functions and handles their execution
- TypeVariable: Manages type constructor calls and type checking
- SuperVariable: Handles super() calls in class hierarchies

These variable trackers ensure that built-in Python operations are correctly
handled during symbolic execution, either by executing them directly when safe
or by creating appropriate graph nodes when needed.
"""
if TYPE_CHECKING: ...
log = ...
IN_PLACE_DESUGARING_MAP = ...
_HandlerCallback: typing.TypeAlias = Callable[[InstructionTranslator, typing.Any, typing.Any], VariableTracker]
_TrackersType: typing.TypeAlias = Union[type[VariableTracker], tuple[type[VariableTracker], ...]]
polyfill_fn_mapping = ...
bin_ops = ...
bin_int_ops = ...
un_int_ops = ...
tensor_and_int_ops = ...
un_ops = ...
BUILTIN_TO_TENSOR_FN_MAP: dict[Callable[..., Any], Callable[..., Any]] = ...
BUILTIN_TO_TENSOR_RFN_MAP: dict[Callable[..., Any], Callable[..., Any]] = ...

def populate_builtin_to_tensor_fn_map():  # -> None:
    ...

class BuiltinVariable(VariableTracker):
    _SENTINEL = ...
    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source):  # -> Self:
        ...
    def can_constant_fold_through(self):  # -> bool:
        ...
    def can_insert_in_graph(self):  # -> bool:
        ...
    def __init__(self, fn, **kwargs) -> None: ...
    def as_python_constant(self):  # -> Any:
        ...
    def as_proxy(self):  # -> dtype:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def constant_args(self, *args, **kwargs):  # -> bool:
        ...
    def tensor_args(self, *args):  # -> bool:
        ...
    def tensor_args_type(self, arg_types):  # -> bool:
        ...
    def python_and_tensor_constant_only(self, *args, **kwargs):  # -> bool:
        ...
    @staticmethod
    def unwrap_unspec_args_kwargs(args, kwargs):  # -> tuple[list[Any], dict[Any, Any]]:
        ...
    def has_constant_handler(self, args, kwargs):  # -> bool:
        ...
    def call_vars(self, tx: InstructionTranslator, *args): ...

    call_function_handler_cache: dict[
        tuple[object, ...],
        Callable[
            [InstructionTranslator, Sequence[VariableTracker], dict[str, VariableTracker]],
            VariableTracker,
        ],
    ] = ...
    def call_function(
        self, tx: InstructionTranslator, args: Sequence[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

    call_int = ...
    call_float = ...
    def call_bool(self, tx: InstructionTranslator, arg):  # -> SymNodeVariable | VariableTracker | None:
        ...
    def call_str(self, tx: InstructionTranslator, arg):  # -> VariableTracker | Any | None:
        ...

    call_min = ...
    call_max = ...
    def call_abs(self, tx: InstructionTranslator, arg: VariableTracker):  # -> VariableTracker:
        ...
    def call_pos(self, tx: InstructionTranslator, arg: VariableTracker):  # -> VariableTracker:
        ...
    def call_index(self, tx: InstructionTranslator, arg: VariableTracker):  # -> VariableTracker:
        ...
    def call_round(self, tx: InstructionTranslator, arg, *args, **kwargs):  # -> VariableTracker:
        ...
    def call_range(self, tx: InstructionTranslator, *args):  # -> RangeVariable | None:
        ...
    def call_slice(self, tx: InstructionTranslator, *args):  # -> SliceVariable:
        ...
    def call_iter(
        self, tx: InstructionTranslator, obj, *args, **kwargs
    ):  # -> ObjectIteratorVariable | VariableTracker | IteratorVariable | DelayGraphBreakVariable | RangeIteratorVariable | ConstantVariable | RangeVariable | ListIteratorVariable | ListVariable | SizeVariable | TupleVariable | DequeVariable | SliceVariable:
        ...

    call_tuple = ...
    call_list = ...
    def call_callable(self, tx: InstructionTranslator, arg):  # -> VariableTracker | None:
        ...
    def call_cast(self, _, *args, **kwargs): ...
    def call_dir(self, tx: InstructionTranslator, arg):  # -> Any | None:
        ...
    def call_dict(self, tx: InstructionTranslator, *args, **kwargs):  # -> Any:
        ...
    @staticmethod
    def call_custom_dict(tx: InstructionTranslator, user_cls, *args, **kwargs):  # -> Any:
        ...
    @staticmethod
    def call_custom_dict_fromkeys(
        tx: InstructionTranslator, user_cls, *args, **kwargs
    ):  # -> ConstDictVariable | DefaultDictVariable:
        ...
    def call_set(self, tx: InstructionTranslator, *args, **kwargs):  # -> SetVariable:
        ...
    def call_frozenset(self, tx: InstructionTranslator, *args, **kwargs):  # -> FrozensetVariable:
        ...
    def call_zip(self, tx: InstructionTranslator, *args, **kwargs):  # -> ZipVariable:
        ...
    def call_len(self, tx: InstructionTranslator, *args, **kwargs): ...
    def call_getitem(self, tx: InstructionTranslator, *args, **kwargs): ...
    def call_isinstance(self, tx: InstructionTranslator, arg, isinstance_type):  # -> VariableTracker:
        ...
    def call_issubclass(self, tx: InstructionTranslator, left_ty, right_ty):  # -> ConstantVariable:

        ...
    def call_super(self, tx: InstructionTranslator, a, b):  # -> SuperVariable:
        ...
    def call_next(self, tx: InstructionTranslator, *args):  # -> VariableTracker:
        ...
    def call_hasattr(self, tx: InstructionTranslator, obj, attr):  # -> ConstantVariable | None:
        ...
    def call_map(self, tx: InstructionTranslator, fn, *seqs):  # -> MapVariable:
        ...
    def call_filter(self, tx: InstructionTranslator, fn, seq):  # -> FilterVariable:
        ...
    def var_getattr(self, tx: InstructionTranslator, name):  # -> Any | GetAttrVariable:
        ...
    def call_getattr(
        self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker, default=...
    ):  # -> VariableTracker | TupleVariable | Any | GetAttrVariable | UserDefinedClassVariable | NNModuleVariable | UnspecializedNNModuleVariable | UserMethodVariable | UserFunctionVariable | DelayGraphBreakVariable | WrapperUserMethodVariable | LazyVariableTracker | BuiltinVariable | ConstDictVariable | NNModuleHooksDictVariable | TorchInGraphFunctionVariable | None:
        ...
    def call_setattr(
        self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker, val: VariableTracker
    ):  # -> ConstantVariable | VariableTracker | ExceptionVariable | TensorVariable | None:
        ...
    def call_delattr(
        self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker
    ):  # -> VariableTracker:
        ...
    def call_type(self, tx: InstructionTranslator, obj: VariableTracker):  # -> Any:
        ...
    def call_reversed(self, tx: InstructionTranslator, obj: VariableTracker):  # -> TupleVariable | None:
        ...
    def call_sorted(
        self, tx: InstructionTranslator, obj: VariableTracker, **kwargs: VariableTracker
    ):  # -> ListVariable | None:
        ...
    def call_neg(self, tx: InstructionTranslator, a):  # -> VariableTracker | SymNodeVariable | None:
        ...
    def call_format(
        self, tx: InstructionTranslator, _format_string, *args, **kwargs
    ):  # -> VariableTracker | StringFormatVariable:
        ...
    def call_id(self, tx: InstructionTranslator, *args):  # -> VariableTracker:
        ...
    def call_deepcopy(self, tx: InstructionTranslator, x): ...
    def call_xor(self, tx: InstructionTranslator, a, b):  # -> VariableTracker | None:
        ...
    def call_ixor(self, tx: InstructionTranslator, a, b):  # -> VariableTracker | None:
        ...
    def call_sub(self, tx: InstructionTranslator, a, b):  # -> VariableTracker | None:
        ...
    def call_isub(self, tx: InstructionTranslator, a, b):  # -> VariableTracker | None:
        ...
    def call_and_(self, tx: InstructionTranslator, a, b):  # -> VariableTracker | SymNodeVariable | None:
        ...
    def call_iand(self, tx: InstructionTranslator, a, b):  # -> VariableTracker | SymNodeVariable | None:
        ...
    def call_or_(self, tx: InstructionTranslator, a, b):  # -> VariableTracker | SymNodeVariable | None:
        ...
    def call_ior(self, tx: InstructionTranslator, a, b):  # -> VariableTracker | SymNodeVariable | None:
        ...
    def call_not_(self, tx: InstructionTranslator, a):  # -> VariableTracker | SymNodeVariable | None:
        ...
    def call_contains(self, tx: InstructionTranslator, a: VariableTracker, b: VariableTracker):  # -> VariableTracker:
        ...

@contextlib.contextmanager
def dynamo_disable_grad(tx):  # -> Generator[None, Any, None]:
    ...
