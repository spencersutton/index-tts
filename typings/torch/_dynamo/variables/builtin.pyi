"""
Built-in function and type variable tracking for TorchDynamo's symbolic execution.

This module contains variable tracker classes for Python built-in functions, types,
and operations during graph compilation. It handles symbolic execution of:

- Built-in functions (len, getattr, isinstance, etc.)
- Type constructors (int, float, str, list, dict, etc.)
- Built-in operators and methods
- Special Python constructs (super, hasattr, etc.)

Key classes:
- BuiltinVariable: Tracks built-in functions and handles their execution
- TypeVariable: Manages type constructor calls and type checking
- SuperVariable: Handles super() calls in class hierarchies

These variable trackers ensure that built-in Python operations are correctly
handled during symbolic execution, either by executing them directly when safe
or by creating appropriate graph nodes when needed.
"""

import contextlib
import typing
from collections.abc import Callable, Sequence
from typing import Any

from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

from .base import VariableTracker

log = ...
IN_PLACE_DESUGARING_MAP = ...
type _HandlerCallback = Callable[[InstructionTranslator, typing.Any, typing.Any], VariableTracker]
type _TrackersType = type[VariableTracker] | tuple[type[VariableTracker], ...]
polyfill_fn_mapping = ...
bin_ops = ...
bin_int_ops = ...
un_int_ops = ...
tensor_and_int_ops = ...
un_ops = ...
BUILTIN_TO_TENSOR_FN_MAP: dict[Callable[..., Any], Callable[..., Any]] = ...
BUILTIN_TO_TENSOR_RFN_MAP: dict[Callable[..., Any], Callable[..., Any]] = ...

def populate_builtin_to_tensor_fn_map() -> None: ...

class BuiltinVariable(VariableTracker):
    """
    A VariableTracker that represents a built-in value (functions and operators).
    A lot of the code here assumes it will be a function object.

    The BuiltinVariable class wraps Python built-in functions (like len, isinstance, etc.)
    and operators (like +, -, *, etc.) to enable symbolic execution during tracing. This allows
    Dynamo to properly handle these operations when converting Python code to FX graphs while
    maintaining correct semantics and enabling optimizations.
    """

    _SENTINEL = ...
    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source): ...
    def can_constant_fold_through(self): ...
    def can_insert_in_graph(self): ...
    def __init__(self, fn, **kwargs) -> None: ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def constant_args(self, *args, **kwargs): ...
    def tensor_args(self, *args): ...
    def tensor_args_type(self, arg_types): ...
    def python_and_tensor_constant_only(self, *args, **kwargs): ...
    @staticmethod
    def unwrap_unspec_args_kwargs(args, kwargs): ...
    def has_constant_handler(self, args, kwargs): ...
    def call_vars(self, tx: InstructionTranslator, *args): ...

    call_function_handler_cache: dict[
        tuple[object, ...],
        Callable[[InstructionTranslator, Sequence[VariableTracker], dict[str, VariableTracker]], VariableTracker],
    ] = ...
    def call_function(
        self, tx: InstructionTranslator, args: Sequence[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

    call_int = ...
    call_float = ...
    def call_bool(self, tx: InstructionTranslator, arg): ...
    def call_str(self, tx: InstructionTranslator, arg): ...

    call_min = ...
    call_max = ...
    def call_abs(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def call_pos(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def call_index(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def call_round(self, tx: InstructionTranslator, arg, *args, **kwargs): ...
    def call_range(self, tx: InstructionTranslator, *args): ...
    def call_slice(self, tx: InstructionTranslator, *args): ...
    def call_iter(self, tx: InstructionTranslator, obj, *args, **kwargs): ...

    call_tuple = ...
    call_list = ...
    def call_callable(self, tx: InstructionTranslator, arg): ...
    def call_cast(self, _, *args, **kwargs): ...
    def call_dir(self, tx: InstructionTranslator, arg): ...
    def call_dict(self, tx: InstructionTranslator, *args, **kwargs): ...
    @staticmethod
    def call_custom_dict(tx: InstructionTranslator, user_cls, *args, **kwargs): ...
    @staticmethod
    def call_custom_dict_fromkeys(tx: InstructionTranslator, user_cls, *args, **kwargs): ...
    def call_set(self, tx: InstructionTranslator, *args, **kwargs): ...
    def call_frozenset(self, tx: InstructionTranslator, *args, **kwargs): ...
    def call_zip(self, tx: InstructionTranslator, *args, **kwargs): ...
    def call_len(self, tx: InstructionTranslator, *args, **kwargs): ...
    def call_getitem(self, tx: InstructionTranslator, *args, **kwargs): ...
    def call_isinstance(self, tx: InstructionTranslator, arg, isinstance_type): ...
    def call_issubclass(self, tx: InstructionTranslator, left_ty, right_ty):
        """Checks if first arg is subclass of right arg"""
    def call_super(self, tx: InstructionTranslator, a, b): ...
    def call_next(self, tx: InstructionTranslator, *args): ...
    def call_hasattr(self, tx: InstructionTranslator, obj, attr): ...
    def call_map(self, tx: InstructionTranslator, fn, *seqs): ...
    def call_filter(self, tx: InstructionTranslator, fn, seq): ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def call_getattr(self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker, default=...): ...
    def call_setattr(
        self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker, val: VariableTracker
    ): ...
    def call_delattr(self, tx: InstructionTranslator, obj: VariableTracker, name_var: VariableTracker): ...
    def call_type(self, tx: InstructionTranslator, obj: VariableTracker): ...
    def call_reversed(self, tx: InstructionTranslator, obj: VariableTracker): ...
    def call_sorted(self, tx: InstructionTranslator, obj: VariableTracker, **kwargs: VariableTracker): ...
    def call_neg(self, tx: InstructionTranslator, a): ...
    def call_format(self, tx: InstructionTranslator, _format_string, *args, **kwargs): ...
    def call_id(self, tx: InstructionTranslator, *args): ...
    def call_deepcopy(self, tx: InstructionTranslator, x): ...
    def call_xor(self, tx: InstructionTranslator, a, b): ...
    def call_ixor(self, tx: InstructionTranslator, a, b): ...
    def call_sub(self, tx: InstructionTranslator, a, b): ...
    def call_isub(self, tx: InstructionTranslator, a, b): ...
    def call_and_(self, tx: InstructionTranslator, a, b): ...
    def call_iand(self, tx: InstructionTranslator, a, b): ...
    def call_or_(self, tx: InstructionTranslator, a, b): ...
    def call_ior(self, tx: InstructionTranslator, a, b): ...
    def call_not_(self, tx: InstructionTranslator, a): ...
    def call_contains(self, tx: InstructionTranslator, a: VariableTracker, b: VariableTracker): ...

@contextlib.contextmanager
def dynamo_disable_grad(tx): ...
