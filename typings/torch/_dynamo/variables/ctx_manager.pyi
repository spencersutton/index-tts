from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

from .base import VariableTracker
from .user_defined import UserDefinedObjectVariable

class ContextWrappingVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, target_values, initial_values=..., **kwargs) -> None: ...
    def enter(self, tx): ...
    def set_cleanup_hook(self, tx: InstructionTranslator, fn=...): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def reconstruct_type(self, codegen: PyCodegen): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def module_name(self): ...
    def fn_name(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def supports_graph_breaks(self): ...
    def exit_on_graph_break(self): ...
    def cleanup(self): ...
    def cleanup_assert(self): ...

class GenericContextWrappingVariable(UserDefinedObjectVariable):
    def __init__(self, cm_obj, **kwargs) -> None: ...
    def module_name(self): ...
    def fn_name(self): ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def supports_graph_breaks(self): ...
    def exit_on_graph_break(self): ...

class RepararametrizeModuleContextVariable(GenericContextWrappingVariable):
    def __init__(self, ctx_manager_vt, mod) -> None: ...
    def enter(self, tx: InstructionTranslator): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def __getattr__(self, name): ...

class GradInplaceRequiresGradCtxManagerVariable(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, target_values, **kwargs): ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...

class TemporarilyPopInterpreterStackCtxManagerVariable(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, target_values, **kwargs): ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...

class JvpIncrementNestingCtxManagerVariable(ContextWrappingVariable):
    _guards_singleton = ...
    @staticmethod
    def create(tx: InstructionTranslator, **kwargs): ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...

class SetFwdGradEnabledContextManager(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, target_values, **kwargs): ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...

class DualLevelContextManager(ContextWrappingVariable):
    _guards_singleton = ...
    @staticmethod
    def create(tx: InstructionTranslator, **kwargs): ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...

class GradIncrementNestingCtxManagerVariable(ContextWrappingVariable):
    _guards_singleton = ...
    @staticmethod
    def create(tx: InstructionTranslator, **kwargs): ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...

class CatchWarningsCtxManagerVariable(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, catch_warnings_args): ...
    def __init__(self, catch_warnings_args, **kwargs) -> None: ...
    def enter(self, tx): ...
    def reconstruct(self, cg): ...

class VmapIncrementNestingCtxManagerVariable(ContextWrappingVariable):
    _guards_singleton = ...
    @staticmethod
    def create(tx: InstructionTranslator, target_values, **kwargs): ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...

class GradModeVariable(ContextWrappingVariable):
    _guards_singleton = ...
    @staticmethod
    def create(tx: InstructionTranslator, target_value, initialized=..., **kwargs): ...
    def __init__(self, target_values, initial_values=..., initialized=..., **kwargs) -> None: ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ): ...
    def module_name(self): ...
    def fn_name(self): ...

class InferenceModeVariable(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, target_value, **kwargs): ...
    def __init__(self, target_values, initial_values=..., **kwargs) -> None: ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def enter(self, tx): ...
    def module_name(self): ...
    def fn_name(self): ...

class CUDADeviceVariable(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, device, **kwargs): ...
    def __init__(self, target_values, initial_values=..., **kwargs) -> None: ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def enter(self, tx): ...
    def module_name(self): ...
    def fn_name(self): ...

class TorchFunctionDisableVariable(ContextWrappingVariable):
    _guards_singleton = ...
    @staticmethod
    def create(tx: InstructionTranslator, **kwargs): ...
    def __init__(self, target_values, initial_values=..., only_subclass=..., **kwargs) -> None: ...
    def set_cleanup_hook(self, tx: InstructionTranslator, fn=...): ...
    def module_name(self): ...
    def fn_name(self): ...

class DeterministicAlgorithmsVariable(ContextWrappingVariable):
    _guards_singleton = ...
    @staticmethod
    def create(tx: InstructionTranslator, target_value, **kwargs): ...
    def __init__(self, target_values, initial_values=..., **kwargs) -> None: ...
    def enter(self, tx): ...
    def module_name(self): ...
    def fn_name(self): ...

class DisabledSavedTensorsHooksVariable(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, target_value, **kwargs): ...
    def __init__(self, target_values, initial_values=..., **kwargs) -> None: ...
    def enter(self, tx): ...
    def module_name(self): ...
    def fn_name(self): ...

class AutocastModeVariable(ContextWrappingVariable):
    @staticmethod
    def create(func, args, kwargs): ...
    def __init__(self, target_values, initial_values=..., **kwargs) -> None: ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def enter(self, tx): ...
    def module_name(self): ...
    def fn_name(self): ...

class NullContextVariable(ContextWrappingVariable):
    def __init__(self, target_values=..., **kwargs) -> None: ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def module_name(self): ...
    def fn_name(self): ...

class ProfilerContextVariable(ContextWrappingVariable):
    def __init__(self, **kwargs) -> None: ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def module_name(self): ...
    def fn_name(self): ...
    def reconstruct(self, cg): ...

class StreamContextVariable(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, target_value, **kwargs): ...
    def __init__(self, target_values, device, initial_values=..., **kwargs) -> None: ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...

class PreserveVersionContextVariable(ContextWrappingVariable):
    @staticmethod
    def constructor(tx): ...
    def __init__(self, tensors, prev_versions, **kwargs) -> None: ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def reconstruct(self, codegen: PyCodegen): ...

class FSDPParamGroupUseTrainingStateVariable(ContextWrappingVariable):
    _guards_singleton = ...
    @staticmethod
    def create(tx: InstructionTranslator, param_group_var, target_value, **kwargs): ...
    def __init__(self, param_group_var, target_values, initial_values=..., **kwargs) -> None: ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ): ...
    def module_name(self): ...
    def fn_name(self): ...

class SDPAKernelVariable(ContextWrappingVariable):
    @staticmethod
    def create(tx: InstructionTranslator, backends, set_priority=..., **kwargs): ...
    def __init__(
        self, target_values: list[torch.nn.attention.SDPBackend], initial_values=..., set_priority: bool = ..., **kwargs
    ) -> None: ...
    def enter(self, tx): ...
    def exit(self, tx: InstructionTranslator, *args): ...
    def module_name(self): ...
    def fn_name(self): ...

class StreamVariable(VariableTracker):
    def __init__(self, proxy, value, device, **kwargs) -> None: ...
    def python_type(self): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen): ...

class EventVariable(VariableTracker):
    def __init__(self, proxy, value, **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen): ...

class DynamoConfigPatchVariable(ContextWrappingVariable):
    def __init__(self, target_values, **kwargs) -> None: ...
    def module_name(self): ...
    def fn_name(self): ...

class ErrorOnGraphBreakVariable(ContextWrappingVariable):
    def __init__(self, error_on_graph_break, **kwargs) -> None: ...
    def module_name(self): ...
    def fn_name(self): ...

class WithExitFunctionVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, ctx: ContextWrappingVariable | GenericContextWrappingVariable, target, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen: PyCodegen): ...
