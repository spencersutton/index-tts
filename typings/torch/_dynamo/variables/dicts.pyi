from typing import TYPE_CHECKING, Optional

from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

from .base import VariableTracker

"""
Dictionary-related variable tracking classes for PyTorch Dynamo.

This module implements variable tracking for different types of dictionary-like objects:
- Regular Python dictionaries (dict)
- Ordered dictionaries (collections.OrderedDict)
- Default dictionaries (collections.defaultdict)
- Dictionary views (keys and values)
- Sets and frozensets (implemented internally using dictionaries)

These classes are responsible for tracking dictionary operations during graph compilation,
maintaining proper guards for dictionary mutations and key existence checks. They handle
dictionary creation, modification, key/value access, and view operations while ensuring
correct behavior in the compiled code through appropriate guard installation.

The implementation uses a special _HashableTracker wrapper to handle dictionary keys
while preserving proper aliasing semantics. Sets are implemented as dictionaries with
None values for efficiency and code reuse.
"""
if TYPE_CHECKING: ...

def was_instancecheck_override(obj):  # -> Any:
    ...
def raise_unhashable(arg, tx=...): ...
def is_hashable(x):  # -> bool:
    ...

class ConstDictVariable(VariableTracker):
    CONTAINS_GUARD = ...
    _nonvar_fields = ...
    class _HashableTracker:
        def __init__(self, vt) -> None: ...
        @property
        def underlying_value(self):  # -> Any | Module | object | FunctionType | HashWrapper | tuple[Any, ...]:
            ...
        def __hash__(self) -> int: ...
        def __eq__(self, other: ConstDictVariable._HashableTracker) -> bool: ...

    def __init__(self, items: dict[VariableTracker, VariableTracker], user_cls=..., **kwargs) -> None: ...
    def as_proxy(self):  # -> dict[Any, Any]:
        ...
    def debug_repr(self):  # -> str:
        ...
    def as_python_constant(self):  # -> dict[Any, Any]:
        ...
    def keys_as_python_constant(self):  # -> dict[Any, Any | VariableTracker]:
        ...
    def python_type(self):  # -> type[dict[Any, Any]]:
        ...
    def __contains__(self, vt) -> bool: ...
    def len(self) -> int: ...
    def has_new_items(self) -> bool: ...
    def is_new_item(self, value, other):  # -> bool:
        ...
    def reconstruct_kvs_into_new_dict(self, codegen):  # -> None:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def getitem_const_raise_exception_if_absent(
        self, tx: InstructionTranslator, arg: VariableTracker
    ):  # -> VariableTracker:
        ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker):  # -> VariableTracker:
        ...
    def maybe_getitem_const(self, arg: VariableTracker):  # -> VariableTracker | None:
        ...
    def realize_key_vt(self, arg: VariableTracker):  # -> None:
        ...
    def install_dict_keys_match_guard(self):  # -> None:
        ...
    def install_dict_contains_guard(self, tx, args):  # -> None:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def unpack_var_sequence(self, tx):  # -> list[Any]:
        ...
    def call_obj_hasattr(self, tx, name):  # -> VariableTracker:
        ...
    def clone(self, **kwargs):  # -> Self:
        ...

class MappingProxyVariable(VariableTracker):
    def __init__(self, dv_dict: ConstDictVariable, **kwargs) -> None: ...
    def python_type(self):  # -> type[MappingProxyType[Any, Any]]:
        ...
    def unpack_var_sequence(self, tx):  # -> list[Any]:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class NNModuleHooksDictVariable(ConstDictVariable):
    def install_dict_keys_match_guard(self):  # -> None:
        ...
    def install_dict_contains_guard(self, tx, args):  # -> None:
        ...

class DefaultDictVariable(ConstDictVariable):
    def __init__(self, items, user_cls, default_factory=..., **kwargs) -> None: ...
    def is_python_constant(self):  # -> bool:
        ...
    def debug_repr(self):  # -> str:
        ...
    @staticmethod
    def is_supported_arg(arg):  # -> bool:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen):  # -> None:
        ...

class SetVariable(ConstDictVariable):
    CONTAINS_GUARD = ...
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def debug_repr(self):  # -> LiteralString | Literal['set()']:
        ...
    @property
    def set_items(self):  # -> set[str | _HashableTracker]:
        ...
    def as_proxy(self):  # -> set[Any]:
        ...
    def python_type(self):  # -> type[set[Any]]:
        ...
    def as_python_constant(self):  # -> set[Any]:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def install_dict_keys_match_guard(self):  # -> None:
        ...
    def install_dict_contains_guard(self, tx, args):  # -> None:
        ...

class FrozensetVariable(SetVariable):
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def debug_repr(self):  # -> LiteralString | Literal['frozenset()']:
        ...
    @property
    def set_items(
        self,
    ):  # -> _odict_keys[Any, Any] | dict_keys[str, Any] | dict_keys[_HashableTracker, VariableTracker]:
        ...
    def python_type(self):  # -> type[frozenset[Any]]:
        ...
    def as_python_constant(self):  # -> frozenset[Any]:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class DictKeySetVariable(SetVariable):
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def debug_repr(self):  # -> LiteralString | Literal['dict_keys([])']:
        ...
    def install_dict_keys_match_guard(self):  # -> None:
        ...
    def install_dict_contains_guard(self, tx, args):  # -> None:
        ...
    @property
    def set_items(self):  # -> OrderedDict[Any, Any] | defaultdict[str, Any] | dict[_HashableTracker, VariableTracker]:
        ...
    def python_type(self):  # -> type[KeysView[Any]]:
        ...
    def as_python_constant(self):  # -> dict_keys[Any, Any | None]:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class DictViewVariable(VariableTracker):
    kv: str | None = ...
    def __init__(self, dv_dict: ConstDictVariable, **kwargs) -> None: ...
    @property
    def view_items(self):  # -> Any:
        ...
    @property
    def view_items_vt(self): ...
    def unpack_var_sequence(self, tx): ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def call_obj_hasattr(self, tx, name):  # -> VariableTracker:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class DictKeysVariable(DictViewVariable):
    kv = ...
    @property
    def set_items(self):  # -> set[Any]:
        ...
    @property
    def view_items_vt(self):  # -> list[Any]:
        ...
    def python_type(self):  # -> type[KeysView[Any]]:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class DictValuesVariable(DictViewVariable):
    kv = ...
    @property
    def view_items_vt(self):  # -> list[Any]:
        ...
    def python_type(self):  # -> type[ValuesView[Any]]:
        ...

class DictItemsVariable(DictViewVariable):
    kv = ...
    @property
    def view_items_vt(self):  # -> list[TupleVariable]:
        ...
    def python_type(self):  # -> type[ItemsView[Any, Any]]:
        ...
