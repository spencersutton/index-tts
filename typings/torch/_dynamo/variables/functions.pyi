"""
Function-related variable tracking classes for Dynamo's symbolic execution.

This module contains classes that track different types of functions during graph
compilation, including:
- User-defined functions and methods
- Built-in functions and methods
- Wrapped functions (e.g. from decorators)
- Special function types (e.g. functools.partial)
- Triton kernels and related function types

These classes are responsible for:
- Tracking function calls and their arguments
- Managing function closures and cell variables
- Handling function attributes and special methods
- Maintaining guards for function identity and closure contents
- Supporting function inlining and specialization
- Enabling proper symbolic execution of different function types

The variable trackers here work together with the rest of Dynamo to enable
accurate graph capture while handling Python's various function-related behaviors.
"""

import builtins
import types
from collections.abc import Callable, Sequence
from types import FunctionType
from typing import Any, Never, TypeVar

import torch
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator
from torch._higher_order_ops.triton_kernel_wrap import TritonGridType, TritonHOPifier, TritonKernelType

from .. import variables
from ..source import AttrSource
from .base import VariableTracker
from .constant import ConstantVariable

_F = TypeVar("_F", bound=Callable)
CO_VARARGS = ...
CO_VARKEYWORDS = ...
_spec_cache = ...

class FunctionSpec:
    def __init__(self, func: FunctionType) -> None: ...
    def update_defaults(self, func: FunctionType): ...

def bind_args_cached(func, tx, fn_source, args, kwargs): ...
def wrap_bound_arg(tx: InstructionTranslator, val, source=...): ...
def wrap_args_kwargs(tx: InstructionTranslator, result): ...
def init_cellvars(parent, result: dict[str, VariableTracker], code):
    """
    Update `result` to add mapping from local name to new cells created
    directly by `code`, or update SideEffects in `parent` if the a local cell is
    already in `result` (cell argument).
    """

fn_known_dunder_attrs = ...

def fn_var_getattr(tx, fn, source, name): ...

class BaseUserFunctionVariable(VariableTracker):
    def get_filename(self): ...
    def get_name(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def inspect_parameter_names(self): ...
    def closure_vars(self, tx): ...

class UserFunctionVariable(BaseUserFunctionVariable):
    """Some unsupported user-defined global function"""

    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source): ...
    def __init__(self, fn, is_constant=..., **kwargs) -> None: ...
    def as_python_constant(self): ...
    def self_args(self): ...
    def get_function(self): ...
    def get_code(self): ...
    def python_type(self): ...
    def has_self(self): ...
    def get_globals(self): ...
    def get_source(self): ...
    def bind_args(self, parent, args, kwargs) -> dict[str, VariableTracker]:
        """
        Assume `args` and `kwargs` are VariableTracker arguments for a call to
        this function, create new bindings for initial locals.
        """
    def var_getattr(self, tx: InstructionTranslator, name: str): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class BuiltinMethodVariable(BaseUserFunctionVariable):
    def __init__(self, fn, is_constant=..., **kwargs) -> None: ...
    @staticmethod
    def is_supported_builtin_method(obj): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class LocalGeneratorObjectVariable(VariableTracker):
    def __init__(
        self, code: types.CodeType, f_globals, inline_tracer: InstructionTranslator | None, **kwargs
    ) -> None: ...
    def get_code(self): ...
    def get_filename(self): ...
    def get_name(self): ...
    def get_function(self): ...
    def has_self(self): ...
    def __name__(self): ...

    __repr__ = ...
    def reconstruct(self, codegen: PyCodegen): ...
    def bind_args(self, tx, args, kwargs): ...
    def get_globals(self): ...
    def python_type(self): ...
    def next_variable(self, tx): ...
    def call_obj_hasattr(self, tx, name): ...
    def has_unpack_var_sequence(self, tx): ...
    def has_force_unpack_var_sequence(self, tx) -> builtins.bool: ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def force_apply_to_var_sequence(self, tx, fn) -> None: ...
    def call_method(
        self, tx: InstructionTranslator, name: str, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class ContextlibContextManagerLocalGeneratorObjectVariable(LocalGeneratorObjectVariable):
    """
    .. note::

        This is only used when the function is annotated with @contextlib.contextmanager

        It is a special case of a generator function as we do not allow return a context manager
        from a torch.compile function.
    """

class LocalGeneratorFunctionVariable(BaseUserFunctionVariable):
    """
    functions that behaves like iterators

    .. note::

        This is a wrapper around (Nested)UserFunctionVariable
    """
    def __init__(self, vt: VariableTracker, *, generator_cls=..., **kwargs) -> None: ...
    def __getattr__(self, name): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class FunctionDecoratedByContextlibContextManagerVariable(LocalGeneratorFunctionVariable):
    """
    .. note::

        This is only used when the function is annotated with @contextlib.contextmanager
    """
    def __init__(self, vt, **kwargs) -> None: ...

class UserMethodVariable(UserFunctionVariable):
    """Some unsupported user-defined method"""
    def __init__(self, fn, obj, source_fn=..., **kwargs) -> None: ...
    def self_args(self): ...
    def python_type(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def inspect_parameter_names(self): ...
    def var_getattr(self, tx: InstructionTranslator, name: str): ...

class WrappedUserMethodVariable(UserMethodVariable):
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

class WrappedUserFunctionVariable(UserFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

def invoke_and_store_as_constant(tx: InstructionTranslator, fn, name, args, kwargs): ...

class NestedUserFunctionVariable(BaseUserFunctionVariable):
    _nonvar_fields = ...
    def __init__(
        self, fn_name, code, f_globals, defaults, kwdefaults, annotations, closure, wrapped_fn=..., **kwargs
    ) -> None: ...
    def self_args(self): ...
    def get_code(self): ...
    def python_type(self): ...
    def get_function(self): ...
    def call_setattr(self, tx: InstructionTranslator, name_var: VariableTracker, val: VariableTracker): ...
    def call_method(self, tx, name, args, kwargs): ...
    def has_closure(self): ...
    def const_getattr(self, tx, name): ...
    def has_self(self): ...
    def get_globals(self): ...
    def bind_args(self, parent, args, kwargs): ...
    def reconstruct(self, codegen: PyCodegen): ...

class WrappedNestedUserFunctionVariable(NestedUserFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

class SkipFunctionVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, value, reason=..., **kwargs) -> None: ...
    def as_python_constant(self): ...
    @classmethod
    def create_with_source(cls, value, source): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name): ...
    def var_getattr(self, tx: InstructionTranslator, name: str): ...

class WrappedSkipFunctionVariable(SkipFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen): ...

class WrapperUserFunctionVariable(VariableTracker):
    """
    Used to represent a wrapper object that contains the actual callable as an
    attribute. For example, torch.jit.script/trace have the original function at
    their _torchdynamo_inline attribute. Similarly, functions with
    __script_if_tracing_wrapper have the original attr at "__original_fn".
    """
    def __init__(self, wrapper_obj, attr_to_trace, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def self_args(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class WrapperUserMethodVariable(WrapperUserFunctionVariable):
    """
    Similar to WrapperUserFunctionVariable, but for methods. The only delta is
    saving the vt for `self` object of the method which is then used by
    WrapperUserFunctionVariable in `call_function` method.
    """
    def __init__(self, wrapper_obj, attr_to_trace, self_obj, **kwargs) -> None: ...
    def self_args(self): ...

class CollectiveFunctionRewriteVariable(UserFunctionVariable):
    """
    Some of the torch.distributed.* collective APIs are possible to rewrite to 'traceable' collectives.

    This class provides both a way to check if a function is remappable, and perform the remapping.

    In the case that a function is 'remappable' but only for some combinations of call-time arguments,
    we check the args at `call_function` time and fall back to graph-breaking if needed.  This is no worse
    than status-quo as we currently graph-break on all distributed.* collectives.
    """
    def __init__(self, fn, *, replacement_var, **kwargs) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, old_fn, source, **options): ...
    @staticmethod
    def can_rewrite(variable): ...
    @staticmethod
    def rewrite(tx: InstructionTranslator, fn): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class FunctoolsWrapsVariable(UserFunctionVariable):
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class CollectionsNamedTupleFunction(UserFunctionVariable):
    def as_python_constant(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class FunctoolsPartialVariable(VariableTracker):
    def __init__(self, func: VariableTracker, args, keywords, **kwargs) -> None: ...
    def python_type(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def get_function(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name: str): ...
    def as_python_constant(self): ...
    def guard_as_python_constant(self):
        """Similar to as_python_constant(), but add ID_MATCH guards to try to force things to become constants"""

class PolyfilledFunctionVariable(VariableTracker):
    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source): ...
    def __init__(self, fn: _F, **kwargs) -> None: ...
    @property
    def polyfill_fn(self) -> _F: ...
    def can_constant_fold_through(self): ...
    def get_function(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def as_python_constant(self): ...

class TracebackVariable(VariableTracker):
    def call_function(self, tx, args, kwargs): ...

class SysFunctionVariable(VariableTracker):
    def __init__(self, value, **kwargs) -> None: ...
    def exc_info(self, tx): ...
    def exception(self, tx): ...
    def call_function(self, tx, args, kwargs): ...

class DynamoTritonHOPifier(TritonHOPifier):
    def raise_unsupported(self, msg: str) -> Never: ...
    def is_callable(self, maybe_callable: Any) -> bool: ...
    def get_value(self, val: Any) -> Any: ...
    def check_grid(self, grid) -> tuple[torch.fx.proxy.Proxy, ...]: ...
    def call_grid(self, grid, meta, tx): ...
    def call_user_defined_fn(self, user_fn, args, kwargs, tx, variable): ...
    def wrap_user_defined_obj(self, user_obj, tx, variable, name): ...
    def maybe_unpack_configs(self, configs, tx): ...
    def maybe_unpack_heuristic_result(self, result: Any) -> Any: ...
    def call_getitem(self, variable: TritonKernelVariable, args: Sequence[Any]) -> TritonKernelVariable: ...
    def call_HOP(self, variable, grids, combined_args_raw, tx) -> ConstantVariable: ...

dynamo_triton_hopifier_singleton = ...

class TritonKernelVariable(VariableTracker):
    grid: TritonGridType
    kernel: TritonKernelType
    kernel_idx: int | None
    kernel_source: AttrSource
    def __init__(self, kernel, kernel_idx, grid, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def specialize_symbolic(self, arg: Any) -> Any: ...

class TMADescriptorExperimentalVariable(VariableTracker):
    def __init__(
        self,
        data_ptr: variables.DataPtrVariable,
        dims: list[ConstantVariable],
        block_dims: list[ConstantVariable],
        element_size: ConstantVariable,
        **kwargs,
    ) -> None: ...
    def to_metadata(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def get_tensor(self): ...

class TMADescriptorStableVariable(VariableTracker):
    def __init__(self, tensor: variables.TensorVariable, block_shape: variables.ListVariable, **kwargs) -> None: ...
    def to_metadata(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def get_tensor(self) -> variables.TensorVariable: ...

class CreateTMADescriptorExperimentalVariable(VariableTracker):
    def __init__(self, rank: int, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class CreateTMADescriptorStableVariable(VariableTracker):
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
