import builtins
import types
import torch
from collections.abc import Sequence
from types import FunctionType
from typing import Any, Callable, Optional, TYPE_CHECKING, TypeVar
from typing_extensions import Never
from .. import variables
from ..source import AttrSource
from .base import VariableTracker
from .constant import ConstantVariable
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator
from torch._higher_order_ops.triton_kernel_wrap import TritonGridType, TritonHOPifier, TritonKernelType

"""
Function-related variable tracking classes for Dynamo's symbolic execution.

This module contains classes that track different types of functions during graph
compilation, including:
- User-defined functions and methods
- Built-in functions and methods
- Wrapped functions (e.g. from decorators)
- Special function types (e.g. functools.partial)
- Triton kernels and related function types

These classes are responsible for:
- Tracking function calls and their arguments
- Managing function closures and cell variables
- Handling function attributes and special methods
- Maintaining guards for function identity and closure contents
- Supporting function inlining and specialization
- Enabling proper symbolic execution of different function types

The variable trackers here work together with the rest of Dynamo to enable
accurate graph capture while handling Python's various function-related behaviors.
"""
if TYPE_CHECKING: ...
_F = TypeVar("_F", bound=Callable)
CO_VARARGS = ...
CO_VARKEYWORDS = ...
_spec_cache = ...

class FunctionSpec:
    def __init__(self, func: FunctionType) -> None: ...
    def update_defaults(self, func: FunctionType):  # -> None:
        ...

def bind_args_cached(func, tx, fn_source, args, kwargs):  # -> dict[Any, Any]:
    ...
def wrap_bound_arg(tx: InstructionTranslator, val, source=...):  # -> VariableTracker | Any | LazyVariableTracker:
    ...
def wrap_args_kwargs(tx: InstructionTranslator, result):  # -> None:
    ...
def init_cellvars(parent, result: dict[str, VariableTracker], code):  # -> None:

    ...

fn_known_dunder_attrs = ...

def fn_var_getattr(tx, fn, source, name):  # -> LazyVariableTracker | Any:
    ...

class BaseUserFunctionVariable(VariableTracker):
    def get_filename(self): ...
    def get_name(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def inspect_parameter_names(self):  # -> list[str]:
        ...
    def closure_vars(self, tx):  # -> dict[Any, Any]:
        ...

class UserFunctionVariable(BaseUserFunctionVariable):
    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source):  # -> Self:
        ...
    def __init__(self, fn, is_constant=..., **kwargs) -> None: ...
    def as_python_constant(self):  # -> FunctionType:
        ...
    def self_args(self):  # -> list[Any]:
        ...
    def get_function(self):  # -> FunctionType:
        ...
    def get_code(self):  # -> CodeType:
        ...
    def python_type(self):  # -> type[FunctionType]:
        ...
    def has_self(self):  # -> bool:
        ...
    def get_globals(self):  # -> dict[str, Any]:
        ...
    def get_source(self):  # -> AttrSource | Source | None:
        ...
    def bind_args(self, parent, args, kwargs) -> dict[str, VariableTracker]: ...
    def var_getattr(self, tx: InstructionTranslator, name: str):  # -> GetAttrVariable | LazyVariableTracker | Any:
        ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class BuiltinMethodVariable(BaseUserFunctionVariable):
    def __init__(self, fn, is_constant=..., **kwargs) -> None: ...
    @staticmethod
    def is_supported_builtin_method(obj):  # -> Literal[False]:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class LocalGeneratorObjectVariable(VariableTracker):
    def __init__(
        self, code: types.CodeType, f_globals, inline_tracer: Optional[InstructionTranslator], **kwargs
    ) -> None: ...
    def get_code(self):  # -> CodeType:
        ...
    def get_filename(self):  # -> str:
        ...
    def get_name(self):  # -> str:
        ...
    def get_function(self): ...
    def has_self(self):  # -> Literal[False]:
        ...
    def __name__(self):  # -> str:
        ...

    __repr__ = ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def bind_args(self, tx, args, kwargs): ...
    def get_globals(self): ...
    def python_type(self):  # -> type[GeneratorType[Any, None, None]]:
        ...
    def next_variable(self, tx):  # -> VariableTracker:
        ...
    def call_obj_hasattr(self, tx, name):  # -> VariableTracker:
        ...
    def has_unpack_var_sequence(self, tx):  # -> Literal[False]:
        ...
    def has_force_unpack_var_sequence(self, tx) -> builtins.bool: ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def force_apply_to_var_sequence(self, tx, fn) -> None: ...
    def call_method(
        self, tx: InstructionTranslator, name: str, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class ContextlibContextManagerLocalGeneratorObjectVariable(LocalGeneratorObjectVariable): ...

class LocalGeneratorFunctionVariable(BaseUserFunctionVariable):
    def __init__(self, vt: VariableTracker, *, generator_cls=..., **kwargs) -> None: ...
    def __getattr__(self, name):  # -> Any:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class FunctionDecoratedByContextlibContextManagerVariable(LocalGeneratorFunctionVariable):
    def __init__(self, vt, **kwargs) -> None: ...

class UserMethodVariable(UserFunctionVariable):
    def __init__(self, fn, obj, source_fn=..., **kwargs) -> None: ...
    def self_args(self):  # -> list[Any]:
        ...
    def python_type(self):  # -> type[MethodType]:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def inspect_parameter_names(self):  # -> list[str]:
        ...
    def var_getattr(self, tx: InstructionTranslator, name: str):  # -> Any | GetAttrVariable | LazyVariableTracker:
        ...

class WrappedUserMethodVariable(UserMethodVariable):
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen):  # -> None:
        ...

class WrappedUserFunctionVariable(UserFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen):  # -> None:
        ...

def invoke_and_store_as_constant(tx: InstructionTranslator, fn, name, args, kwargs):  # -> VariableTracker:
    ...

class NestedUserFunctionVariable(BaseUserFunctionVariable):
    _nonvar_fields = ...
    def __init__(
        self, fn_name, code, f_globals, defaults, kwdefaults, annotations, closure, wrapped_fn=..., **kwargs
    ) -> None: ...
    def self_args(self):  # -> list[Any]:
        ...
    def get_code(self): ...
    def python_type(self):  # -> type[FunctionType]:
        ...
    def get_function(self):  # -> FunctionType:
        ...
    def call_setattr(
        self, tx: InstructionTranslator, name_var: VariableTracker, val: VariableTracker
    ):  # -> ConstantVariable:
        ...
    def call_method(self, tx, name, args, kwargs):  # -> ConstantVariable | VariableTracker:
        ...
    def has_closure(self):  # -> bool:
        ...
    def const_getattr(self, tx, name):  # -> Any:
        ...
    def has_self(self):  # -> Literal[False]:
        ...
    def get_globals(self):  # -> dict[Any, Any]:
        ...
    def bind_args(self, parent, args, kwargs):  # -> dict[str, Any]:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...

class WrappedNestedUserFunctionVariable(NestedUserFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen):  # -> None:
        ...

class SkipFunctionVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, value, reason=..., **kwargs) -> None: ...
    def as_python_constant(self):  # -> Any:
        ...
    @classmethod
    def create_with_source(cls, value, source):  # -> Self:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name):  # -> VariableTracker:
        ...
    def var_getattr(self, tx: InstructionTranslator, name: str):  # -> GetAttrVariable | LazyVariableTracker | Any:
        ...

class WrappedSkipFunctionVariable(SkipFunctionVariable):
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen):  # -> None:
        ...

class WrapperUserFunctionVariable(VariableTracker):
    def __init__(self, wrapper_obj, attr_to_trace, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name):  # -> Any | VariableTracker:
        ...
    def self_args(self):  # -> list[Any]:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class WrapperUserMethodVariable(WrapperUserFunctionVariable):
    def __init__(self, wrapper_obj, attr_to_trace, self_obj, **kwargs) -> None: ...
    def self_args(self):  # -> list[Any]:
        ...

class CollectiveFunctionRewriteVariable(UserFunctionVariable):
    def __init__(self, fn, *, replacement_var, **kwargs) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, old_fn, source, **options):  # -> CollectiveFunctionRewriteVariable:
        ...
    @staticmethod
    def can_rewrite(variable):  # -> TypeIs[FunctionType] | bool:
        ...
    @staticmethod
    def rewrite(
        tx: InstructionTranslator, fn
    ):  # -> tuple[Callable[..., Tensor] | Callable[..., list[Tensor]] | Any, AttrSource]:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class FunctoolsWrapsVariable(UserFunctionVariable):
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class CollectionsNamedTupleFunction(UserFunctionVariable):
    def as_python_constant(self):  # -> FunctionType:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class FunctoolsPartialVariable(VariableTracker):
    def __init__(self, func: VariableTracker, args, keywords, **kwargs) -> None: ...
    def python_type(self):  # -> type[partial[Any]]:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def get_function(self):  # -> partial[Any]:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def var_getattr(
        self, tx: InstructionTranslator, name: str
    ):  # -> VariableTracker | ListVariable | ConstDictVariable | GetAttrVariable:
        ...
    def as_python_constant(self):  # -> partial[Any]:
        ...
    def guard_as_python_constant(self):  # -> partial[Any]:

        ...

class PolyfilledFunctionVariable(VariableTracker):
    _nonvar_fields = ...
    @classmethod
    def create_with_source(cls, value, source):  # -> Self:
        ...
    def __init__(self, fn: _F, **kwargs) -> None: ...
    @property
    def polyfill_fn(self) -> _F: ...
    def can_constant_fold_through(self):  # -> Any | bool:
        ...
    def get_function(self):  # -> _F:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def as_python_constant(self):  # -> _F:
        ...

class TracebackVariable(VariableTracker):
    def call_function(self, tx, args, kwargs):  # -> None:
        ...

class SysFunctionVariable(VariableTracker):
    def __init__(self, value, **kwargs) -> None: ...
    def exc_info(self, tx):  # -> TupleVariable:
        ...
    def exception(self, tx):  # -> VariableTracker:
        ...
    def call_function(self, tx, args, kwargs):  # -> TupleVariable | VariableTracker:
        ...

class DynamoTritonHOPifier(TritonHOPifier):
    def raise_unsupported(self, msg: str) -> Never: ...
    def is_callable(self, maybe_callable: Any) -> bool: ...
    def get_value(self, val: Any) -> Any: ...
    def check_grid(self, grid) -> tuple[torch.fx.proxy.Proxy, ...]: ...
    def call_grid(self, grid, meta, tx): ...
    def call_user_defined_fn(self, user_fn, args, kwargs, tx, variable):  # -> VariableTracker:
        ...
    def wrap_user_defined_obj(self, user_obj, tx, variable, name): ...
    def maybe_unpack_configs(self, configs, tx):  # -> list[Any]:
        ...
    def maybe_unpack_heuristic_result(self, result: Any) -> Any: ...
    def call_getitem(self, variable: TritonKernelVariable, args: Sequence[Any]) -> TritonKernelVariable: ...
    def call_HOP(self, variable, grids, combined_args_raw, tx) -> ConstantVariable: ...

dynamo_triton_hopifier_singleton = ...

class TritonKernelVariable(VariableTracker):
    grid: TritonGridType
    kernel: TritonKernelType
    kernel_idx: Optional[int]
    kernel_source: AttrSource
    def __init__(self, kernel, kernel_idx, grid, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def specialize_symbolic(self, arg: Any) -> Any: ...

class TMADescriptorExperimentalVariable(VariableTracker):
    def __init__(
        self,
        data_ptr: variables.DataPtrVariable,
        dims: list[ConstantVariable],
        block_dims: list[ConstantVariable],
        element_size: ConstantVariable,
        **kwargs,
    ) -> None: ...
    def to_metadata(self):  # -> TMAExperimentalMetadata:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def get_tensor(self):  # -> TensorVariable:
        ...

class TMADescriptorStableVariable(VariableTracker):
    def __init__(self, tensor: variables.TensorVariable, block_shape: variables.ListVariable, **kwargs) -> None: ...
    def to_metadata(self):  # -> TMAStableMetadata:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def get_tensor(self) -> variables.TensorVariable: ...

class CreateTMADescriptorExperimentalVariable(VariableTracker):
    def __init__(self, rank: int, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class CreateTMADescriptorStableVariable(VariableTracker):
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
