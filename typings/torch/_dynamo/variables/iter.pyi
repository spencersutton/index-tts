from typing import TYPE_CHECKING, Union
from .base import VariableTracker
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
This module provides iterator-related variable tracking functionality for Dynamo.
It implements variable classes for handling Python iterators and itertools functions
during symbolic execution and tracing.

The module includes:
- Base iterator variable classes for tracking iterator state
- Implementations of built-in iterators (zip, map, filter)
- Support for itertools functions (product, accumulate, combinations, etc.)
- Mutation tracking and reconstruction capabilities for iterator operations

These classes integrate with Dynamo's variable tracking system to enable proper
handling of iterator operations during code transformation and optimization.
"""
if TYPE_CHECKING: ...
MAX_ITERATOR_LIMIT = ...

class ItertoolsVariable(VariableTracker):
    def __init__(self, value, **kwargs) -> None: ...
    def as_python_constant(self):  # -> Any:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class IteratorVariable(VariableTracker):
    def __init__(self, **kwargs) -> None: ...
    def next_variable(self, tx): ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def force_apply_to_var_sequence(self, tx, fn) -> None: ...
    def has_force_unpack_var_sequence(self, tx) -> bool: ...

class ObjectIteratorVariable(IteratorVariable):
    def __init__(self, obj: VariableTracker, **kwargs) -> None: ...
    def next_variable(self, tx): ...

class RepeatIteratorVariable(IteratorVariable):
    def __init__(self, item: VariableTracker, **kwargs) -> None: ...
    def next_variable(self, tx):  # -> VariableTracker:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...

class CountIteratorVariable(IteratorVariable):
    def __init__(self, item: int = ..., step: int = ..., **kwargs) -> None: ...
    def next_variable(self, tx):  # -> int | <subclass of int and VariableTracker> | VariableTracker:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...

class ZipVariable(IteratorVariable):
    _nonvar_fields = ...
    def __init__(self, iterables: list[VariableTracker], strict: bool = ..., **kwargs) -> None: ...
    def python_type(self):  # -> type[zip[Any]]:
        ...
    def has_unpack_var_sequence(self, tx) -> bool: ...
    def unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def next_variable(self, tx):  # -> TupleVariable:
        ...
    def reconstruct_items(self, codegen: PyCodegen):  # -> None:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...

class MapVariable(ZipVariable):
    def __init__(
        self, fn: VariableTracker, iterables: list[Union[list[VariableTracker], VariableTracker]], **kwargs
    ) -> None: ...
    def python_type(self):  # -> type[map[Any]]:
        ...
    def has_unpack_var_sequence(self, tx) -> bool: ...
    def next_variable(self, tx):  # -> VariableTracker:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...

class FilterVariable(IteratorVariable):
    _nonvar_fields = ...
    def __init__(
        self, fn: VariableTracker, iterable: Union[list[VariableTracker], VariableTracker], **kwargs
    ) -> None: ...
    def python_type(self):  # -> type[filter[Any]]:
        ...
    def has_unpack_var_sequence(self, tx) -> bool: ...
    def unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def next_variable(self, tx):  # -> VariableTracker:
        ...
    def reconstruct_items(self, codegen: PyCodegen):  # -> None:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
