from typing import TYPE_CHECKING, Optional

import torch
import torch.fx
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

from .base import VariableTracker
from .iter import IteratorVariable

"""
Variable tracking implementations for list-like data structures in Dynamo.

This module provides specialized variable tracking for various collection types:
- Lists and list subclasses (including torch.nn.ModuleList, ParameterList)
- Tuples and named tuples
- Ranges and slices
- Collections.deque
- torch.Size with special proxy handling

The implementations support both mutable and immutable collections, iteration,
and common sequence operations. Each collection type has a dedicated Variable
class that handles its unique behaviors while integrating with Dynamo's
variable tracking system.
"""
if TYPE_CHECKING: ...

class BaseListVariable(VariableTracker):
    @staticmethod
    def cls_for_instance(
        obj,
    ):  # -> type[ListIteratorVariable] | type[ListVariable] | type[SliceVariable] | type[SizeVariable] | type[TupleVariable] | type[DequeVariable]:
        ...
    @staticmethod
    def cls_for(
        obj,
    ):  # -> type[ListIteratorVariable] | type[ListVariable] | type[SliceVariable] | type[SizeVariable] | type[TupleVariable] | type[DequeVariable]:
        ...
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def modified(self, items, **kwargs):  # -> Self:
        ...
    @property
    def value(self):  # -> Any:
        ...
    def debug_repr_helper(self, prefix, suffix): ...
    def as_python_constant(self):  # -> Any:
        ...
    def as_proxy(self):  # -> Any:
        ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker):  # -> Self | VariableTracker:
        ...
    def unpack_var_sequence(self, tx):  # -> list[VariableTracker]:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class RangeVariable(BaseListVariable):
    def __init__(self, items, **kwargs) -> None: ...
    def debug_repr(self): ...
    def python_type(self):  # -> type[range]:
        ...
    def start(self): ...
    def stop(self): ...
    def step(self): ...
    def range_length(self):  # -> Literal[0]:
        ...
    def apply_index(self, index):  # -> VariableTracker:
        ...
    def apply_slice(self, slice):  # -> RangeVariable:
        ...
    def as_python_constant(self):  # -> range:
        ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker):  # -> RangeVariable | VariableTracker:
        ...
    def as_proxy(self):  # -> range:
        ...
    def unpack_var_sequence(self, tx=...):  # -> list[VariableTracker]:
        ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def range_equals(self, other: RangeVariable):  # -> bool:
        ...
    def range_count(self, x: VariableTracker):  # -> int:
        ...
    def call_method(
        self, tx, name, args, kwargs
    ):  # -> DelayGraphBreakVariable | RangeIteratorVariable | VariableTracker | ConstantVariable | RangeVariable:
        ...
    def var_getattr(self, tx: InstructionTranslator, name):  # -> VariableTracker:
        ...

class CommonListMethodsVariable(BaseListVariable):
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class ListVariable(CommonListMethodsVariable):
    def python_type(self):  # -> type[list[Any]]:
        ...
    def debug_repr(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(self, tx, name):  # -> BuiltinVariable | UserDefinedClassVariable | VariableTracker:
        ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class DequeVariable(CommonListMethodsVariable):
    def __init__(self, items, maxlen=..., **kwargs) -> None: ...
    def python_type(self):  # -> type[deque[Any]]:
        ...
    def debug_repr(self): ...
    def as_python_constant(self):  # -> deque[Any]:
        ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name):  # -> VariableTracker:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class TupleVariable(BaseListVariable):
    def python_type(self):  # -> type[tuple[Any, ...]]:
        ...
    def debug_repr(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(self, tx, name):  # -> BuiltinVariable | UserDefinedClassVariable | VariableTracker:
        ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class SizeVariable(TupleVariable):
    _nonvar_fields = ...
    def __init__(self, items: list[VariableTracker], proxy: torch.fx.Proxy | None = ..., **kwargs) -> None: ...
    def debug_repr(self): ...
    def python_type(self):  # -> type[Size]:
        ...
    def as_proxy(self):  # -> Proxy | Size:
        ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def unpack_var_sequence(self, tx):  # -> list[VariableTracker]:
        ...
    def numel(self, tx):  # -> VariableTracker:
        ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def get_item_dyn(self, tx: InstructionTranslator, arg: VariableTracker):  # -> SizeVariable | VariableTracker:
        ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class NamedTupleVariable(TupleVariable):
    _nonvar_fields = ...
    def __init__(self, items, tuple_cls, dynamic_attributes=..., **kwargs) -> None: ...
    def is_namedtuple(self):  # -> TypeIs[Callable[..., object]] | Literal[False]:
        ...
    def is_structseq(self):  # -> bool:
        ...
    def fields(self):  # -> tuple[str, ...]:
        ...
    def debug_repr(self):  # -> str:
        ...
    def python_type(self):  # -> Any:
        ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(
        self, tx: InstructionTranslator, name
    ):  # -> Any | BuiltinVariable | UserDefinedClassVariable | VariableTracker | UserMethodVariable | UserFunctionVariable:
        ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class SliceVariable(VariableTracker):
    def __init__(self, items, **kwargs) -> None: ...
    def debug_repr(self): ...
    def as_proxy(self):  # -> slice[Any, Any, Any]:
        ...
    def python_type(self):  # -> type[slice[Any, Any, Any]]:
        ...
    def as_python_constant(self):  # -> slice[Any, Any, Any]:
        ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name):  # -> GetAttrVariable | VariableTracker:
        ...

class ListIteratorVariable(IteratorVariable):
    _nonvar_fields = ...
    def __init__(self, items, index: int = ..., **kwargs) -> None: ...
    def next_variable(self, tx): ...
    def call_obj_hasattr(self, tx, name):  # -> VariableTracker:
        ...
    def python_type(self):  # -> type[Iterator[Any]]:
        ...
    def as_python_constant(self):  # -> Iterator[Any]:
        ...
    def has_unpack_var_sequence(self, tx):  # -> Literal[True]:
        ...
    def unpack_var_sequence(self, tx):  # -> list[Any]:
        ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...

class TupleIteratorVariable(ListIteratorVariable): ...

class RangeIteratorVariable(IteratorVariable):
    _nonvar_fields = ...
    def __init__(self, start: int, stop: int, step: int, len_: int, **kwargs) -> None: ...
    def call_method(self, tx, name, args, kwargs):  # -> VariableTracker | Self:
        ...
    def call_obj_hasattr(self, tx, name):  # -> ConstantVariable | VariableTracker:
        ...
    def next_variable(self, tx):  # -> VariableTracker:
        ...
    def python_type(self):  # -> type[Iterator[Any]]:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
