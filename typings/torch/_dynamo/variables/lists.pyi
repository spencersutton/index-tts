"""
Variable tracking implementations for list-like data structures in Dynamo.

This module provides specialized variable tracking for various collection types:
- Lists and list subclasses (including torch.nn.ModuleList, ParameterList)
- Tuples and named tuples
- Ranges and slices
- Collections.deque
- torch.Size with special proxy handling

The implementations support both mutable and immutable collections, iteration,
and common sequence operations. Each collection type has a dedicated Variable
class that handles its unique behaviors while integrating with Dynamo's
variable tracking system.
"""

import torch.fx
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

from .base import VariableTracker
from .iter import IteratorVariable

class BaseListVariable(VariableTracker):
    @staticmethod
    def cls_for_instance(obj): ...
    @staticmethod
    def cls_for(obj): ...
    def __init__(self, items: list[VariableTracker], **kwargs) -> None: ...
    def modified(self, items, **kwargs): ...
    @property
    def value(self): ...
    def debug_repr_helper(self, prefix, suffix): ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def unpack_var_sequence(self, tx): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class RangeVariable(BaseListVariable):
    def __init__(self, items, **kwargs) -> None: ...
    def debug_repr(self): ...
    def python_type(self): ...
    def start(self): ...
    def stop(self): ...
    def step(self): ...
    def range_length(self): ...
    def apply_index(self, index): ...
    def apply_slice(self, slice): ...
    def as_python_constant(self): ...
    def getitem_const(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def as_proxy(self): ...
    def unpack_var_sequence(self, tx=...): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def range_equals(self, other: RangeVariable): ...
    def range_count(self, x: VariableTracker): ...
    def call_method(self, tx, name, args, kwargs): ...
    def var_getattr(self, tx: InstructionTranslator, name): ...

class CommonListMethodsVariable(BaseListVariable):
    """Implement methods common to List and other List-like things"""
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class ListVariable(CommonListMethodsVariable):
    def python_type(self): ...
    def debug_repr(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(self, tx, name): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class DequeVariable(CommonListMethodsVariable):
    def __init__(self, items, maxlen=..., **kwargs) -> None: ...
    def python_type(self): ...
    def debug_repr(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class TupleVariable(BaseListVariable):
    def python_type(self): ...
    def debug_repr(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(self, tx, name): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class SizeVariable(TupleVariable):
    """torch.Size(...)"""

    _nonvar_fields = ...
    def __init__(self, items: list[VariableTracker], proxy: torch.fx.Proxy | None = ..., **kwargs) -> None: ...
    def debug_repr(self): ...
    def python_type(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def unpack_var_sequence(self, tx): ...
    def numel(self, tx): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def get_item_dyn(self, tx: InstructionTranslator, arg: VariableTracker): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class NamedTupleVariable(TupleVariable):
    _nonvar_fields = ...
    def __init__(self, items, tuple_cls, dynamic_attributes=..., **kwargs) -> None: ...
    def is_namedtuple(self): ...
    def is_structseq(self): ...
    def fields(self): ...
    def debug_repr(self): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class SliceVariable(VariableTracker):
    def __init__(self, items, **kwargs) -> None: ...
    def debug_repr(self): ...
    def as_proxy(self): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...

class ListIteratorVariable(IteratorVariable):
    _nonvar_fields = ...
    def __init__(self, items, index: int = ..., **kwargs) -> None: ...
    def next_variable(self, tx): ...
    def call_obj_hasattr(self, tx, name): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def has_unpack_var_sequence(self, tx): ...
    def unpack_var_sequence(self, tx): ...
    def force_unpack_var_sequence(self, tx) -> list[VariableTracker]: ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...

class TupleIteratorVariable(ListIteratorVariable): ...

class RangeIteratorVariable(IteratorVariable):
    _nonvar_fields = ...
    def __init__(self, start: int, stop: int, step: int, len_: int, **kwargs) -> None: ...
    def call_method(self, tx, name, args, kwargs): ...
    def call_obj_hasattr(self, tx, name): ...
    def next_variable(self, tx): ...
    def python_type(self): ...
    def reconstruct(self, codegen: PyCodegen): ...
