import dataclasses
import functools
import random
import types
from typing import Optional, TYPE_CHECKING
from .base import VariableTracker
from .user_defined import UserDefinedObjectVariable
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
This module contains miscellaneous variable tracker implementations for various Python types
and features used in Dynamo's symbolic execution. These classes help track and propagate
information about different kinds of variables during graph capture.

Key classes include:
- SuperVariable: Handles super() calls and method resolution
- ExceptionVariable: Tracks exception objects
- RandomVariable: Manages random number generators
- GetAttrVariable: Tracks attribute access
- MethodWrapperVariable: Handles method wrappers
- PythonModuleVariable: Tracks Python modules
- NumpyVariable: Handles numpy functions and types
- StringFormatVariable: Manages string formatting
- DebuggingVariable: Handles print and logging
"""
if TYPE_CHECKING: ...

class NO_SUCH_SUBOBJ: ...

class SuperVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, typevar, objvar=..., **kwargs) -> None: ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class ExceptionVariable(VariableTracker):
    def __init__(self, exc_type, args, **kwargs) -> None: ...
    def set_context(self, context: ExceptionVariable):  # -> None:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def python_type(self):  # -> Any:
        ...
    def call_setattr(
        self, tx: InstructionTranslator, name_var: VariableTracker, val: VariableTracker
    ):  # -> ConstantVariable:
        ...
    def call_method(self, tx, name, args, kwargs):  # -> ConstantVariable | Self | VariableTracker:
        ...
    def var_getattr(
        self, tx, name
    ):  # -> ConstantVariable | ExceptionVariable | BuiltinVariable | UserDefinedExceptionClassVariable | UserDefinedExceptionObjectVariable | ListVariable | VariableTracker:
        ...

    __repr__ = ...

class UnknownVariable(VariableTracker): ...

class DelayGraphBreakVariable(UnknownVariable):
    def __init__(self, msg=..., **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class ComptimeVariable(VariableTracker):
    def reconstruct(self, codegen: PyCodegen): ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class CellVariable(VariableTracker):
    pre_existing_contents: Optional[VariableTracker]
    local_name: Optional[str] = ...
    def __init__(self, pre_existing_contents: Optional[VariableTracker] = ..., **kwargs) -> None: ...

class NewGlobalVariable(VariableTracker):
    def __init__(self, **kwargs) -> None: ...

def produce_trampoline_autograd_apply(fn_cls):  # -> Callable[..., Any]:
    ...

class AutogradFunctionVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, fn_cls, **kwargs) -> None: ...
    def call_apply(self, tx: InstructionTranslator, args, kwargs):  # -> VariableTracker:
        ...
    def call_backward(self, tx: InstructionTranslator, args, kwargs):  # -> VariableTracker:
        ...
    def call_function(self, tx: InstructionTranslator, args, kwargs):  # -> AutogradFunctionVariable:
        ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ):  # -> VariableTracker:
        ...

@dataclasses.dataclass
class SavedTensorBox:
    tensors: list[VariableTracker] = ...

class AutogradFunctionContextVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(
        self,
        value,
        value_type=...,
        inference=...,
        saved_tensors=...,
        needs_input_grad=...,
        non_differentiable=...,
        **kwargs,
    ) -> None: ...
    @staticmethod
    def create(tx: InstructionTranslator, args=..., kwargs=...):  # -> VariableTracker:
        ...
    def as_proxy(self): ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(
        self, tx: InstructionTranslator, name
    ):  # -> LambdaVariable | TupleVariable | VariableTracker | Any | GetAttrVariable | UserDefinedClassVariable | UnspecializedNNModuleVariable | NNModuleVariable | UserMethodVariable | WrapperUserMethodVariable | LazyVariableTracker:
        ...

class AutogradEngineVariable(UserDefinedObjectVariable):
    def __init__(self, value, value_type=..., **kwargs) -> None: ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class LambdaVariable(VariableTracker):
    def __init__(self, fn, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class GetAttrVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, obj, name, py_type=..., **kwargs) -> None: ...
    def python_type(self):  # -> type[Any]:
        ...
    @staticmethod
    def create_getattr_proxy(base_proxy: torch.fx.Proxy, attr):  # -> Any:
        ...
    def as_proxy(self):  # -> Any:
        ...
    def as_python_constant(self):  # -> Any:
        ...
    def const_getattr(self, tx: InstructionTranslator, name):  # -> Any:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def get_forwarded_dict(self, tx):  # -> Any:
        ...

class MethodWrapperVariable(VariableTracker):
    def __init__(self, method_wrapper, **kwargs) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def is_python_constant(self):  # -> Literal[True]:
        ...
    def as_python_constant(self):  # -> Any:
        ...

class GetSetDescriptorVariable(VariableTracker):
    def __init__(self, desc, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name):  # -> Any | VariableTracker:
        ...
    def is_python_constant(self):  # -> Literal[True]:
        ...
    def as_python_constant(self):  # -> Any:
        ...

class PythonModuleVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, value: types.ModuleType, **kwargs) -> None: ...
    def python_type(self):  # -> type[ModuleType]:
        ...
    def as_python_constant(self):  # -> ModuleType:
        ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name):  # -> VariableTracker:
        ...
    def var_getattr(self, tx: InstructionTranslator, name):  # -> VariableTracker | Any:
        ...

class TypingVariable(VariableTracker):
    def __init__(self, value, **kwargs) -> None: ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name: str):  # -> GetAttrVariable | VariableTracker:
        ...
    def as_python_constant(self):  # -> Any:
        ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...

@functools.lru_cache(maxsize=1)
def get_np_to_tnp_map():  # -> dict[Any, Any]:

    ...
@functools.lru_cache(maxsize=1)
def get_tnp_to_np_map():  # -> dict[Any, Any]:

    ...

class NumpyVariable(VariableTracker):
    constant_fold_functions = ...
    def __init__(self, value, **kwargs) -> None: ...
    @classmethod
    def can_constant_fold_through(cls, fn):  # -> bool:
        ...
    @classmethod
    def get_constant_collection_for_func(cls, fn):  # -> type[NumpyTypeInfoVariable] | type[NumpyDTypeVariable] | None:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def as_python_constant(self):  # -> Any:
        ...
    def as_proxy(self):  # -> str:
        ...

class NullVariable(VariableTracker):
    def __init__(self, **kwargs) -> None: ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...

class DeletedVariable(VariableTracker): ...

class StringFormatVariable(VariableTracker):
    _nonvar_fields = ...
    @classmethod
    def create(cls, format_string, sym_args, sym_kwargs):  # -> VariableTracker | Self:
        ...
    def __init__(self, format_string, sym_args, sym_kwargs, **kwargs) -> None: ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...

class DebuggingVariable(VariableTracker):
    def __init__(self, value, **kwargs) -> None: ...
    @staticmethod
    def is_reorderable_logging_function(obj):  # -> TypeIs[Callable[..., object]] | bool:
        ...
    def call_function(self, tx: InstructionTranslator, args, kwargs):  # -> None:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    @staticmethod
    def can_reorder_logs(fn, args, kwargs) -> True: ...

class LoggingLoggerVariable(VariableTracker):
    def __init__(self, value, **kwargs) -> None: ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class ConstantLikeVariable(VariableTracker):
    _error_prefix = ...
    def __init__(self, value, **kwargs) -> None: ...
    def as_python_constant(self):  # -> Any:
        ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class RegexPatternVariable(ConstantLikeVariable):
    _error_prefix = ...

class ConstantRegexMatchVariable(ConstantLikeVariable):
    _error_prefix = ...

class TorchVersionVariable(ConstantLikeVariable):
    _error_prefix = ...
    def __init__(self, **kwargs) -> None: ...

class NumpyTypeInfoVariable(ConstantLikeVariable):
    _error_prefix = ...

class NumpyDTypeVariable(ConstantLikeVariable):
    _error_prefix = ...
    def as_proxy(self): ...

np_constant_collections_map = ...

class RandomClassVariable(VariableTracker):
    def __init__(self, **kwargs) -> None: ...
    def call_function(self, tx: InstructionTranslator, args, kwargs):  # -> RandomVariable:
        ...

class RandomVariable(VariableTracker):
    _nonvar_fields = ...
    _supported_fn_names = ...
    def __init__(
        self, rand: Optional[random.Random] = ..., seed: Optional[VariableTracker] = ..., **kwargs
    ) -> None: ...
    def python_type(self):  # -> type[Random]:
        ...
    def as_python_constant(self):  # -> Random:
        ...
    @staticmethod
    def is_supported_random_obj(val):  # -> bool:
        ...
    @staticmethod
    def check_state(state):  # -> None:
        ...
    @staticmethod
    def wrap_state(state):  # -> TupleVariable:
        ...
    @staticmethod
    def unwrap_state(state): ...
    def call_method(
        self, tx: InstructionTranslator, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...

class WeakRefVariable(VariableTracker):
    @staticmethod
    def build(tx, weakref_value, **options):  # -> WeakRefVariable:
        ...
    def __init__(self, referent_vt, callback_vt, **options) -> None: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
