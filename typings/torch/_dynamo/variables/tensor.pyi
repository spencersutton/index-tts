import torch.fx
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

from .base import VariableTracker
from .user_defined import UserDefinedClassVariable

log = ...
supported_tensor_comparison_ops = ...
supported_const_comparison_ops = ...
supported_comparison_ops = ...
supported_tensor_comparison_op_values = ...
supported_const_comparison_op_values = ...

def is_bound_tensor_method(value): ...

all_tensor_attrs = ...

class TensorVariable(VariableTracker):
    _nonvar_fields = ...
    def get_real_value(self): ...
    def __init__(
        self,
        proxy: torch.fx.Proxy,
        *,
        dtype,
        device,
        layout,
        ndim,
        requires_grad,
        is_nested,
        is_quantized,
        is_sparse,
        class_type,
        has_grad_fn,
        _size=...,
        stride=...,
        is_contiguous=...,
        _is_name_set=...,
        **kwargs,
    ) -> None: ...
    def debug_repr(self): ...
    def as_proxy(self): ...
    def python_type(self): ...
    @staticmethod
    def specialize(value: torch.Tensor): ...
    def dynamic_getattr(self, tx: InstructionTranslator, name): ...
    def method_attr_ndim(self, tx): ...
    def method_attr_dtype(self, tx): ...
    def method_attr_device(self, tx): ...
    def method_attr_layout(self, tx): ...
    def method_attr_is_cuda(self, tx): ...
    def method_attr_shape(self, tx): ...
    def method_attr_requires_grad(self, tx): ...
    def method_attr_is_quantized(self, tx): ...
    def method_attr_is_sparse(self, tx): ...
    def method_attr_is_nested(self, tx): ...
    def method_attr_retain_grad(self, tx): ...
    def method_attr_data(self, tx): ...
    def method_attr_grad_fn(self, tx): ...
    def method_attr__version(self, tx): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name): ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def call_id(self, tx): ...
    def has_unpack_var_sequence(self, tx): ...
    def unpack_var_sequence(self, tx: InstructionTranslator, idxes=...): ...
    def valid_size(self): ...
    @property
    def size(self): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def method_size(self, *args, **kwargs): ...
    def method_stride(self, *args, **kwargs): ...
    def method_numel(self): ...

    method_nelement = ...
    def method_dim(self): ...

    method_ndimension = ...
    def method_is_floating_point(self): ...
    def method_is_inference(self): ...
    def method_is_complex(self): ...
    def method_is_contiguous(self, memory_format=...): ...
    def method_type(self, dtype=..., non_blocking=..., **kwargs): ...
    def method_as_subclass(self, cls): ...
    def method_get_device(self): ...
    def method_element_size(self): ...
    def method_numpy(self, *, force=...): ...
    def method_tolist(self): ...
    def method_backward(self, *args, **kwargs): ...
    def method_data_ptr(self, *args, **kwargs): ...
    def method_item(self, *args, **kwargs): ...
    def method___getitem__(self, *args, **kwargs): ...
    def method___len__(self): ...
    def method_addcmul_(self, tensor1, tensor2, *, value=...): ...
    def method___setitem__(self, key, value): ...
    def method_resize_(self, *args, **kwargs): ...
    def method_resize_as_(self, *args, **kwargs): ...
    def method_sparse_resize_(self, *args, **kwargs): ...
    def method_sparse_resize_and_clear_(self, *args, **kwargs): ...
    def method_set_(self, *args, **kwargs): ...
    def method_add_(self, other, *, alpha=...): ...
    def method_addcdiv_(self, tensor1, tensor2, *, value=...): ...
    def method___contains__(self, arg): ...
    def method_redistribute(self, *args, **kwargs): ...
    def method_to_local(self, *args, **kwargs): ...
    def method_register_hook(self, *args, **kwargs): ...
    def method_register_post_accumulate_grad_hook(self, *args, **kwargs): ...
    def method_requires_grad_(self, requires_grad=...): ...
    def method_new(self, *args, **kwargs): ...
    def method_untyped_storage(self): ...
    def set_name_hint(self, name: str): ...

class SymNodeVariable(VariableTracker):
    _nonvar_fields = ...
    def debug_repr(self): ...
    @classmethod
    def create(cls, tx, proxy, sym_num=..., **options): ...
    def __init__(self, proxy, sym_num, **kwargs) -> None: ...
    def python_type(self): ...
    def as_proxy(self): ...
    def as_tensor(self, tx, dtype): ...
    def evaluate_expr(self, output_graph=...): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class NumpyNdarrayVariable(TensorVariable):
    @staticmethod
    def create(tx: InstructionTranslator, proxy, **options): ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    @staticmethod
    def patch_args(name, args, kwargs): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def python_type(self): ...

class UnspecializedPythonVariable(TensorVariable):
    _nonvar_fields = ...
    def __init__(self, proxy: torch.fx.Proxy, *, raw_value=..., need_unwrap=..., **kwargs) -> None: ...
    @classmethod
    def from_tensor_variable(cls, tensor_variable, raw_value, need_unwrap=...): ...

class FakeItemVariable(TensorVariable):
    _nonvar_fields = ...
    def __init__(self, proxy: torch.fx.Proxy, **kwargs) -> None: ...
    @classmethod
    def from_tensor_variable(cls, tensor_variable): ...

class TensorSubclassVariable(UserDefinedClassVariable):
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def as_python_constant(self): ...

class UntypedStorageVariable(VariableTracker):
    _nonvar_fields = ...
    def __init__(self, from_tensor: TensorVariable, example_value: torch.UntypedStorage, **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def reconstruct(self, codegen: PyCodegen): ...

class DataPtrVariable(VariableTracker):
    def __init__(self, from_tensor: TensorVariable, **kwargs) -> None: ...
    def reconstruct(self, codegen: PyCodegen): ...
