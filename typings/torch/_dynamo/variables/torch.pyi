import functools
from collections.abc import Callable, Sequence
from typing import Any

from torch._dynamo.symbolic_convert import InstructionTranslator

from ..codegen import PyCodegen
from .base import VariableTracker

log = ...
supported_ctx_manager_classes = ...
REWRITE_OPS_TO_TENSOR_SIZE_METHOD = ...
constant_fold_functions_need_guards = ...
constant_fold_functions = ...
if torch.distributed.is_available(): ...
constant_fold_functions_need_guards = ...
constant_fold_functions = ...

@functools.cache
def tracing_state_functions() -> dict[Callable[[], Any], bool | None]: ...

bin_ops = ...
dispatch_key_set_functions = ...

@functools.cache
def get_overridable_functions(): ...

class BaseTorchVariable(VariableTracker):
    @classmethod
    def create_with_source(cls, value, source): ...
    def __init__(self, value, **kwargs) -> None: ...
    def reconstruct(self, codegen: PyCodegen): ...
    def as_proxy(self): ...
    def as_python_constant(self): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name): ...
    def can_constant_fold_through(self): ...

class TorchCtxManagerClassVariable(BaseTorchVariable):
    @staticmethod
    def is_matching_cls(value): ...
    def call_function(
        self, tx: InstructionTranslator, args: Sequence[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class TorchInGraphFunctionVariable(BaseTorchVariable):
    def __init__(self, value, nonstrict_traceable=..., **kwargs) -> None: ...
    def get_function(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: Sequence[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    @classmethod
    def call_nn_parameter(cls, tx, data=..., requires_grad=...): ...
    def call_tensor_method(self, tx, args, kwargs): ...
    def is_tensor_method(self): ...
    def torch_function_override_enabled(self, tx, args, kwargs): ...

class DispatchKeySetVariable(BaseTorchVariable):
    @staticmethod
    def create(value, **kwargs): ...
    @classmethod
    def create_with_source(cls, value, source): ...
    def is_constant_fold_method(self, name): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class FuncTorchInterpreterVariable(BaseTorchVariable):
    @classmethod
    def create_with_source(cls, value, source): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
