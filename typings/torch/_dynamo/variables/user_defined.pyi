import functools
from typing import TYPE_CHECKING
from .. import variables
from .base import VariableTracker
from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

"""
This module contains variable classes for handling user-defined objects in Dynamo's tracing system.

The key classes are:
- UserDefinedVariable: Base class for representing custom Python objects
- UserDefinedClassVariable: Handles Python class objects/types
- UserDefinedObjectVariable: Fallback class for instance objects, with support for method calls,
  attribute access, and other Python object behaviors.
- Specialized subclasses for common patterns:
  - UserDefinedDictVariable: For dict subclasses
  - UserDefinedSetVariable: For set subclasses
  - UserDefinedTupleVariable: For tuple subclasses
  - UserDefinedExceptionObjectVariable: For exception subclasses
  - FrozenDataClassVariable: Special handling of frozen dataclasses
  - MutableMappingVariable: For collections.abc.MutableMapping subclasses

Dynamo specializes to VariableTracker subclasses like FrozenDataClassVariable if available; if no
subclass qualifies, it falls back to UserDefinedObjectVariable.

These classes help Dynamo track and handle arbitrary Python objects during tracing,
maintaining proper semantics while enabling optimizations where possible.
"""
if TYPE_CHECKING: ...

def is_standard_setattr(val):  # -> bool:
    ...
def is_standard_delattr(val):  # -> bool:
    ...
def is_forbidden_context_manager(ctx):  # -> bool:
    ...
def is_cython_function(obj):  # -> TypeIs[Callable[..., object]] | bool:
    ...

class UserDefinedVariable(VariableTracker):
    value: object

class UserDefinedClassVariable(UserDefinedVariable):
    value: type[object]
    def __init__(self, value, **kwargs) -> None: ...
    def as_python_constant(self):  # -> type[object]:
        ...
    def as_proxy(self):  # -> type[object]:
        ...
    @staticmethod
    @functools.cache
    def supported_c_new_functions():  # -> set[Callable[..., Self] | Callable[..., Any] | Callable[[type[Self], Iterable[Any]], Self] | Any]:
        ...
    @staticmethod
    def is_supported_new_method(value):  # -> bool:
        ...
    def can_constant_fold_through(self):  # -> bool:
        ...
    def has_key_in_generic_dict(self, tx: InstructionTranslator, key):  # -> bool:
        ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def is_standard_new(self):  # -> bool:

        ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def const_getattr(self, tx: InstructionTranslator, name):  # -> str | Any:
        ...

class UserDefinedExceptionClassVariable(UserDefinedClassVariable):
    @property
    def fn(self):  # -> type[object]:
        ...
    def python_type(self):  # -> type[object]:
        ...

class NO_SUCH_SUBOBJ: ...

def call_random_fn(tx, fn, args, kwargs):  # -> ConstantVariable:
    ...

class UserDefinedObjectVariable(UserDefinedVariable):
    _nonvar_fields = ...
    def __init__(self, value, *, value_type=..., cls_source=..., base_cls_vt=..., init_args=..., **kwargs) -> None: ...
    def is_underlying_vt_modified(self, side_effects):  # -> Literal[False]:
        ...
    def python_type(self):  # -> Any:
        ...
    def as_python_constant(self):  # -> object:
        ...
    def guard_as_python_constant(self):  # -> object:
        ...
    def torch_function_check(self):  # -> None:
        ...
    def get_torch_fn(self, tx):  # -> VariableTracker:
        ...
    def call_torch_function(self, tx: InstructionTranslator, fn, types, args, kwargs): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def method_setattr_standard(
        self, tx: InstructionTranslator, name, value, directly_update_dict=...
    ):  # -> Any | ConstantVariable:
        ...
    def needs_slow_setattr(self):  # -> bool:
        ...
    def unpack_var_sequence(self, tx):  # -> list[LazyVariableTracker] | list[VariableTracker]:
        ...
    def has_force_unpack_var_sequence(self, tx: InstructionTranslator) -> bool: ...
    def force_unpack_var_sequence(self, tx):  # -> list[Any]:
        ...
    def next_variable(self, tx):  # -> VariableTracker:
        ...
    def is_supported_random(self):  # -> bool:
        ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def should_skip_descriptor_setter(self, attr_name):  # -> bool:
        ...
    def try_get_descritor_and_setter_py_func(self, attr_name):  # -> tuple[Any, FunctionType] | None:
        ...
    def has_key_in_generic_dict(self, tx: InstructionTranslator, key):  # -> bool:
        ...
    def get_source_by_walking_mro(self, name):  # -> DictGetItemSource:
        ...
    def var_getattr(
        self, tx: InstructionTranslator, name
    ):  # -> VariableTracker | GetAttrVariable | UserDefinedClassVariable | UnspecializedNNModuleVariable | NNModuleVariable | Any | UserMethodVariable | WrapperUserMethodVariable | LazyVariableTracker:
        ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class FrozenDataClassVariable(UserDefinedObjectVariable):
    class HashWrapper:
        def __init__(self, c, fields) -> None: ...
        def __eq__(self, other) -> bool: ...
        def __hash__(self) -> int: ...

    @staticmethod
    def create(tx, value, source):  # -> FrozenDataClassVariable:
        ...
    def __init__(self, value, fields=..., **kwargs) -> None: ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def method_setattr_standard(self, tx: InstructionTranslator, name, value):  # -> Any | ConstantVariable:
        ...

class SourcelessGraphModuleVariable(UserDefinedObjectVariable):
    def __init__(self, value, **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class UserDefinedExceptionObjectVariable(UserDefinedObjectVariable):
    def __init__(self, value, **kwargs) -> None: ...
    @property
    def fn(self):  # -> Any:
        ...
    def call_method(self, tx, name, args, kwargs):  # -> ConstantVariable | ExceptionVariable | VariableTracker:
        ...
    @property
    def __context__(self):  # -> ConstantVariable | ExceptionVariable:
        ...
    @property
    def args(self):  # -> tuple[()]:
        ...
    def set_context(self, context: variables.ExceptionVariable):  # -> None:
        ...
    @property
    def exc_type(self):  # -> Any:
        ...

class KeyedJaggedTensorVariable(UserDefinedObjectVariable):
    @staticmethod
    def is_matching_object(obj):  # -> bool:
        ...
    def __init__(self, value, **kwargs) -> None: ...
    def var_getattr(
        self, tx: InstructionTranslator, name
    ):  # -> VariableTracker | GetAttrVariable | UserDefinedClassVariable | UnspecializedNNModuleVariable | NNModuleVariable | Any | UserMethodVariable | WrapperUserMethodVariable | LazyVariableTracker:
        ...

class IntWrapperVariable(UserDefinedObjectVariable):
    @staticmethod
    def is_matching_object(obj):  # -> bool:
        ...

class RemovableHandleClass: ...

class RemovableHandleVariable(VariableTracker):
    REMOVED = ...
    def __init__(self, mutation_type=..., idx=..., **kwargs) -> None: ...
    def call_method(self, tx: InstructionTranslator, method_name, args, kwargs):  # -> VariableTracker | None:
        ...
    def reconstruct(self, codegen: PyCodegen):  # -> None:
        ...
    def python_type(self):  # -> type[RemovableHandleClass]:
        ...

class UserDefinedDictVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, dict_vt=..., **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def unpack_var_sequence(self, tx):  # -> list[Any]:
        ...
    def is_underlying_vt_modified(self, side_effects): ...
    @property
    def user_cls(self):  # -> type[dict[Any, Any]]:
        ...
    @property
    def items(self):  # -> OrderedDict[Any, Any] | defaultdict[str, Any] | dict[_HashableTracker, VariableTracker]:
        ...
    def install_dict_keys_match_guard(self):  # -> None:
        ...
    def install_dict_contains_guard(self): ...

class UserDefinedSetVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, set_vt=..., **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def as_python_constant(self):  # -> set[Any]:
        ...
    def unpack_var_sequence(self, tx):  # -> list[Any] | list[VariableTracker]:
        ...
    @property
    def set_items(self):  # -> set[str | _HashableTracker]:
        ...
    @property
    def items(self):  # -> OrderedDict[Any, Any] | defaultdict[str, Any] | dict[_HashableTracker, VariableTracker]:
        ...
    def is_underlying_vt_modified(self, side_effects): ...
    def install_dict_keys_match_guard(self):  # -> None:
        ...
    def install_dict_contains_guard(self): ...

class UserDefinedListVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, list_vt=..., **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def unpack_var_sequence(self, tx):  # -> list[VariableTracker]:
        ...
    def is_underlying_vt_modified(self, side_effects): ...

class UserDefinedTupleVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, tuple_vt=..., init_args=..., **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def unpack_var_sequence(self, tx):  # -> list[VariableTracker]:
        ...

class MutableMappingVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class RandomVariable(UserDefinedObjectVariable): ...
