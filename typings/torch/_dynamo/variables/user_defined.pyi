import functools

from torch._dynamo.codegen import PyCodegen
from torch._dynamo.symbolic_convert import InstructionTranslator

from .. import variables
from .base import VariableTracker

def is_standard_setattr(val): ...
def is_standard_delattr(val): ...
def is_forbidden_context_manager(ctx): ...
def is_cython_function(obj): ...

class UserDefinedVariable(VariableTracker):
    value: object

class UserDefinedClassVariable(UserDefinedVariable):
    value: type[object]
    def __init__(self, value, **kwargs) -> None: ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    @staticmethod
    @functools.cache
    def supported_c_new_functions(): ...
    @staticmethod
    def is_supported_new_method(value): ...
    def can_constant_fold_through(self): ...
    def has_key_in_generic_dict(self, tx: InstructionTranslator, key): ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def is_standard_new(self): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...
    def const_getattr(self, tx: InstructionTranslator, name): ...

class UserDefinedExceptionClassVariable(UserDefinedClassVariable):
    @property
    def fn(self): ...
    def python_type(self): ...

class NO_SUCH_SUBOBJ: ...

def call_random_fn(tx, fn, args, kwargs): ...

class UserDefinedObjectVariable(UserDefinedVariable):
    _nonvar_fields = ...
    def __init__(self, value, *, value_type=..., cls_source=..., base_cls_vt=..., init_args=..., **kwargs) -> None: ...
    def is_underlying_vt_modified(self, side_effects): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def guard_as_python_constant(self): ...
    def torch_function_check(self): ...
    def get_torch_fn(self, tx): ...
    def call_torch_function(self, tx: InstructionTranslator, fn, types, args, kwargs): ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def method_setattr_standard(self, tx: InstructionTranslator, name, value, directly_update_dict=...): ...
    def needs_slow_setattr(self): ...
    def unpack_var_sequence(self, tx): ...
    def has_force_unpack_var_sequence(self, tx: InstructionTranslator) -> bool: ...
    def force_unpack_var_sequence(self, tx): ...
    def next_variable(self, tx): ...
    def is_supported_random(self): ...
    def call_function(
        self, tx: InstructionTranslator, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def should_skip_descriptor_setter(self, attr_name): ...
    def try_get_descritor_and_setter_py_func(self, attr_name): ...
    def has_key_in_generic_dict(self, tx: InstructionTranslator, key): ...
    def get_source_by_walking_mro(self, name): ...
    def var_getattr(self, tx: InstructionTranslator, name): ...
    def call_obj_hasattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class FrozenDataClassVariable(UserDefinedObjectVariable):
    class HashWrapper:
        def __init__(self, c, fields) -> None: ...
        def __eq__(self, other) -> bool: ...
        def __hash__(self) -> int: ...

    @staticmethod
    def create(tx, value, source): ...
    def __init__(self, value, fields=..., **kwargs) -> None: ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen: PyCodegen) -> None: ...
    def method_setattr_standard(self, tx: InstructionTranslator, name, value): ...

class SourcelessGraphModuleVariable(UserDefinedObjectVariable):
    def __init__(self, value, **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...

class UserDefinedExceptionObjectVariable(UserDefinedObjectVariable):
    def __init__(self, value, **kwargs) -> None: ...
    @property
    def fn(self): ...
    def call_method(self, tx, name, args, kwargs): ...
    @property
    def __context__(self): ...
    @property
    def args(self): ...
    def set_context(self, context: variables.ExceptionVariable): ...
    @property
    def exc_type(self): ...

class KeyedJaggedTensorVariable(UserDefinedObjectVariable):
    @staticmethod
    def is_matching_object(obj): ...
    def __init__(self, value, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name): ...

class IntWrapperVariable(UserDefinedObjectVariable):
    @staticmethod
    def is_matching_object(obj): ...

class RemovableHandleClass: ...

class RemovableHandleVariable(VariableTracker):
    REMOVED = ...
    def __init__(self, mutation_type=..., idx=..., **kwargs) -> None: ...
    def call_method(self, tx: InstructionTranslator, method_name, args, kwargs): ...
    def reconstruct(self, codegen: PyCodegen): ...
    def python_type(self): ...

class UserDefinedDictVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, dict_vt=..., **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def unpack_var_sequence(self, tx): ...
    def is_underlying_vt_modified(self, side_effects): ...
    @property
    def user_cls(self): ...
    @property
    def items(self): ...
    def install_dict_keys_match_guard(self): ...
    def install_dict_contains_guard(self): ...

class UserDefinedSetVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, set_vt=..., **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def as_python_constant(self): ...
    def unpack_var_sequence(self, tx): ...
    @property
    def set_items(self): ...
    @property
    def items(self): ...
    def is_underlying_vt_modified(self, side_effects): ...
    def install_dict_keys_match_guard(self): ...
    def install_dict_contains_guard(self): ...

class UserDefinedListVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, list_vt=..., **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def unpack_var_sequence(self, tx): ...
    def is_underlying_vt_modified(self, side_effects): ...

class UserDefinedTupleVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, tuple_vt=..., init_args=..., **kwargs) -> None: ...
    def call_method(
        self, tx, name, args: list[VariableTracker], kwargs: dict[str, VariableTracker]
    ) -> VariableTracker: ...
    def unpack_var_sequence(self, tx): ...

class MutableMappingVariable(UserDefinedObjectVariable):
    _nonvar_fields = ...
    def __init__(self, value, **kwargs) -> None: ...
    def var_getattr(self, tx: InstructionTranslator, name: str) -> VariableTracker: ...

class RandomVariable(UserDefinedObjectVariable): ...
