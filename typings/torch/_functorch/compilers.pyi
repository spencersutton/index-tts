from collections.abc import Callable
from typing import Union

import torch.fx as fx
import torch.nn as nn

from .aot_autograd import make_boxed_compiler

log = ...

@make_boxed_compiler
def ts_compile(fx_g: fx.GraphModule, inps) -> Callable: ...
def draw_graph_compile(name):  # -> _Wrapped[..., Any, ..., Callable[..., Any]]:
    ...
@make_boxed_compiler
def nop(fx_g: fx.GraphModule, _) -> Callable: ...

class DebugInterpreter(fx.Interpreter):
    def run(self, *args):  # -> None:
        ...
    def run_node(self, n):  # -> Any:
        ...

@make_boxed_compiler
def debug_nop(fx_g: fx.GraphModule, _) -> Callable: ...
@make_boxed_compiler
def simple_ts_compile(fx_g, _):  # -> RecursiveScriptModule:
    ...
def nnc_jit(f):  # -> Callable[..., Any]:
    ...

aten = ...
default_decompositions = ...
default_decompositions = ...

@make_boxed_compiler
def print_compile(fx_g, _): ...
def memory_efficient_fusion(fn: Callable | nn.Module, **kwargs):  # -> Module | Callable[..., Any]:

    ...
def debug_compile(fx_g, inps):  # -> Callable[..., Any]:
    ...

graph_index = ...

def get_inputs(input_data_path):  # -> list[Any]:

    ...
def graph_dumper_aot(current_name, folder_name, dump_example_input=...):  # -> partial[Any]:

    ...
