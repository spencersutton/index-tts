import dataclasses
from typing import TYPE_CHECKING, Any

import sympy
import torch
from torch._inductor.index_propagation import SymPyOps, TypedExpr
from torch._inductor.scheduler import SchedulerNode

from .ops_handler import DefaultHandler
from .virtualized import StoreMode

if TYPE_CHECKING: ...

def construct_symbol(count: int, dtype: torch.dtype) -> sympy.Symbol: ...

class PreservesZeros(SymPyOps, DefaultHandler):
    def __init__(self) -> None: ...
    def load(self, name: str, index: sympy.Expr) -> TypedExpr: ...
    def store(self, name: str, index: sympy.Expr, value: TypedExpr, mode: StoreMode = ...) -> None: ...
    def indirect_indexing(self, *args: Any, **kwargs: Any) -> sympy.Expr: ...

def prologue_preserves_zero_mask(prologue: SchedulerNode) -> bool: ...

@dataclasses.dataclass
class DTypeContainer:
    dtype: torch.dtype
    is_scalar: bool = ...

class RecordLowPrecisionOps(DefaultHandler):
    def __init__(self, disallow_fp32_ops: bool = ...) -> None: ...
    def load(self, name: str, index: sympy.Expr) -> DTypeContainer: ...
    @staticmethod
    def store(name: str, index: sympy.Expr, value: TypedExpr, mode: StoreMode = ...) -> None: ...
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool) -> None: ...
    @staticmethod
    def indirect_indexing(*args: Any, **kwargs: Any) -> sympy.Expr: ...

def low_prec_float(dtype: torch.dtype) -> bool: ...
def can_codegen_without_upcasts(prologue: SchedulerNode, disallow_fp32_ops: bool = ...) -> bool: ...
