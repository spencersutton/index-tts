from collections.abc import Callable
from typing import Any, TypeAlias

import torch

Feedback = float
Choice = str
type Value = Any
CHOICE_COL = ...
FEEDBACK_COL = ...

class AHFeature:
    def __init__(self, name: str, value: Value, is_categorical: bool = ...) -> None: ...

class AHOperation:
    def __init__(self, name: str, func: Callable[[Any], Value], is_categorical: bool = ...) -> None: ...
    def apply_operation(self, data: Any) -> None: ...

class AHContext:
    features: list[AHFeature]
    context_dict: dict[str, Value]
    def __init__(self) -> None: ...
    def add_feature(self, name: str, value: Value, is_categorical: bool = ...) -> None: ...
    def get_numerical_and_categorical_features(self) -> tuple[list[str], list[str]]: ...
    def get_feature_names_csv(self) -> str: ...
    def get_feature_values_csv(self) -> str: ...
    def get_value(self, name: str) -> Value: ...
    def apply_operations(self, operations: list[AHOperation]) -> None: ...

class AHMetadata:
    def __init__(self, shared_memory: Any, device_capa: tuple[int, int], choices: list[Choice], name: str) -> None: ...
    def to_dict(self) -> dict[str, Value]: ...

def get_metadata_str_from_log(log_path: str) -> str: ...
def check_minsize(context: AHContext, minsize: int) -> bool: ...
def pad_mm_precondition(metadata: AHMetadata, context: AHContext) -> bool: ...
def get_mixedmm_precondition(metadata: AHMetadata, context: AHContext) -> bool: ...
def get_mult_dims_ops() -> list[AHOperation]: ...
def get_arith_intensity(data: Any) -> float: ...
def pad_mm_operations() -> list[AHOperation]: ...
def between_op(data: Any, dim: str, lower: int, upper: int) -> bool: ...
def between_ops() -> list[AHOperation]: ...
def pow2_op(data: Any, dim: str, exponent: int) -> bool: ...
def mm_operations() -> list[AHOperation]: ...
def mixed_mm_operations() -> list[AHOperation]: ...
def is_multiple(data: Any, dim: str, mult: int) -> bool: ...
def get_dims_multiple_ops() -> list[AHOperation]: ...
def get_dims_need_padding_ops() -> list[AHOperation]: ...
def get_is_contig_ops() -> list[AHOperation]: ...
def context_add_strides(context: AHContext, name: str, stride: tuple[int, ...]) -> None: ...
def context_add_using_tf32(context: AHContext, dtype: torch.dtype) -> None: ...
