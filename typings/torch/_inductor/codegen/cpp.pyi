import contextlib
import dataclasses
import functools
from collections.abc import Sequence
from enum import Enum

import sympy
import torch
from torch.utils._ordered_set import OrderedSet

from ..loop_body import LoopBody
from ..scheduler import BaseSchedulerNode, BaseScheduling, FusedSchedulerNode, Scheduler, SchedulerNode
from ..utils import cache_on_self
from .common import BackendFeature, BracesBuffer, CSEVariable, IndentedBuffer, Kernel, OpOverrides
from .cpp_utils import CppCSEVariable

_IS_WINDOWS = ...

@functools.cache
def get_export_declaration(): ...

schedule_log = ...
NATIVE_OMP_RTYPES = ...
RTYPE_TO_CPP = ...
VECTORIZABLE_RTYPES = ...
PYTHON_TO_CPP = ...
CONTAINER_PYTHON_TO_CPP = ...
DTYPE_LOWP_FP = ...
VECTORIZABLE_DTYPES: list[torch.dtype] = ...
MASKED_VECTORIZABLE_DTYPES: list[torch.dtype] = ...

def reduction_init(reduction_type, dtype): ...
def reduction_acc_type(reduction_type, dtype): ...
def reduction_combine(
    reduction_type, var, next_value, helper_val=..., index: sympy.Symbol | None = ..., src_dtype=...
): ...
def reduction_project(reduction_type, acc): ...
def move_code_under_inner_loop(
    code: IndentedBuffer, iter_var: sympy.Expr, new_iter_var: str, loop_start: sympy.Expr, loop_end: sympy.Expr
) -> BracesBuffer: ...
def reduction_prefix_array(
    acc_var: str | CSEVariable, acc_type: str, reduction_type: str, dtype: torch.dtype, len: str | int, init_fn
): ...
def replace_acc_name(buffer: IndentedBuffer, name: str, new_name: str): ...
def replace_cascade_sum_with_add(buffer: IndentedBuffer): ...
@functools.lru_cache
def stride_at(index: sympy.Expr, var: sympy.Symbol): ...
@functools.lru_cache
def simplify_index_in_vec_range(index: sympy.Expr, var: sympy.Expr, vec_length: int): ...
@functools.lru_cache
def stride_at_vec_range(index: sympy.Expr, var: sympy.Symbol, vec_length: int | None = ...): ...

@dataclasses.dataclass
class ParallelDepth:
    parallel_depth: int
    start_depth: int

class OuterLoopFusedSchedulerNode(FusedSchedulerNode):
    @classmethod
    def fuse(cls, node1: BaseSchedulerNode, node2: BaseSchedulerNode, outer_loop_fusion_depth): ...
    def __init__(
        self, scheduler: Scheduler, outer_fused_nodes: list[FusedSchedulerNode | SchedulerNode], outer_loop_fusion_depth
    ) -> None: ...
    def get_outer_nodes(self): ...
    def check_outer_fusion_loop_level_attr(self, cpp_kernel_proxy_list, outer_loop_fusion_depth): ...
    def merge_outer_fusion_kernels(self, cpp_kernel_proxy_list): ...

class RecordOptimizationContext:
    def __init__(self, func_name: str = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...
    def get_opt_ctx(self): ...
    def get_fx_node(self): ...

def decltype_promoted(*args): ...

class CppOverrides(OpOverrides):
    @staticmethod
    def add(a, b): ...
    @staticmethod
    def sub(a, b): ...
    @staticmethod
    def mul(a, b): ...
    @staticmethod
    def to_dtype(x, dtype, src_dtype=..., use_compute_types=...): ...
    @staticmethod
    def to_dtype_bitcast(x, dtype, src_dtype): ...
    @staticmethod
    def abs(x): ...
    @staticmethod
    def sin(x): ...
    @staticmethod
    def cos(x): ...
    @staticmethod
    def neg(x): ...
    @staticmethod
    def exp(x): ...
    @staticmethod
    def exp2(x): ...
    @staticmethod
    def expm1(x): ...
    @staticmethod
    def erf(x): ...
    @staticmethod
    def erfc(x): ...
    @staticmethod
    def erfinv(x): ...
    @staticmethod
    def sqrt(x): ...
    @staticmethod
    def rsqrt(x): ...
    @staticmethod
    def log1p(x): ...
    @staticmethod
    def tan(x): ...
    @staticmethod
    def tanh(x): ...
    @staticmethod
    def signbit(x): ...
    @staticmethod
    def pow(a, b): ...
    @staticmethod
    def log(x): ...
    @staticmethod
    def round(x): ...
    @staticmethod
    def floor(x): ...
    @staticmethod
    def floordiv(a, b): ...
    @staticmethod
    def ceil(x): ...
    @staticmethod
    def trunc(x): ...
    @staticmethod
    def truncdiv(a, b): ...
    @staticmethod
    def fmod(a, b): ...
    @staticmethod
    def isinf(x): ...
    @staticmethod
    def isnan(x): ...
    @staticmethod
    def lgamma(x): ...
    @staticmethod
    def acos(x): ...
    @staticmethod
    def acosh(x): ...
    @staticmethod
    def cosh(x): ...
    @staticmethod
    def sinh(x): ...
    @staticmethod
    def asin(x): ...
    @staticmethod
    def asinh(x): ...
    @staticmethod
    def atan2(x, y): ...
    @staticmethod
    def atan(x): ...
    @staticmethod
    def atanh(x): ...
    @staticmethod
    def copysign(x, y): ...
    @staticmethod
    def frexp(x): ...
    @staticmethod
    def hypot(x, y): ...
    @staticmethod
    def log10(x): ...
    @staticmethod
    def log2(x): ...
    @staticmethod
    def nextafter(x, y): ...
    @staticmethod
    def relu(x): ...
    @staticmethod
    def minimum(a, b): ...
    @staticmethod
    def maximum(a, b): ...
    @staticmethod
    def where(a, b, c): ...
    @staticmethod
    def mod(a, b): ...
    @staticmethod
    def constant(val, dtype): ...
    @staticmethod
    def index_expr(expr, dtype): ...
    @staticmethod
    def masked(mask, body, other): ...
    @staticmethod
    def logical_and(a, b): ...
    @staticmethod
    def logical_not(a): ...
    @staticmethod
    def logical_or(a, b): ...
    @staticmethod
    def logical_xor(a, b): ...
    @staticmethod
    def bitwise_and(a, b): ...
    @staticmethod
    def bitwise_not(a): ...
    @staticmethod
    def bitwise_or(a, b): ...
    @staticmethod
    def bitwise_xor(a, b): ...
    @staticmethod
    def bitwise_left_shift(a, b): ...
    @staticmethod
    def bitwise_right_shift(a, b): ...
    @staticmethod
    def rand(seed: sympy.Expr, offset: sympy.Expr): ...
    @staticmethod
    def randn(seed: sympy.Expr, offset: sympy.Expr): ...
    @staticmethod
    def randint64(seed: sympy.Expr, offset: sympy.Expr, low, high): ...
    @staticmethod
    def sigmoid(x): ...
    @staticmethod
    def sign(x): ...
    @staticmethod
    def device_assert_async(cond, msg): ...

class CppVecOverrides(CppOverrides):
    def __new__(cls, *args, **kargs): ...
    @staticmethod
    def add(a, b): ...
    @staticmethod
    def sub(a, b): ...
    @staticmethod
    def mul(a, b): ...
    @staticmethod
    def truediv(a, b): ...
    @staticmethod
    def abs(x): ...
    @staticmethod
    def sin(x): ...
    @staticmethod
    def cos(x): ...
    @staticmethod
    def exp(x): ...
    @staticmethod
    def exp2(x): ...
    @staticmethod
    def expm1(x): ...
    @staticmethod
    def erf(x): ...
    @staticmethod
    def erfc(x): ...
    @staticmethod
    def erfinv(x): ...
    @staticmethod
    def sqrt(x): ...
    @staticmethod
    def eq(x, y): ...
    @staticmethod
    def ne(x, y): ...
    @staticmethod
    def lt(x, y): ...
    @staticmethod
    def gt(x, y): ...
    @staticmethod
    def le(x, y): ...
    @staticmethod
    def ge(x, y): ...
    @staticmethod
    def and_(x, y): ...
    @staticmethod
    def rsqrt(x): ...
    @staticmethod
    def pow(a, b): ...
    @staticmethod
    def log(x): ...
    @staticmethod
    def round(x): ...
    @staticmethod
    def floor(x): ...
    @staticmethod
    def ceil(x): ...
    @staticmethod
    def trunc(x): ...
    @staticmethod
    def fmod(a, b): ...
    @staticmethod
    def lgamma(x): ...
    @staticmethod
    def logical_and(a, b): ...
    @staticmethod
    def logical_not(a): ...
    @staticmethod
    def logical_or(a, b): ...
    @staticmethod
    def logical_xor(a, b): ...
    @staticmethod
    def bitwise_and(a, b): ...
    @staticmethod
    def bitwise_not(a): ...
    @staticmethod
    def bitwise_or(a, b): ...
    @staticmethod
    def bitwise_xor(a, b): ...
    @staticmethod
    def bitwise_left_shift(a, b): ...
    @staticmethod
    def bitwise_right_shift(a, b): ...
    @staticmethod
    def load_seed(name, offset): ...
    @staticmethod
    def rand(seed, offset): ...
    @staticmethod
    def randn(seed, offset): ...
    @staticmethod
    def randint64(seed, offset, low, high): ...
    @staticmethod
    def remainder(a, b): ...
    @staticmethod
    def tan(a): ...
    @staticmethod
    def tanh(a): ...
    @staticmethod
    def reciprocal(a): ...
    @staticmethod
    def atan(x): ...
    @staticmethod
    def acos(x): ...
    @staticmethod
    def asin(x): ...
    @staticmethod
    def cosh(x): ...
    @staticmethod
    def sinh(x): ...
    @staticmethod
    def log10(x): ...
    @staticmethod
    def log2(x): ...
    @staticmethod
    def nextafter(x, y): ...
    @staticmethod
    def copysign(a, b): ...
    @staticmethod
    def atan2(a, b): ...
    @staticmethod
    def hypot(a, b): ...
    @staticmethod
    def atanh(x): ...
    @staticmethod
    def asinh(x): ...
    @staticmethod
    def acosh(x): ...
    @staticmethod
    def relu(x): ...
    @staticmethod
    def sigmoid(x): ...
    @staticmethod
    def neg(x): ...
    @staticmethod
    def floordiv(a, b): ...
    @staticmethod
    def truncdiv(a, b): ...
    @staticmethod
    def minimum(a, b): ...
    @staticmethod
    def maximum(a, b): ...
    @staticmethod
    def square(a): ...
    @staticmethod
    def where(a, b, c): ...
    @staticmethod
    def sign(x): ...
    @staticmethod
    def to_dtype(x, dtype, src_dtype=..., use_compute_dtypes=...): ...
    @staticmethod
    def log1p(x): ...
    @staticmethod
    def masked(mask, body, other): ...
    @staticmethod
    def index_expr(expr, dtype): ...
    @staticmethod
    def frexp(x): ...

class CppTile2DOverrides(CppVecOverrides):
    @staticmethod
    def index_expr(expr, dtype): ...

class CppKernel(Kernel):
    overrides = CppOverrides
    sexpr = ...
    newvar_prefix = ...
    suffix = ...
    def __init__(self, args, num_threads) -> None: ...
    def update_stores_with_parallel_reduction(self): ...
    def gen_body(self, code: BracesBuffer | None = ...): ...
    @contextlib.contextmanager
    def masked(self, mask): ...
    def scale_index_with_offset(self, index: sympy.Expr, scale=..., itervar_idx=..., offset=...): ...
    def index_to_str(self, index: sympy.Expr) -> str: ...
    def index_indirect_depends_on(self, index: sympy.Expr, itervar: sympy.Symbol): ...
    def index_depends_on(self, index: sympy.Expr, itervar: sympy.Symbol): ...
    def var_ranges(self): ...
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool): ...
    def load(self, name: str, index: sympy.Expr): ...
    def store(self, name, index, value, mode=...): ...
    def finalize_reduction_prefix(self, size: int | None = ...): ...
    def need_use_acc_helper(self, reduction_type, dtype, use_scalar): ...
    def need_use_acc_helper(self, reduction_type, dtype, use_scalar): ...
    def reduction(self, dtype, src_dtype, reduction_type, value): ...
    def store_reduction(self, name, index, value): ...
    def set_ranges(self, lengths, reduction_lengths): ...
    def size_hint(self): ...
    def codegen_loops_impl(self, loop_nest, code, worksharing): ...
    def codegen_loops(self, code, worksharing): ...
    @property
    def assert_function(self) -> str: ...
    def decide_parallel_depth(self, max_parallel_depth, threads): ...
    @contextlib.contextmanager
    def write_to_suffix(self): ...
    def create_cse_var(self, *args, **kwargs): ...
    def get_to_dtype_expr(self, src, dtype, src_dtype): ...
    def cache_dtype_convert(self, dst, dst_dtype, src, src_dtype): ...
    def codegen_conditions(self, code: BracesBuffer, prefix: str | None = ..., var: sympy.Symbol | None = ...): ...

class CppVecKernel(CppKernel):
    overrides = CppVecOverrides
    def __init__(self, args, num_threads, tiling_factor, tiling_idx, tail_size=...) -> None: ...
    def load(self, name: str, index: sympy.Expr): ...
    def store(self, name, index, value, mode=...): ...
    def reduction(self, dtype, src_dtype, reduction_type, value): ...
    def store_reduction(self, name, index, value): ...
    def broadcast(self, scalar_var: CppCSEVariable) -> CppCSEVariable: ...
    def arange(self, index: CppCSEVariable, stride: sympy.Symbol) -> CppCSEVariable: ...
    def reduction_init_vec(self, reduction_type, dtype): ...
    def reduction_acc_type_vec(self, reduction_type, dtype): ...
    def reduction_combine_vec(
        self,
        reduction_type,
        var,
        next_value,
        helper_val=...,
        index: sympy.Symbol | None = ...,
        horizontal_reduction: bool | None = ...,
        src_dtype: torch.dtype | None = ...,
    ): ...
    def indirect_assert(self, var, lower, upper, mask=...): ...
    def get_to_dtype_expr(self, src, dtype, src_dtype): ...

class CppTile2DKernel(CppVecKernel):
    overrides = CppTile2DOverrides
    def __init__(
        self, args, num_threads, tiling_factor, tiling_indices, inner_tail_size=..., outer_tail_size=...
    ) -> None: ...
    def inner_itervar(self): ...
    def need_vec_transpose(self, index): ...
    def gen_transposed_tile_load_store(self, name, var, index, is_store, store_mode=...): ...
    def load(self, name: str, index: sympy.Expr): ...
    def store(self, name, index, value, mode=...): ...
    def codegen_inner_loops(self, code): ...
    def set_ranges(self, group, reduction_group): ...
    def transform_indexing(self, index: sympy.Expr) -> sympy.Expr: ...

def get_loop_body_lowp_fp(_body: LoopBody) -> tuple[torch.dtype | None, bool]: ...

class TilingSelect:
    def __init__(self) -> None: ...
    def select_tiling(self, fn_list, var_sizes_list) -> tuple[list[int], list[int]]: ...

class CppKernelProxy(CppKernel):
    kernel_cls: type[CppKernel] = ...
    vec_kernel_cls: type[CppVecKernel] = ...
    tile2d_kernel_cls: type[CppTile2DKernel] = ...
    def __init__(self, kernel_group) -> None: ...
    def data_type_propagation(self, nodes): ...
    def is_lowp_fp_scheduler(self, scheduler_node: SchedulerNode): ...
    def legalize_lowp_fp_dtype_loopbody(self, loop_body: LoopBody): ...
    def legalize_lowp_fp_dtype(self, nodes): ...
    def codegen_functions(self, fn_list, var_sizes_list): ...
    def codegen_loop_bodies(self, loop_bodies, var_sizes_list): ...
    def codegen_nodes(self, nodes: list[SchedulerNode]): ...
    def codegen_loops(self, code, worksharing): ...
    def update_stores_with_parallel_reduction(self): ...
    def gen_body(self, code: BracesBuffer | None = ...): ...
    def aggregate_reduction_buffers(self, inner_loop_reduction_outer_not: bool, outer_loop: LoopLevel | None): ...

class OuterLoopFusedKernel(CppKernel):
    def __init__(self, kernel_group) -> None: ...
    def decide_parallel_depth(self, max_parallel_depth, threads): ...

class ReasonFusedNodes(Enum):
    SAME_VARS_REDUCE = ...
    COMPATIBLE_REDUCTION = ...
    COMPATIBLE_RANGES_NO_REDUCTION = ...

class CppScheduling(BaseScheduling):
    kernel_proxy_cls: type[CppKernelProxy] = ...
    MAX_FUSED_KERNEL_ARGS_NUM = ...
    backend_features = ...
    @classmethod
    def get_backend_features(cls, device: torch.device) -> OrderedSet[BackendFeature]: ...
    def __init__(self, scheduler) -> None: ...
    def group_fn(self, sizes): ...
    def reset_kernel_group(self): ...
    def fuse(self, node1, node2): ...
    def can_fuse_horizontal(self, node1, node2): ...
    def can_fuse_multi_outputs_template(self, node1: BaseSchedulerNode, node2: BaseSchedulerNode) -> bool: ...
    def can_fuse_vertical_outer_loop(self, node1, node2): ...
    def get_fusion_pair_priority(self, node1, node2): ...
    def can_fuse_vertical(self, node1, node2): ...
    def try_loop_split(self, nodes: list[SchedulerNode]): ...
    def codegen_outer_loop_node(self, node: OuterLoopFusedSchedulerNode): ...
    def codegen_node(self, node: OuterLoopFusedSchedulerNode | FusedSchedulerNode | SchedulerNode): ...
    def is_cpp_template(self, node: BaseSchedulerNode) -> bool: ...
    def codegen_template(
        self,
        template_node: BaseSchedulerNode,
        epilogue_nodes: Sequence[BaseSchedulerNode],
        prologue_nodes: Sequence[BaseSchedulerNode],
    ): ...
    def ready_to_flush(self): ...
    def codegen_sync(self): ...
    def define_kernel(self, src_code, nodes, kernel_args=...): ...
    def flush(self): ...

class KernelGroup:
    def __init__(self) -> None: ...
    def new_kernel(self, cls, *args): ...
    def finalize_kernel(self, new_kernel, nodes): ...
    def get_num_args(self): ...
    def codegen_group(self, name=...) -> str: ...
    def call_kernel(self, wrapper, kernel_name, debug_handle: int | None = ...): ...

class WorkSharing:
    def __init__(self, code) -> None: ...
    def parallel(self, threads): ...
    def single(self): ...
    def close(self): ...
    def __enter__(self): ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...

@dataclasses.dataclass
class LoopLevel:
    var: sympy.Expr | None = ...
    size: sympy.Expr | None = ...
    offset: sympy.Expr = ...
    tiled_size: sympy.Expr = ...
    steps: sympy.Expr = ...
    parallel: int = ...
    simd_omp: bool = ...
    simd_vec: bool = ...
    collapsed: bool = ...
    is_reduction: bool = ...
    def __post_init__(self): ...
    def tile(self, factor): ...
    def lines(self): ...

@dataclasses.dataclass
class LoopNest:
    loops: list[LoopLevel] | None = ...
    kernel: CppKernel | None = ...
    @staticmethod
    def build(kernel: CppKernel): ...
    def __bool__(self) -> bool: ...
    @cache_on_self
    def max_parallel_depth(self): ...
    def mark_parallel(self, par_depth): ...
    def tile(self, depth, factor): ...
    def get_kernel(self) -> CppKernel: ...
    def set_kernel(self, kernel): ...
    def from_loop_level(self, level: int): ...
