import contextlib
import dataclasses
import functools
from collections.abc import Sequence
from enum import Enum
from typing import Optional, Union

import sympy
import torch
from torch.utils._ordered_set import OrderedSet

from ..loop_body import LoopBody
from ..scheduler import BaseSchedulerNode, BaseScheduling, FusedSchedulerNode, Scheduler, SchedulerNode
from ..utils import cache_on_self
from .common import BackendFeature, BracesBuffer, CSEVariable, IndentedBuffer, Kernel, OpOverrides
from .cpp_utils import CppCSEVariable

_IS_WINDOWS = ...

@functools.cache
def get_export_declaration():  # -> Literal['__declspec(dllexport)', '']:
    ...

schedule_log = ...
NATIVE_OMP_RTYPES = ...
RTYPE_TO_CPP = ...
VECTORIZABLE_RTYPES = ...
PYTHON_TO_CPP = ...
CONTAINER_PYTHON_TO_CPP = ...
DTYPE_LOWP_FP = ...
VECTORIZABLE_DTYPES: list[torch.dtype] = ...
MASKED_VECTORIZABLE_DTYPES: list[torch.dtype] = ...

def reduction_init(reduction_type, dtype):  # -> str | Literal[0, 1]:
    ...
def reduction_acc_type(reduction_type, dtype):  # -> str:
    ...
def reduction_combine(
    reduction_type, var, next_value, helper_val=..., index: sympy.Symbol | None = ..., src_dtype=...
):  # -> str:
    ...
def reduction_project(reduction_type, acc):  # -> tuple[str, str, str] | str:
    ...
def move_code_under_inner_loop(
    code: IndentedBuffer, iter_var: sympy.Expr, new_iter_var: str, loop_start: sympy.Expr, loop_end: sympy.Expr
) -> BracesBuffer: ...
def reduction_prefix_array(
    acc_var: str | CSEVariable,
    acc_type: str,
    reduction_type: str,
    dtype: torch.dtype,
    len: str | int,
    init_fn,
):  # -> IndentedBuffer:

    ...
def replace_acc_name(buffer: IndentedBuffer, name: str, new_name: str):  # -> None:
    ...
def replace_cascade_sum_with_add(buffer: IndentedBuffer):  # -> None:

    ...
@functools.lru_cache
def stride_at(index: sympy.Expr, var: sympy.Symbol): ...
@functools.lru_cache
def simplify_index_in_vec_range(index: sympy.Expr, var: sympy.Expr, vec_length: int): ...
@functools.lru_cache
def stride_at_vec_range(index: sympy.Expr, var: sympy.Symbol, vec_length: int | None = ...): ...

@dataclasses.dataclass
class ParallelDepth:
    parallel_depth: int
    start_depth: int

class OuterLoopFusedSchedulerNode(FusedSchedulerNode):
    @classmethod
    def fuse(cls, node1: BaseSchedulerNode, node2: BaseSchedulerNode, outer_loop_fusion_depth):  # -> Self:
        ...
    def __init__(
        self,
        scheduler: Scheduler,
        outer_fused_nodes: list[FusedSchedulerNode | SchedulerNode],
        outer_loop_fusion_depth,
    ) -> None: ...
    def get_outer_nodes(self):  # -> list[FusedSchedulerNode | SchedulerNode]:
        ...
    def check_outer_fusion_loop_level_attr(self, cpp_kernel_proxy_list, outer_loop_fusion_depth):  # -> bool:
        ...
    def merge_outer_fusion_kernels(self, cpp_kernel_proxy_list): ...

class RecordOptimizationContext:
    def __init__(self, func_name: str = ...) -> None: ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, exc_type, exc_val, exc_tb):  # -> None:
        ...
    def get_opt_ctx(self):  # -> OptimizationContext | None:
        ...
    def get_fx_node(self):  # -> Node:
        ...

def decltype_promoted(*args):  # -> str:
    ...

class CppOverrides(OpOverrides):
    @staticmethod
    def add(a, b):  # -> str:
        ...
    @staticmethod
    def sub(a, b):  # -> str:
        ...
    @staticmethod
    def mul(a, b):  # -> str:
        ...
    @staticmethod
    def to_dtype(x, dtype, src_dtype=..., use_compute_types=...): ...
    @staticmethod
    def to_dtype_bitcast(x, dtype, src_dtype):  # -> str:
        ...
    @staticmethod
    def abs(x):  # -> str:
        ...
    @staticmethod
    def sin(x):  # -> str:
        ...
    @staticmethod
    def cos(x):  # -> str:
        ...
    @staticmethod
    def neg(x):  # -> str:
        ...
    @staticmethod
    def exp(x):  # -> str:
        ...
    @staticmethod
    def exp2(x):  # -> str:
        ...
    @staticmethod
    def expm1(x):  # -> str:
        ...
    @staticmethod
    def erf(x):  # -> str:
        ...
    @staticmethod
    def erfc(x):  # -> str:
        ...
    @staticmethod
    def erfinv(x):  # -> str:
        ...
    @staticmethod
    def sqrt(x):  # -> str:
        ...
    @staticmethod
    def rsqrt(x):  # -> str:
        ...
    @staticmethod
    def log1p(x):  # -> str:
        ...
    @staticmethod
    def tan(x):  # -> str:
        ...
    @staticmethod
    def tanh(x):  # -> str:
        ...
    @staticmethod
    def signbit(x):  # -> str:

        ...
    @staticmethod
    def pow(a, b):  # -> str:
        ...
    @staticmethod
    def log(x):  # -> str:
        ...
    @staticmethod
    def round(x):  # -> str:
        ...
    @staticmethod
    def floor(x):  # -> str:
        ...
    @staticmethod
    def floordiv(a, b):  # -> str:
        ...
    @staticmethod
    def ceil(x):  # -> str:
        ...
    @staticmethod
    def trunc(x):  # -> str:
        ...
    @staticmethod
    def truncdiv(a, b):  # -> str:
        ...
    @staticmethod
    def fmod(a, b):  # -> str:
        ...
    @staticmethod
    def isinf(x):  # -> str:
        ...
    @staticmethod
    def isnan(x):  # -> str:
        ...
    @staticmethod
    def lgamma(x):  # -> str:
        ...
    @staticmethod
    def acos(x):  # -> str:
        ...
    @staticmethod
    def acosh(x):  # -> str:
        ...
    @staticmethod
    def cosh(x):  # -> str:
        ...
    @staticmethod
    def sinh(x):  # -> str:
        ...
    @staticmethod
    def asin(x):  # -> str:
        ...
    @staticmethod
    def asinh(x):  # -> str:
        ...
    @staticmethod
    def atan2(x, y):  # -> str:
        ...
    @staticmethod
    def atan(x):  # -> str:
        ...
    @staticmethod
    def atanh(x):  # -> str:
        ...
    @staticmethod
    def copysign(x, y):  # -> str:
        ...
    @staticmethod
    def frexp(x):  # -> tuple[Any, ...] | tuple[Any, Any]:
        ...
    @staticmethod
    def hypot(x, y):  # -> str:
        ...
    @staticmethod
    def log10(x):  # -> str:
        ...
    @staticmethod
    def log2(x):  # -> str:
        ...
    @staticmethod
    def nextafter(x, y):  # -> str:
        ...
    @staticmethod
    def relu(x):  # -> str:
        ...
    @staticmethod
    def minimum(a, b):  # -> str:
        ...
    @staticmethod
    def maximum(a, b):  # -> str:
        ...
    @staticmethod
    def where(a, b, c):  # -> str:
        ...
    @staticmethod
    def mod(a, b):  # -> str:
        ...
    @staticmethod
    def constant(val, dtype):  # -> str:
        ...
    @staticmethod
    def index_expr(expr, dtype):  # -> Any:
        ...
    @staticmethod
    def masked(mask, body, other):  # -> str:
        ...
    @staticmethod
    def logical_and(a, b):  # -> str:
        ...
    @staticmethod
    def logical_not(a):  # -> str:
        ...
    @staticmethod
    def logical_or(a, b):  # -> str:
        ...
    @staticmethod
    def logical_xor(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_and(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_not(a):  # -> str:
        ...
    @staticmethod
    def bitwise_or(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_xor(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_left_shift(a, b):  # -> BracesBuffer:
        ...
    @staticmethod
    def bitwise_right_shift(a, b):  # -> BracesBuffer:
        ...
    @staticmethod
    def rand(seed: sympy.Expr, offset: sympy.Expr):  # -> str:
        ...
    @staticmethod
    def randn(seed: sympy.Expr, offset: sympy.Expr):  # -> str:
        ...
    @staticmethod
    def randint64(seed: sympy.Expr, offset: sympy.Expr, low, high):  # -> str:
        ...
    @staticmethod
    def sigmoid(x):  # -> str:
        ...
    @staticmethod
    def sign(x):  # -> BracesBuffer:
        ...
    @staticmethod
    def device_assert_async(cond, msg):  # -> str:
        ...

class CppVecOverrides(CppOverrides):
    def __new__(cls, *args, **kargs):  # -> Self:
        ...
    @staticmethod
    def add(a, b):  # -> str:
        ...
    @staticmethod
    def sub(a, b):  # -> str:
        ...
    @staticmethod
    def mul(a, b):  # -> str:
        ...
    @staticmethod
    def truediv(a, b):  # -> str:
        ...
    @staticmethod
    def abs(x):  # -> str:
        ...
    @staticmethod
    def sin(x):  # -> str:
        ...
    @staticmethod
    def cos(x):  # -> str:
        ...
    @staticmethod
    def exp(x):  # -> str:
        ...
    @staticmethod
    def exp2(x):  # -> str:
        ...
    @staticmethod
    def expm1(x):  # -> str:
        ...
    @staticmethod
    def erf(x):  # -> str:
        ...
    @staticmethod
    def erfc(x):  # -> str:
        ...
    @staticmethod
    def erfinv(x):  # -> str:
        ...
    @staticmethod
    def sqrt(x):  # -> str:
        ...
    @staticmethod
    def eq(x, y):  # -> str:
        ...
    @staticmethod
    def ne(x, y):  # -> str:
        ...
    @staticmethod
    def lt(x, y):  # -> str:
        ...
    @staticmethod
    def gt(x, y):  # -> str:
        ...
    @staticmethod
    def le(x, y):  # -> str:
        ...
    @staticmethod
    def ge(x, y):  # -> str:
        ...
    @staticmethod
    def and_(x, y):  # -> str:
        ...
    @staticmethod
    def rsqrt(x):  # -> str:
        ...
    @staticmethod
    def pow(a, b):  # -> str:
        ...
    @staticmethod
    def log(x):  # -> str:
        ...
    @staticmethod
    def round(x):  # -> str:
        ...
    @staticmethod
    def floor(x):  # -> str:
        ...
    @staticmethod
    def ceil(x):  # -> str:
        ...
    @staticmethod
    def trunc(x):  # -> str:
        ...
    @staticmethod
    def fmod(a, b):  # -> str:
        ...
    @staticmethod
    def lgamma(x):  # -> str:
        ...
    @staticmethod
    def logical_and(a, b):  # -> str:
        ...
    @staticmethod
    def logical_not(a):  # -> str:
        ...
    @staticmethod
    def logical_or(a, b):  # -> str:
        ...
    @staticmethod
    def logical_xor(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_and(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_not(a):  # -> str:
        ...
    @staticmethod
    def bitwise_or(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_xor(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_left_shift(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_right_shift(a, b):  # -> str:
        ...
    @staticmethod
    def load_seed(name, offset):  # -> str:
        ...
    @staticmethod
    def rand(seed, offset): ...
    @staticmethod
    def randn(seed, offset): ...
    @staticmethod
    def randint64(seed, offset, low, high): ...
    @staticmethod
    def remainder(a, b):  # -> str:
        ...
    @staticmethod
    def tan(a):  # -> str:
        ...
    @staticmethod
    def tanh(a):  # -> str:
        ...
    @staticmethod
    def reciprocal(a):  # -> str:
        ...
    @staticmethod
    def atan(x):  # -> str:
        ...
    @staticmethod
    def acos(x):  # -> str:
        ...
    @staticmethod
    def asin(x):  # -> str:
        ...
    @staticmethod
    def cosh(x):  # -> str:
        ...
    @staticmethod
    def sinh(x):  # -> str:
        ...
    @staticmethod
    def log10(x):  # -> str:
        ...
    @staticmethod
    def log2(x):  # -> str:
        ...
    @staticmethod
    def nextafter(x, y):  # -> str:
        ...
    @staticmethod
    def copysign(a, b):  # -> str:
        ...
    @staticmethod
    def atan2(a, b):  # -> str:
        ...
    @staticmethod
    def hypot(a, b):  # -> str:
        ...
    @staticmethod
    def atanh(x):  # -> str:
        ...
    @staticmethod
    def asinh(x):  # -> str:
        ...
    @staticmethod
    def acosh(x):  # -> str:
        ...
    @staticmethod
    def relu(x):  # -> str:
        ...
    @staticmethod
    def sigmoid(x):  # -> str:
        ...
    @staticmethod
    def neg(x):  # -> str:
        ...
    @staticmethod
    def floordiv(a, b):  # -> str:
        ...
    @staticmethod
    def truncdiv(a, b):  # -> str:
        ...
    @staticmethod
    def minimum(a, b):  # -> str:
        ...
    @staticmethod
    def maximum(a, b):  # -> str:
        ...
    @staticmethod
    def square(a):  # -> str:
        ...
    @staticmethod
    def where(a, b, c):  # -> str:
        ...
    @staticmethod
    def sign(x):  # -> BracesBuffer:
        ...
    @staticmethod
    def to_dtype(x, dtype, src_dtype=..., use_compute_dtypes=...): ...
    @staticmethod
    def log1p(x):  # -> str:
        ...
    @staticmethod
    def masked(mask, body, other):  # -> CSEVariable:
        ...
    @staticmethod
    def index_expr(expr, dtype):  # -> Any | CppCSEVariable | None:
        ...
    @staticmethod
    def frexp(x):  # -> tuple[Any, ...] | tuple[Any, Any]:
        ...

class CppTile2DOverrides(CppVecOverrides):
    @staticmethod
    def index_expr(expr, dtype):  # -> Any | CppCSEVariable | None:
        ...

class CppKernel(Kernel):
    overrides = CppOverrides
    sexpr = ...
    newvar_prefix = ...
    suffix = ...
    def __init__(self, args, num_threads) -> None: ...
    def update_stores_with_parallel_reduction(self):  # -> None:
        ...
    def gen_body(self, code: BracesBuffer | None = ...):  # -> BracesBuffer:
        ...
    @contextlib.contextmanager
    def masked(self, mask):  # -> Generator[CppCSEVariable | Any, Any, None]:

        ...
    def scale_index_with_offset(self, index: sympy.Expr, scale=..., itervar_idx=..., offset=...): ...
    def index_to_str(self, index: sympy.Expr) -> str: ...
    def index_indirect_depends_on(self, index: sympy.Expr, itervar: sympy.Symbol):  # -> bool:

        ...
    def index_depends_on(self, index: sympy.Expr, itervar: sympy.Symbol):  # -> bool:
        ...
    def var_ranges(self):  # -> dict[Any, Any]:
        ...
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool):  # -> None:
        ...
    def load(self, name: str, index: sympy.Expr):  # -> CSEVariable:
        ...
    def store(self, name, index, value, mode=...):  # -> None:
        ...
    def finalize_reduction_prefix(self, size: int | None = ...):  # -> None:
        ...
    def need_use_acc_helper(self, reduction_type, dtype, use_scalar):  # -> bool:
        ...
    def reduction(self, dtype, src_dtype, reduction_type, value):  # -> CSEVariable | tuple[str, str, str] | str:
        ...
    def store_reduction(self, name, index, value):  # -> None:
        ...
    def set_ranges(self, lengths, reduction_lengths):  # -> tuple[list[Any], list[Any]]:
        ...
    def size_hint(self):  # -> int:
        ...
    def codegen_loops_impl(self, loop_nest, code, worksharing):  # -> None:
        ...
    def codegen_loops(self, code, worksharing):  # -> None:
        ...
    @property
    def assert_function(self) -> str: ...
    def decide_parallel_depth(self, max_parallel_depth, threads):  # -> ParallelDepth:
        ...
    @contextlib.contextmanager
    def write_to_suffix(self):  # -> Generator[None, Any, None]:
        ...
    def create_cse_var(self, *args, **kwargs):  # -> CppCSEVariable:
        ...
    def get_to_dtype_expr(self, src, dtype, src_dtype):  # -> str:
        ...
    def cache_dtype_convert(self, dst, dst_dtype, src, src_dtype):  # -> None:
        ...
    def codegen_conditions(
        self, code: BracesBuffer, prefix: str | None = ..., var: sympy.Symbol | None = ...
    ):  # -> bool:
        ...

class CppVecKernel(CppKernel):
    overrides = CppVecOverrides
    def __init__(self, args, num_threads, tiling_factor, tiling_idx, tail_size=...) -> None: ...
    def load(self, name: str, index: sympy.Expr):  # -> CSEVariable | CppCSEVariable:
        ...
    def store(self, name, index, value, mode=...):  # -> None:
        ...
    def reduction(self, dtype, src_dtype, reduction_type, value):  # -> CSEVariable | tuple[str, str, str] | str:

        ...
    def store_reduction(self, name, index, value):  # -> None:
        ...
    def broadcast(self, scalar_var: CppCSEVariable) -> CppCSEVariable: ...
    def arange(self, index: CppCSEVariable, stride: sympy.Symbol) -> CppCSEVariable: ...
    def reduction_init_vec(self, reduction_type, dtype):  # -> str:
        ...
    def reduction_acc_type_vec(self, reduction_type, dtype):  # -> str:
        ...
    def reduction_combine_vec(
        self,
        reduction_type,
        var,
        next_value,
        helper_val=...,
        index: sympy.Symbol | None = ...,
        horizontal_reduction: bool | None = ...,
        src_dtype: torch.dtype | None = ...,
    ):  # -> str:
        ...
    def indirect_assert(self, var, lower, upper, mask=...):  # -> str:
        ...
    def get_to_dtype_expr(self, src, dtype, src_dtype):  # -> str:
        ...

class CppTile2DKernel(CppVecKernel):
    overrides = CppTile2DOverrides
    def __init__(
        self, args, num_threads, tiling_factor, tiling_indices, inner_tail_size=..., outer_tail_size=...
    ) -> None: ...
    def inner_itervar(self): ...
    def need_vec_transpose(self, index):  # -> bool:
        ...
    def gen_transposed_tile_load_store(self, name, var, index, is_store, store_mode=...):  # -> CSEVariable:
        ...
    def load(self, name: str, index: sympy.Expr):  # -> CppCSEVariable | CSEVariable:
        ...
    def store(self, name, index, value, mode=...):  # -> None:
        ...
    def codegen_inner_loops(self, code):  # -> None:
        ...
    def set_ranges(self, group, reduction_group):  # -> tuple[list[Any], list[Any]]:
        ...
    def transform_indexing(self, index: sympy.Expr) -> sympy.Expr: ...

def get_loop_body_lowp_fp(_body: LoopBody) -> tuple[torch.dtype | None, bool]: ...

class TilingSelect:
    def __init__(self) -> None: ...
    def select_tiling(self, fn_list, var_sizes_list) -> tuple[list[int], list[int]]: ...

class CppKernelProxy(CppKernel):
    kernel_cls: type[CppKernel] = ...
    vec_kernel_cls: type[CppVecKernel] = ...
    tile2d_kernel_cls: type[CppTile2DKernel] = ...
    def __init__(self, kernel_group) -> None: ...
    def data_type_propagation(self, nodes):  # -> None:
        ...
    def is_lowp_fp_scheduler(self, scheduler_node: SchedulerNode):  # -> bool:
        ...
    def legalize_lowp_fp_dtype_loopbody(self, loop_body: LoopBody):  # -> None:
        ...
    def legalize_lowp_fp_dtype(self, nodes):  # -> None:
        ...
    def codegen_functions(self, fn_list, var_sizes_list):  # -> None:
        ...
    def codegen_loop_bodies(self, loop_bodies, var_sizes_list):  # -> None:
        ...
    def codegen_nodes(self, nodes: list[SchedulerNode]):  # -> None:
        ...
    def codegen_loops(self, code, worksharing):  # -> None:
        ...
    def update_stores_with_parallel_reduction(self):  # -> None:
        ...
    def gen_body(self, code: BracesBuffer | None = ...):  # -> None:
        ...
    def aggregate_reduction_buffers(
        self, inner_loop_reduction_outer_not: bool, outer_loop: LoopLevel | None
    ):  # -> None:

        ...

class OuterLoopFusedKernel(CppKernel):
    def __init__(self, kernel_group) -> None: ...
    def decide_parallel_depth(self, max_parallel_depth, threads):  # -> ParallelDepth:
        ...

class ReasonFusedNodes(Enum):
    SAME_VARS_REDUCE = ...
    COMPATIBLE_REDUCTION = ...
    COMPATIBLE_RANGES_NO_REDUCTION = ...

class CppScheduling(BaseScheduling):
    kernel_proxy_cls: type[CppKernelProxy] = ...
    MAX_FUSED_KERNEL_ARGS_NUM = ...
    backend_features = ...
    @classmethod
    def get_backend_features(cls, device: torch.device) -> OrderedSet[BackendFeature]: ...
    def __init__(self, scheduler) -> None: ...
    def group_fn(self, sizes):  # -> tuple[tuple[Any, ...], ...]:
        ...
    def reset_kernel_group(self):  # -> None:
        ...
    def fuse(self, node1, node2):  # -> ForeachKernelSchedulerNode | FusedSchedulerNode | OuterLoopFusedSchedulerNode:
        ...
    def can_fuse_horizontal(self, node1, node2):  # -> bool:
        ...
    def can_fuse_multi_outputs_template(self, node1: BaseSchedulerNode, node2: BaseSchedulerNode) -> bool: ...
    def can_fuse_vertical_outer_loop(self, node1, node2):  # -> bool:
        ...
    def get_fusion_pair_priority(self, node1, node2):  # -> Literal[1, 0]:
        ...
    def can_fuse_vertical(self, node1, node2):  # -> bool:
        ...
    def try_loop_split(self, nodes: list[SchedulerNode]):  # -> list[SchedulerNode]:

        ...
    def codegen_outer_loop_node(self, node: OuterLoopFusedSchedulerNode):  # -> None:

        ...
    def codegen_node(self, node: OuterLoopFusedSchedulerNode | FusedSchedulerNode | SchedulerNode):  # -> None:

        ...
    def is_cpp_template(self, node: BaseSchedulerNode) -> bool: ...
    def codegen_template(
        self,
        template_node: BaseSchedulerNode,
        epilogue_nodes: Sequence[BaseSchedulerNode],
        prologue_nodes: Sequence[BaseSchedulerNode],
    ):  # -> None:

        ...
    def ready_to_flush(self):  # -> bool:
        ...
    def codegen_sync(self):  # -> None:
        ...
    def define_kernel(self, src_code, nodes, kernel_args=...):  # -> str:
        ...
    def flush(self):  # -> None:
        ...

class KernelGroup:
    def __init__(self) -> None: ...
    def new_kernel(self, cls, *args): ...
    def finalize_kernel(self, new_kernel, nodes):  # -> None:
        ...
    def get_num_args(self):  # -> int:
        ...
    def codegen_group(self, name=...) -> str: ...
    def call_kernel(self, wrapper, kernel_name, debug_handle: int | None = ...):  # -> None:
        ...

class WorkSharing:
    def __init__(self, code) -> None: ...
    def parallel(self, threads):  # -> None:
        ...
    def single(self):  # -> bool:
        ...
    def close(self):  # -> None:
        ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, exc_type, exc_val, exc_tb):  # -> None:
        ...

@dataclasses.dataclass
class LoopLevel:
    var: sympy.Expr | None = ...
    size: sympy.Expr | None = ...
    offset: sympy.Expr = ...
    tiled_size: sympy.Expr = ...
    steps: sympy.Expr = ...
    parallel: int = ...
    simd_omp: bool = ...
    simd_vec: bool = ...
    collapsed: bool = ...
    is_reduction: bool = ...
    def __post_init__(self):  # -> None:
        ...
    def tile(self, factor):  # -> LoopLevel:
        ...
    def lines(self):  # -> list[str] | None:
        ...

@dataclasses.dataclass
class LoopNest:
    loops: list[LoopLevel] | None = ...
    kernel: CppKernel | None = ...
    @staticmethod
    def build(kernel: CppKernel):  # -> LoopNest:

        ...
    def __bool__(self):  # -> bool:
        ...
    @cache_on_self
    def max_parallel_depth(self):  # -> ParallelDepth:

        ...
    def mark_parallel(self, par_depth):  # -> None:
        ...
    def tile(self, depth, factor): ...
    def get_kernel(self) -> CppKernel: ...
    def set_kernel(self, kernel):  # -> None:
        ...
    def from_loop_level(self, level: int):  # -> LoopNest:
        ...
