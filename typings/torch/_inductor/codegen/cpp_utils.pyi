from collections.abc import Callable
from typing import Any, Optional

import sympy
import torch
from torch.utils._sympy.printers import CppPrinter as _CppPrinter
from torch.utils._sympy.value_ranges import ValueRanges

from .. import ir
from ..scheduler import BaseSchedulerNode
from ..shape_propagation import BlockShapeType
from ..utils import IndentedBuffer
from ..virtualized import V
from .common import CSEVariable, KernelArgs

DTYPE_TO_CPP = ...
DTYPE_TO_ATEN = ...
DEVICE_TO_ATEN = ...
LAYOUT_TO_ATEN = ...
DEVICE_TO_INT = ...
_IS_WINDOWS = ...
INDEX_TYPE = ...
GemmBlocking = ...

def get_promote_dtype(args):  # -> dtype | None:
    ...
def promote_args(new_args):  # -> list[Any | CppCSEVariable]:
    ...

class CppCSEVariable(CSEVariable):
    def __init__(
        self, name, bounds: ValueRanges[Any], dtype: torch.dtype | None = ..., shape: BlockShapeType = ...
    ) -> None: ...
    def update_on_args(self, name, args, kwargs):  # -> None:
        ...
    def depends_on(self, itervar: sympy.Symbol):  # -> bool:
        ...

class CppPrinter(_CppPrinter):
    def doprint(self, expr, *, simplify: bool = ..., p=...): ...
    def parenthesize(self, item: sympy.Expr, level: int, strict: bool = ...) -> str: ...

cexpr = ...

def cexpr_index(index):  # -> str:
    ...
def value_to_cpp(value, cpp_type):  # -> str:
    ...
def rewrite_index_for_function(
    localize_buffer_handler: LocalizeBufferHandler, index: sympy.Expr, global_buf_name: str
): ...
def rewrite_index_for_nodes(
    localize_buffer_handler: LocalizeBufferHandler, index: sympy.Expr, global_buf_name: str
): ...

class LocalizeBufferHandler(V.WrapperHandler):
    def __init__(
        self,
        inner,
        global_to_local: dict[str, ir.Buffer],
        rewrite_index: Callable[[LocalizeBufferHandler, sympy.Expr, str], sympy.Expr],
    ) -> None: ...
    def localize(self, name: str, index: sympy.Expr):  # -> tuple[str, Any]:
        ...
    def load(self, name: str, index: sympy.Expr):  # -> Any:
        ...
    def store(self, name, index, value, mode=...):  # -> None:
        ...
    def store_reduction(self, name, index, value):  # -> None:
        ...

class LocalBufferContext:
    def __init__(self, kernel_args: KernelArgs) -> None: ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, exc_type, exc_val, exc_tb):  # -> None:
        ...
    def add_local_buffer(self, local_buffer: ir.Buffer, global_buffers: list[ir.Buffer] | None = ...):  # -> None:
        ...
    def localize_function(
        self,
        fn: Callable[..., Any],
        rewrite_index: Callable[[LocalizeBufferHandler, sympy.Expr, str], sympy.Expr] = ...,
    ):  # -> Callable[..., Any]:
        ...
    def localize_nodes(
        self,
        nodes: list[ir.IRNode],
        rewrite_index: Callable[[LocalizeBufferHandler, sympy.Expr, str], sympy.Expr] = ...,
    ) -> list[ir.IRNode]: ...

def unify_mask_base_type(
    buffer: IndentedBuffer, vars: tuple[CSEVariable, ...], dtype=...
):  # -> Generator[Any, None, None]:

    ...
def may_unify_binary_op_mask_type(a, b):  # -> Generator[Any, None, None] | tuple[Any, Any]:

    ...
def codegen_rand(offset, code, rand_function, dst_dtype=...): ...
def get_gemm_template_output_and_compute_dtype(input_dtype):  # -> tuple[dtype, dtype]:
    ...
def create_epilogue_with_attr(input_buffer, attr, **kwargs):  # -> Pointwise:
    ...
def template_fusion_with_epilogues_supported(
    template: BaseSchedulerNode, epilogues: list[BaseSchedulerNode]
) -> tuple[bool, bool]: ...
