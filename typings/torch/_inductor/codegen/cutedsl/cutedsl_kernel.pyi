import contextlib
import dataclasses
from collections.abc import Callable
from typing import Any

import sympy
from torch._inductor.codegen.common import CSEVariable, IndentedBuffer, Kernel
from torch._inductor.ir import Buffer
from torch._inductor.ops_handler import StoreMode
from torch._inductor.virtualized import V

MAIN_SUFFIX = ...
log = ...
kernel_code_log = ...

class CuteDSLKernelWrapper:
    def __init__(self, kernel_fn: Callable[..., Any], kernel_path: str | None = ...) -> None: ...
    def run(self, *args, stream=..., **kwargs): ...

@dataclasses.dataclass
class CuteDSLSubgraphInfo:
    body: IndentedBuffer
    template_mask: str | None = ...
    template_out: str | None = ...
    def to_dict(self): ...

class CuteDSLTemplateKernel(Kernel):
    def __init__(
        self, kernel_name: str, input_nodes: list[Buffer], output_node: Buffer, subgraphs: list[Buffer] | None = ...
    ) -> None: ...
    def gen_imports(self) -> str: ...
    def gen_defines(self, **kwargs) -> str: ...
    def render(self, template, **kwargs): ...
    @contextlib.contextmanager
    def set_subgraph_body(self, body_name: str): ...
    @contextlib.contextmanager
    def create_subgraph_body(self, body_name: str): ...
    def def_kernel(self, *argnames): ...
    def get_output(self): ...
    def call_kernel(self, name: str, node=...): ...
    def modification(
        self, subgraph_number: int, output_name: str | None, mask: str | None = ..., **fixed_inputs
    ) -> str: ...

class ModificationWrapperCuteDSL(V.WrapperHandler):
    def __init__(self, kernel, subgraph_number: int, fixed_inputs: dict[str, Any], mask: str | None) -> None: ...
    def load(self, name: str, index: sympy.Expr): ...
    def indirect_indexing(self, index_var: str, size, check, wrap_neg=...): ...
    def store(self, name: str, index: sympy.Expr, value: CSEVariable, mode: StoreMode = ...) -> str: ...
