import dataclasses
from collections.abc import Callable, Sequence
from typing import TYPE_CHECKING, Any, Optional, Union

import sympy
import torch

from ...utils._ordered_set import OrderedSet
from ...utils._sympy.value_ranges import ValueRanges
from ..ops_handler import ReductionType, StoreMode
from ..runtime.hints import HalideMeta
from ..shape_propagation import BlockShapeType
from .common import BackendFeature, CSEVariable, OpOverrides, PythonPrinter
from .simd import SIMDKernel, SIMDScheduling

if TYPE_CHECKING: ...
log = ...

def halide_constant(val):  # -> str:
    ...

class Unsupported(RuntimeError):
    def __init__(self, thing) -> None: ...

class HalidePrinter(PythonPrinter):
    @staticmethod
    def cast_index(expr):  # -> str:
        ...
    @staticmethod
    def cast_float(expr):  # -> str:
        ...

    _print_FloorToInt = ...
    _print_TruncToInt = ...
    _print_RoundToInt = ...

texpr = ...
pexpr = ...
_halide_type = ...

def halide_type(dtype):  # -> str:
    ...
def halide_acc_type(dtype):  # -> str:
    ...

class HalideOverrides(OpOverrides):
    @staticmethod
    def to_dtype(x, dtype: torch.dtype, src_dtype: torch.dtype | None = ..., use_compute_types=...):  # -> str:
        ...
    @staticmethod
    def to_dtype_bitcast(x, dtype: torch.dtype, src_dtype: torch.dtype):  # -> str:
        ...
    @classmethod
    def constant(cls, value, dtype):  # -> str:
        ...
    @staticmethod
    def abs(x):  # -> str:
        ...
    @staticmethod
    def exp(x):  # -> str:
        ...
    @staticmethod
    def sqrt(x):  # -> str:
        ...
    @staticmethod
    def minimum(a, b):  # -> str:
        ...
    @staticmethod
    def maximum(a, b):  # -> str:
        ...
    @staticmethod
    def where(a, b, c):  # -> str:
        ...
    @staticmethod
    def cos(x):  # -> str:
        ...
    @staticmethod
    def sin(x):  # -> str:
        ...
    @staticmethod
    def lgamma(x): ...
    @staticmethod
    def erf(x):  # -> str:
        ...
    @staticmethod
    def cosh(x):  # -> str:
        ...
    @staticmethod
    def sinh(x):  # -> str:
        ...
    @staticmethod
    def acos(x):  # -> str:
        ...
    @staticmethod
    def acosh(x):  # -> str:
        ...
    @staticmethod
    def asin(x):  # -> str:
        ...
    @staticmethod
    def asinh(x):  # -> str:
        ...
    @staticmethod
    def atan2(x, y):  # -> str:
        ...
    @staticmethod
    def atan(x):  # -> str:
        ...
    @staticmethod
    def atanh(x):  # -> str:
        ...
    @staticmethod
    def copysign(x, y): ...
    @staticmethod
    def erfinv(x): ...
    @staticmethod
    def hypot(x, y):  # -> str:
        ...
    @staticmethod
    def nextafter(x, y): ...
    @staticmethod
    def logical_and(a, b):  # -> str:
        ...
    @staticmethod
    def logical_not(a):  # -> str:
        ...
    @staticmethod
    def logical_or(a, b):  # -> str:
        ...
    @staticmethod
    def logical_xor(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_and(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_not(a):  # -> str:
        ...
    @staticmethod
    def bitwise_or(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_xor(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_left_shift(a, b):  # -> str:
        ...
    @staticmethod
    def bitwise_right_shift(a, b):  # -> str:
        ...
    @staticmethod
    def rand(seed, offset):  # -> str:
        ...
    @staticmethod
    def randn(seed, offset):  # -> str:
        ...
    @staticmethod
    def randint64(seed, offset, low, high):  # -> str:
        ...
    @staticmethod
    def load_seed(name, offset):  # -> str:
        ...
    @staticmethod
    def rsqrt(x):  # -> str:
        ...
    @staticmethod
    def tan(x):  # -> str:
        ...
    @staticmethod
    def tanh(x):  # -> str:
        ...
    @staticmethod
    def signbit(x):  # -> str:
        ...
    @staticmethod
    def fmod(a, b):  # -> str:
        ...
    @staticmethod
    def pow(a, b):  # -> str:
        ...
    @staticmethod
    def log(x):  # -> str:
        ...
    @staticmethod
    def log2(x): ...
    @staticmethod
    def isinf(x):  # -> str:
        ...
    @staticmethod
    def isnan(x):  # -> str:
        ...
    @staticmethod
    def round(x):  # -> str:
        ...
    @staticmethod
    def floor(x):  # -> str:
        ...
    @staticmethod
    def int_truediv(a, b):  # -> str:
        ...
    @staticmethod
    def floordiv(a, b):  # -> str:
        ...
    @classmethod
    def sign(cls, x):  # -> str:
        ...
    @staticmethod
    def trunc(x):  # -> str:
        ...
    @staticmethod
    def truncdiv(a, b):  # -> str:
        ...
    @staticmethod
    def ceil(x):  # -> str:
        ...
    @staticmethod
    def relu(x):  # -> str:
        ...
    @classmethod
    def index_expr(cls, expr, dtype):  # -> Any:
        ...
    @classmethod
    def indirect_indexing(cls, index_var, size, check=..., wrap_neg=...): ...
    @classmethod
    def halide_clamp(cls, value, size, check):  # -> str:
        ...
    @staticmethod
    def masked(mask, body, other):  # -> Any:
        ...
    @staticmethod
    def frexp(x): ...
    @staticmethod
    def device_assert_async(cond, msg): ...

class HalideCSEVariable(CSEVariable):
    undefined_re = ...
    def __init__(
        self, name, bounds: ValueRanges[Any], dtype: torch.dtype | None = ..., shape: BlockShapeType = ...
    ) -> None: ...
    def update_on_args(self, name, args, kwargs):  # -> None:
        ...
    def index_str(self, dims):  # -> str:
        ...
    def subs_str(self, replacements):  # -> str:
        ...

@dataclasses.dataclass
class DimensionInfo:
    expr: sympy.Expr | None
    size: sympy.Expr
    stride: sympy.Expr
    def __init__(self, expr, size, stride) -> None: ...
    def index_str(self, replacements=..., zero_vars=...):  # -> Literal['hl.Var()']:
        ...

def eq(left, right):  # -> bool:
    ...
def lt(left, right):  # -> bool:
    ...

class HalideKernel(SIMDKernel):
    overrides = HalideOverrides
    kexpr: Callable[[sympy.Expr], str] = ...
    def __init__(self, tiling: dict[str, sympy.Expr], **kwargs) -> None: ...
    def dtype_to_str(self, dtype: torch.dtype) -> str: ...
    def create_cse_var(self, name, bounds=..., dtype=..., shape=...):  # -> HalideCSEVariable:
        ...
    def finalize_indexing(self, indices: Sequence[sympy.Expr]):  # -> None:

        ...
    def setup_dom_indexing(self):  # -> dict[Any, Any]:

        ...
    def codegen_rdom(self, name, vars):  # -> None:
        ...
    def prepare_indexing(self, index: sympy.Expr): ...
    def sym_size(self, sym): ...
    def indexing_to_dimensions(self, var: str, index: sympy.Expr, is_store: bool):  # -> tuple[str, list[Any]] | None:

        ...
    def install_dims(self, var, dims, offset, is_store):  # -> bool:

        ...
    def apply_offset_to_dimension(self, dims, offset):  # -> None:
        ...
    def used_dims_from_index(self, index: sympy.Expr):  # -> list[Any]:

        ...
    def sort_used_dims(self, used_dims):  # -> list[Any]:
        ...
    def make_index_str(self, dims, replacements=..., zero_vars=...):  # -> LiteralString | Literal['()']:
        ...
    def load(self, name: str, index: sympy.Expr):  # -> HalideCSEVariable:

        ...
    def lookup_cse_var(self, name: str):  # -> CSEVariable:
        ...
    def store(self, name: str, index: sympy.Expr, value: CSEVariable, mode: StoreMode = ...) -> None: ...
    def reduction(
        self,
        dtype: torch.dtype,
        src_dtype: torch.dtype,
        reduction_type: ReductionType,
        value: CSEVariable | tuple[CSEVariable, ...],
    ) -> CSEVariable | tuple[CSEVariable, ...]: ...
    def welford_combine_impl(self, mean, m2, weight):  # -> tuple[Any, ...]:
        ...
    def scan(
        self,
        dtypes: tuple[torch.dtype, ...],
        combine_fn: Callable[[tuple[CSEVariable, ...], tuple[CSEVariable, ...]], tuple[CSEVariable, ...]],
        values_orig: tuple[CSEVariable, ...],
    ) -> tuple[CSEVariable, ...]: ...
    def genfunc(self, line, used_dims, *, bounds=..., shape: BlockShapeType = ...) -> HalideCSEVariable: ...
    def newfunc(self, used_dims, *, shape: BlockShapeType = ...) -> HalideCSEVariable: ...
    def halide_buffer_numel(self, name: str):  # -> Any:

        ...
    def halide_argdefs(self):  # -> list[tuple[str | None, KernelArgType]]:

        ...
    def halide_kernel_meta(self) -> HalideMeta: ...
    def codegen_kernel(self, name=...):  # -> str:

        ...
    def call_kernel(self, name: str, node=...):  # -> None:

        ...
    def generate_assert(self, check):  # -> Literal[False]:
        ...
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool):  # -> None:
        ...

class HalideScheduling(SIMDScheduling):
    kernel_type = ...
    @classmethod
    def get_backend_features(cls, device: torch.device) -> OrderedSet[BackendFeature]: ...
    def define_kernel(self, src_code, node_schedule, kernel):  # -> str:

        ...
