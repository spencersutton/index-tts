import dataclasses
import sympy
import torch
from typing import Any, Optional, Protocol, TYPE_CHECKING
from ..utils import CachedMethod, IndentedBuffer, cache_on_self
from .wrapper import BufferLike, MemoryPlanningLine
from collections.abc import Iterable

if TYPE_CHECKING: ...

@dataclasses.dataclass
class LiveRange:
    begin: float
    end: float
    def contains(self, other: LiveRange):  # -> bool:

        ...
    def join(self, other: LiveRange):  # -> LiveRange:

        ...
    def __len__(self):  # -> float:
        ...

class LiveRanges:
    def __init__(self, ranges: Iterable[LiveRange]) -> None: ...
    def overlaps(self, other: LiveRanges):  # -> bool:

        ...
    @property
    def begin(self):  # -> float:
        ...
    @property
    def end(self):  # -> float:
        ...
    def __repr__(self):  # -> str:
        ...

class AllocationTreeNode:
    def allocate(self, block: Allocation, is_last: bool) -> bool: ...
    def get_live_ranges(self) -> LiveRanges: ...
    def get_size_hint(self) -> int: ...
    def get_symbolic_size(self) -> sympy.Expr: ...
    def finalize(self, pool, offset) -> AllocationTreeNode: ...
    def is_empty(self):  # -> Literal[False]:
        ...

@dataclasses.dataclass
class Allocation(AllocationTreeNode):
    node: BufferLike
    live_range: LiveRange
    size_hint: int
    symbolic_size: sympy.Expr
    allocated: bool = ...
    pool: Optional[AllocationPool] = ...
    offset: Optional[sympy.Expr] = ...
    earliest_available: Optional[float] = ...
    def __post_init__(self) -> None: ...
    @property
    def device(self):  # -> BufferLike:
        ...
    def get_live_ranges(self):  # -> LiveRanges:
        ...
    def get_size_hint(self):  # -> int:
        ...
    def get_symbolic_size(self): ...
    def mark_allocated(self):  # -> None:
        ...
    def finalize(self, pool, offset):  # -> Self:
        ...
    def codegen_alloc_from_pool(self, wrapper): ...
    def __repr__(self):  # -> str:
        ...
    def get_earliest_available(self):  # -> float | None:
        ...

@dataclasses.dataclass
class Empty(AllocationTreeNode):
    size_hint: int
    def get_live_ranges(self):  # -> LiveRanges:
        ...
    def get_size_hint(self):  # -> int:
        ...
    def get_symbolic_size(self):  # -> Literal[0]:
        ...
    def is_empty(self):  # -> Literal[True]:
        ...

class MemorySplitProtocol(Protocol):
    get_live_ranges: CachedMethod[[], LiveRanges]
    get_size_hint: CachedMethod[[], int]
    get_symbolic_size: CachedMethod[[], sympy.Expr]

class ClearCacheOnAllocateMixin(MemorySplitProtocol):
    def allocate(self, block: Allocation, is_last: bool):  # -> bool:
        ...
    def clear_cache(self):  # -> None:
        ...

@dataclasses.dataclass
class TemporalSplit(ClearCacheOnAllocateMixin, AllocationTreeNode):
    allocations: list[AllocationTreeNode]
    @cache_on_self
    def get_live_ranges(self) -> LiveRanges: ...
    @cache_on_self
    def get_size_hint(self) -> int: ...
    @cache_on_self
    def get_symbolic_size(self) -> sympy.Expr: ...
    def is_empty(self):  # -> Literal[False]:
        ...
    def finalize(self, pool, offset):  # -> AllocationTreeNode | Self:
        ...

@dataclasses.dataclass
class SpatialSplit(ClearCacheOnAllocateMixin, AllocationTreeNode):
    left: TemporalSplit
    right: TemporalSplit
    @staticmethod
    def create(left, extra_space):  # -> SpatialSplit:
        ...
    @cache_on_self
    def get_live_ranges(self):  # -> LiveRanges:
        ...
    @cache_on_self
    def get_size_hint(self) -> int: ...
    @cache_on_self
    def get_symbolic_size(self) -> sympy.Expr: ...
    def finalize(self, pool, offset):  # -> TemporalSplit | Self:
        ...

@dataclasses.dataclass
class AllocationPool:
    device: torch.device
    root: TemporalSplit
    can_expand: bool = ...
    restrict_live_range: Optional[LiveRange] = ...
    name: Optional[str] = ...
    names_to_del: list[str] = ...
    creation_cache: dict[str, str] = ...
    def __post_init__(self) -> None: ...
    def allocate(self, block: Allocation, is_last: bool):  # -> bool:
        ...
    def update_restrict_live_range(self, block: Allocation):  # -> None:
        ...
    def allocate_at_end(self, block):  # -> Literal[True]:
        ...
    def finalize(self, name):  # -> None:
        ...
    def codegen_create(self, wrapper, code: IndentedBuffer):  # -> None:
        ...
    def codegen_destroy(self, wrapper, code: IndentedBuffer):  # -> None:
        ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

@dataclasses.dataclass
class AllocationPools:
    device_to_pools: dict[torch.device, list[AllocationPool]] = ...
    def get_pools(self, block):  # -> list[AllocationPool]:
        ...
    def allocate(self, block: Allocation):  # -> None:
        ...
    def allocate_output(self, block: Allocation):  # -> None:

        ...
    def finalize(self):  # -> None:

        ...
    def pprint(self):  # -> None:
        ...

class BufferGroup:
    def __init__(self, node: BufferLike) -> None: ...
    def update_usage(self, timestep: int):  # -> None:

        ...
    def sym_nbytes(self):  # -> Any:
        ...
    def make_allocation(self):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

@dataclasses.dataclass
class PoolMemoryPlanningLine(MemoryPlanningLine):
    group: BufferGroup
    timestep: Optional[int] = ...
    @property
    def node(self):  # -> BufferLike:
        ...

@dataclasses.dataclass
class AllocFromPoolLine(PoolMemoryPlanningLine):
    is_first_pool_usage: bool = ...
    def codegen(self, code: IndentedBuffer):  # -> None:
        ...

@dataclasses.dataclass
class DeallocFromPoolLine(PoolMemoryPlanningLine):
    is_last_pool_usage: bool = ...
    def codegen(self, code: IndentedBuffer):  # -> None:
        ...

@dataclasses.dataclass
class MemoryPlanner:
    wrapper: Any
    pools: AllocationPools = ...
    buffer_groups: Optional[list[BufferGroup]] = ...
    def plan(self, lines: list[Any]) -> list[Any]: ...
    def drop_removed_buffers(self, lines):  # -> None:

        ...
    def compute_buffer_groups(self, lines):  # -> dict[Any, Any]:

        ...
    def convert_to_pool_lines(self, lines):  # -> None:

        ...
    def compute_live_ranges(self, lines):  # -> None:

        ...
    def allocate_groups(self):  # -> None:

        ...
    def mark_first_last_usage(self, lines):  # -> None:

        ...
