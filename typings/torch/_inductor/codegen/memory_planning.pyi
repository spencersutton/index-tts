import dataclasses
from collections.abc import Iterable
from typing import Any, Protocol

import sympy
import torch

from ..utils import CachedMethod, IndentedBuffer, cache_on_self
from .wrapper import BufferLike, MemoryPlanningLine

@dataclasses.dataclass
class LiveRange:
    begin: float
    end: float
    def contains(self, other: LiveRange): ...
    def join(self, other: LiveRange): ...
    def __len__(self) -> int: ...

class LiveRanges:
    def __init__(self, ranges: Iterable[LiveRange]) -> None: ...
    def overlaps(self, other: LiveRanges): ...
    @property
    def begin(self): ...
    @property
    def end(self): ...

class AllocationTreeNode:
    def allocate(self, block: Allocation, is_last: bool) -> bool: ...
    def get_live_ranges(self) -> LiveRanges: ...
    def get_size_hint(self) -> int: ...
    def get_symbolic_size(self) -> sympy.Expr: ...
    def finalize(self, pool, offset) -> AllocationTreeNode: ...
    def is_empty(self): ...

@dataclasses.dataclass
class Allocation(AllocationTreeNode):
    node: BufferLike
    live_range: LiveRange
    size_hint: int
    symbolic_size: sympy.Expr
    allocated: bool = ...
    pool: AllocationPool | None = ...
    offset: sympy.Expr | None = ...
    earliest_available: float | None = ...
    def __post_init__(self) -> None: ...
    @property
    def device(self): ...
    def get_live_ranges(self): ...
    def get_size_hint(self): ...
    def get_symbolic_size(self): ...
    def mark_allocated(self): ...
    def finalize(self, pool, offset): ...
    def codegen_alloc_from_pool(self, wrapper): ...
    def get_earliest_available(self): ...
    def get_earliest_available(self): ...

@dataclasses.dataclass
class Empty(AllocationTreeNode):
    size_hint: int
    def get_live_ranges(self): ...
    def get_size_hint(self): ...
    def get_symbolic_size(self): ...
    def is_empty(self): ...

class MemorySplitProtocol(Protocol):
    get_live_ranges: CachedMethod[[], LiveRanges]
    get_size_hint: CachedMethod[[], int]
    get_symbolic_size: CachedMethod[[], sympy.Expr]

class ClearCacheOnAllocateMixin(MemorySplitProtocol):
    def allocate(self, block: Allocation, is_last: bool): ...
    def clear_cache(self): ...

@dataclasses.dataclass
class TemporalSplit(ClearCacheOnAllocateMixin, AllocationTreeNode):
    allocations: list[AllocationTreeNode]
    @cache_on_self
    def get_live_ranges(self) -> LiveRanges: ...
    @cache_on_self
    def get_size_hint(self) -> int: ...
    @cache_on_self
    def get_symbolic_size(self) -> sympy.Expr: ...
    def is_empty(self): ...
    def finalize(self, pool, offset): ...

@dataclasses.dataclass
class SpatialSplit(ClearCacheOnAllocateMixin, AllocationTreeNode):
    left: TemporalSplit
    right: TemporalSplit
    @staticmethod
    def create(left, extra_space): ...
    @cache_on_self
    def get_live_ranges(self): ...
    @cache_on_self
    def get_size_hint(self) -> int: ...
    @cache_on_self
    def get_symbolic_size(self) -> sympy.Expr: ...
    def finalize(self, pool, offset): ...

@dataclasses.dataclass
class AllocationPool:
    device: torch.device
    root: TemporalSplit
    can_expand: bool = ...
    restrict_live_range: LiveRange | None = ...
    name: str | None = ...
    names_to_del: list[str] = ...
    creation_cache: dict[str, str] = ...
    def __post_init__(self) -> None: ...
    def allocate(self, block: Allocation, is_last: bool): ...
    def update_restrict_live_range(self, block: Allocation): ...
    def allocate_at_end(self, block): ...
    def finalize(self, name): ...
    def codegen_create(self, wrapper, code: IndentedBuffer): ...
    def codegen_destroy(self, wrapper, code: IndentedBuffer): ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

@dataclasses.dataclass
class AllocationPools:
    device_to_pools: dict[torch.device, list[AllocationPool]] = ...
    def get_pools(self, block): ...
    def allocate(self, block: Allocation): ...
    def allocate_output(self, block: Allocation): ...
    def finalize(self): ...
    def pprint(self): ...

class BufferGroup:
    def __init__(self, node: BufferLike) -> None: ...
    def update_usage(self, timestep: int): ...
    def sym_nbytes(self): ...
    def make_allocation(self): ...

@dataclasses.dataclass
class PoolMemoryPlanningLine(MemoryPlanningLine):
    group: BufferGroup
    timestep: int | None = ...
    @property
    def node(self): ...

@dataclasses.dataclass
class AllocFromPoolLine(PoolMemoryPlanningLine):
    is_first_pool_usage: bool = ...
    def codegen(self, code: IndentedBuffer): ...

@dataclasses.dataclass
class DeallocFromPoolLine(PoolMemoryPlanningLine):
    is_last_pool_usage: bool = ...
    def codegen(self, code: IndentedBuffer): ...

@dataclasses.dataclass
class MemoryPlanner:
    wrapper: Any
    pools: AllocationPools = ...
    buffer_groups: list[BufferGroup] | None = ...
    def plan(self, lines: list[Any]) -> list[Any]: ...
    def drop_removed_buffers(self, lines): ...
    def compute_buffer_groups(self, lines): ...
    def convert_to_pool_lines(self, lines): ...
    def compute_live_ranges(self, lines): ...
    def allocate_groups(self): ...
    def mark_first_last_usage(self, lines): ...
