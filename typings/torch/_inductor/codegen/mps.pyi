from typing import Any

import sympy
import torch
from torch.utils._ordered_set import OrderedSet
from torch.utils._sympy.printers import ExprPrinter as ExprPrinter_

from ..ops_handler import ReductionType, StoreMode
from ..scheduler import Scheduler, SchedulerNode
from .common import CSEVariable, OpOverrides, OpVarT
from .simd import IterationRangesEntry, SIMDKernel, SIMDScheduling

log = ...
DTYPE_TO_METAL = ...

def value_to_metal(val: float | bool | str | CSEVariable) -> str: ...

class MetalExprPrinter(ExprPrinter_):
    """Converts sympy expression to Metal code snippet"""

    _print_floor = ...

class MetalOverrides(OpOverrides):
    """Implements Metal-specific overrides for ops. Base class emits Python-friendly overrides."""
    @staticmethod
    def to_dtype(
        x: CSEVariable, dtype: torch.dtype, src_dtype: torch.dtype | None = ..., use_compute_types: bool = ...
    ) -> str: ...
    @staticmethod
    def to_dtype_bitcast(x: CSEVariable, dtype: torch.dtype, src_dtype: torch.dtype) -> str: ...
    @staticmethod
    def constant(val: bool | float, dtype: torch.dtype) -> str: ...
    @staticmethod
    def index_expr(expr: sympy.Expr, dtype: torch.dtype) -> str: ...
    @staticmethod
    def masked(mask: CSEVariable, body: sympy.Expr, other: CSEVariable) -> str: ...
    @staticmethod
    def where(a: OpVarT, b: OpVarT, c: OpVarT) -> str: ...
    @staticmethod
    def remainder(a: OpVarT, b: OpVarT) -> str: ...
    @staticmethod
    def maximum(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def minimum(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def logical_or(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def logical_and(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def isnan(x: CSEVariable) -> str: ...
    @staticmethod
    def isinf(x: CSEVariable) -> str: ...
    @staticmethod
    def log(x: CSEVariable) -> str: ...
    @staticmethod
    def exp(x: CSEVariable) -> str: ...
    @staticmethod
    def abs(x: CSEVariable) -> str: ...
    @staticmethod
    def signbit(x: CSEVariable) -> str: ...
    @staticmethod
    def sin(x: CSEVariable) -> str: ...
    @staticmethod
    def sinc(x: CSEVariable) -> str: ...
    @staticmethod
    def cos(x: CSEVariable) -> str: ...
    @staticmethod
    def tan(x: CSEVariable) -> str: ...
    @staticmethod
    def asin(x: CSEVariable) -> str: ...
    @staticmethod
    def acos(x: CSEVariable) -> str: ...
    @staticmethod
    def atan(x: CSEVariable) -> str: ...
    @staticmethod
    def atan2(x: CSEVariable, y: CSEVariable) -> str: ...
    @staticmethod
    def sqrt(x: CSEVariable) -> str: ...
    @staticmethod
    def neg(x: CSEVariable) -> str: ...
    @staticmethod
    def rsqrt(x: CSEVariable) -> str: ...
    @staticmethod
    def tanh(x: CSEVariable) -> str: ...
    @staticmethod
    def atanh(x: CSEVariable) -> str: ...
    @staticmethod
    def floordiv(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def floor(x: CSEVariable) -> str: ...
    @staticmethod
    def sign(x: CSEVariable) -> str: ...
    @staticmethod
    def fmod(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def trunc(x: CSEVariable) -> str: ...
    @staticmethod
    def truncdiv(a: CSEVariable, b: CSEVariable) -> str: ...
    @staticmethod
    def ceil(x: CSEVariable) -> str: ...
    @staticmethod
    def rand(seed: CSEVariable, offset: CSEVariable) -> str: ...
    @staticmethod
    def randn(seed: CSEVariable, offset: CSEVariable) -> str: ...
    @staticmethod
    def randint64(seed: CSEVariable, offset: CSEVariable, low: CSEVariable, high: CSEVariable) -> str: ...
    @staticmethod
    def round(x: CSEVariable) -> str: ...
    @staticmethod
    def pow(a: CSEVariable, b: CSEVariable) -> str: ...

class MetalKernel(SIMDKernel):
    """Implement Metal codegen based on the SIMDKernel abstraction"""

    overrides = MetalOverrides
    suffix = ...
    newvar_prefix = ...
    max_threadgroup_size = ...
    simd_group_size = ...
    pexpr = ...
    cexpr = ...
    sexpr = ...
    kexpr = ...
    headers: OrderedSet[str] = ...
    multistage_reduction_entry: list[IterationRangesEntry] = ...
    def __init__(self, tiling: dict[str, sympy.Expr], **kwargs: Any) -> None: ...
    def dtype_to_str(self, dtype: torch.dtype) -> str: ...
    def load(self, name: str, index: sympy.Expr) -> CSEVariable:
        """Codegen a load from an InputBuffer"""
    def store(self, name: str, index: sympy.Expr, value: CSEVariable, mode: StoreMode = ...) -> None: ...
    def store_reduction(self, name: str, index: sympy.Expr, value: CSEVariable) -> None: ...
    def reduction(
        self,
        dtype: torch.dtype,
        src_dtype: torch.dtype,
        reduction_type: ReductionType,
        value: CSEVariable | tuple[CSEVariable, ...],
    ) -> CSEVariable | tuple[CSEVariable, ...]:
        """Caching wrapper around _reduction_nocache"""
    def codegen_iteration_ranges_entry(self, entry: IterationRangesEntry) -> None: ...
    def codegen_body(self) -> None:
        """
        Concat output code from index_code, loads, compute, stores,
        suffix into self.body.

        For pointwise kernels, this is called just once at the end.

        For reduction kernels, this generates a loop over the reduction
        axis.
        """
    def codegen_kernel(self, name: str | None = ...) -> str:
        """Called at the end to generate a final kernel string"""
    def call_kernel(self, name: str, node: Any = ...) -> None:
        """Codegens a call to this kernel"""
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool) -> None: ...

class MetalScheduling(SIMDScheduling):
    kernel_type = ...
    def __init__(self, scheduler: Scheduler | None) -> None: ...
    def define_kernel(self, src_code: str, node_schedule: list[SchedulerNode], kernel: MetalKernel) -> str: ...
