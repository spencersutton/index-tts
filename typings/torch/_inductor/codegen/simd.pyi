import contextlib
import dataclasses
import functools
import sympy
import torch
from typing import Any, Generic, Optional, TYPE_CHECKING, Union, no_type_check
from collections.abc import Callable
from typing import TypeVar
from torch._inductor.tiling_utils import CoalesceVarAnalysis
from torch.fx.immutable_collections import immutable_dict
from torch.utils._sympy.symbol import SymT
from .. import ir, scheduler
from ..ir import IRNode
from ..scheduler import BaseSchedulerNode, BaseScheduling
from ..utils import cache_on_self
from ..virtualized import OpsWrapper
from .common import CSEVariable, Kernel
from .simd_kernel_features import NodeScheduleEntry, SIMDKernelFeatures
from collections.abc import Iterable, Iterator, Sequence

if TYPE_CHECKING: ...
if TYPE_CHECKING: ...
log = ...
perf_hint_log = ...
schedule_log = ...
fusion_log = ...
pexpr = ...
all_prefixes = ...

def get_max_tiles(default: int = ...) -> int: ...

@dataclasses.dataclass
class IterationRanges:
    def __init__(
        self,
        name: str,
        var_list: list[sympy.Symbol],
        var_ranges: dict[sympy.Symbol, sympy.Expr],
        numel: sympy.Expr,
        prefix: str,
        *,
        kernel: SIMDKernel,
        divisor=...,
        length=...,
        root: IterationRangesRoot,
    ) -> None: ...
    @property
    @cache_on_self
    @no_type_check
    def is_reduction(self) -> bool: ...
    def symbol(self) -> sympy.Symbol: ...
    @property
    @cache_on_self
    @no_type_check
    def symt(self) -> SymT: ...

class IterationRangesRoot(IterationRanges):
    def __init__(
        self,
        name: str,
        numel: sympy.Expr,
        prefix: str,
        index: int,
        kernel: SIMDKernel,
        pid_cache: dict[str, str] | None = ...,
        *,
        is_loop: bool,
        tensor_dim: int | None,
        grid_dim: int | None,
        has_zdim: bool,
    ) -> None: ...
    def cache_clear(self) -> None: ...
    def index_sym(self) -> sympy.Symbol: ...
    def lookup(self, divisor: sympy.Expr, length: sympy.Expr) -> IterationRangesEntry: ...
    def construct_entries(self, lengths: list[sympy.Expr]) -> list[IterationRangesEntry]: ...
    def construct(self, lengths: list[sympy.Expr]) -> list[sympy.Symbol]: ...
    def vars_and_sizes(self, index: sympy.Expr) -> tuple[list[sympy.Symbol], list[sympy.Expr]]: ...

class IterationRangesEntry(IterationRanges):
    def __init__(
        self, name: str, divisor: sympy.Expr, length: sympy.Expr, expr: sympy.Expr, parent: IterationRanges
    ) -> None: ...
    def set_name(self, name: str) -> None: ...
    def cache_clear(self) -> None: ...
    def precomputed_args(self) -> list[sympy.Expr]: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...

def constant_repr(value: float) -> str: ...

CSEVariableType = TypeVar("CSEVariableType", bound=CSEVariable, default=CSEVariable)

class SIMDKernel(Kernel[CSEVariableType], Generic[CSEVariableType]):
    sexpr: Callable[[sympy.Expr], str] = ...
    kexpr: Callable[[sympy.Expr], str]
    allow_block_ptr: bool = ...
    kernel_name: str
    def __init__(
        self,
        tiling: dict[str, sympy.Expr],
        features: SIMDKernelFeatures,
        pid_cache: dict[str, str] | None = ...,
        override_persistent_reduction: bool | None = ...,
        override_cooperative_reduction: bool | None = ...,
        tiling_scores: dict[str, sympy.Expr] | None = ...,
    ) -> None: ...
    @property
    @cache_on_self
    @no_type_check
    def num_reduction_dims(self) -> int: ...
    def dtype_to_str(self, dtype: torch.dtype) -> str: ...
    def get_index_dtype_as_torch_dtype(self) -> torch.dtype: ...
    @property
    def index_dtype(self) -> str: ...
    def want_no_x_dim(self) -> bool: ...
    def construct_range_trees(
        self,
        pid_cache: dict[str, str] | None,
        inside_reduction: bool,
        is_reduction: bool,
        numels: dict[str, sympy.Expr],
        no_x_dim: bool,
    ) -> list[IterationRangesRoot]: ...
    def initialize_range_tree(self, pid_cache: dict[str, str]) -> None: ...
    def finalize_indexing(self, indices: Sequence[sympy.Expr]) -> None: ...
    def store_reduction(self, name: str, index: sympy.Expr, value: CSEVariable) -> None: ...
    def should_use_cooperative_reduction(self) -> bool: ...
    def should_use_persistent_reduction(self) -> bool: ...
    def var_ranges(self) -> dict[sympy.Symbol, sympy.Expr]: ...
    def triton_tensor_ndim(self) -> int: ...
    def indexing_size_str(self, i: int) -> str: ...
    def dense_size_list(self) -> list[str]: ...
    def dense_size_str(self) -> str: ...
    def combine_modular_indexing_pairs(self, index: sympy.Expr) -> sympy.Expr: ...
    def combine_contiguous_dims(self, index: sympy.Expr, tree: IterationRangesRoot) -> sympy.Expr: ...
    def disable_reduction(self) -> contextlib.AbstractContextManager[None]: ...
    def set_ranges(self, *lengths: sympy.Expr) -> list[sympy.Symbol]: ...
    @classmethod
    def prepare_split_iteration_lengths(
        cls, groups: Iterable[sympy.Expr], lengths: Sequence[Sequence[sympy.Expr]], reduction_numel: sympy.Expr = ...
    ) -> Sequence[Sequence[sympy.Expr]]: ...
    @classmethod
    def is_compatible(
        cls, groups: Iterable[sympy.Expr], lengths: Sequence[Sequence[sympy.Expr]], reduction_numel: sympy.Expr = ...
    ) -> bool: ...
    def split_and_set_ranges(self, lengths: Sequence[Sequence[sympy.Expr]]) -> list[list[sympy.Expr]]: ...
    @classmethod
    def map_kernel_groups_to_node_sizes(
        cls, groups: Sequence[sympy.Expr], lengths: Sequence[Sequence[sympy.Expr]], set_ranges
    ) -> list[list[sympy.Expr]]: ...
    def is_indirect_indexing(self, index: sympy.Expr) -> bool: ...
    def is_broadcasted(self, index: sympy.Expr) -> bool: ...
    def index_to_str(self, index: sympy.Expr) -> str: ...
    def prepare_indexing(self, index: sympy.Expr) -> sympy.Expr: ...
    def active_range_trees(self) -> list[IterationRangesRoot]: ...
    def codegen_indexing(self, expr: sympy.Expr) -> sympy.Expr: ...
    def codegen_nan_check(self) -> None: ...
    def call_kernel(self, name: str, node: IRNode | None = ...) -> None: ...
    @contextlib.contextmanager
    def mask_loads(self, mask: str | OpsWrapper, value: float) -> Iterator[str]: ...
    def get_strides_of_load(self, index: sympy.Expr) -> dict[sympy.Symbol, sympy.Expr]: ...
    def estimate_flops(self) -> int | None: ...
    def estimate_kernel_num_bytes(self):  # -> int:

        ...
    def warn_mix_layout(self, kernel_name):  # -> None:

        ...
    def welford_reduce_fallback(self, dtype, value): ...
    def prepare_softmax_twopass_fallback(self, dtype, value): ...
    def codegen_kernel(self): ...
    def codegen_body(self):  # -> None:
        ...
    def codegen_iteration_ranges_entry(self, entry: IterationRangesEntry):  # -> None:
        ...

class SIMDScheduling(BaseScheduling):
    kernel_type: type[Any] = ...
    def group_fn(self, sizes):  # -> tuple[Any, ...]:
        ...
    def can_fuse(self, node1, node2): ...

    can_fuse_vertical = ...
    can_fuse_horizontal = ...
    def generate_node_schedule(self, nodes, numel, rnumel):  # -> list[Any]:
        ...
    def codegen_node(self, node: scheduler.FusedSchedulerNode | scheduler.SchedulerNode):  # -> None:

        ...
    @staticmethod
    def can_use_32bit_indexing(
        numel: sympy.Expr, buffers: Iterable[ir.Buffer | ir.TensorBox | ir.TorchBindObject | ir.IRNode]
    ) -> bool: ...
    def codegen_node_schedule(self, kernel_features: SIMDKernelFeatures):  # -> None:
        ...
    def create_kernel_choices(
        self, kernel_features: SIMDKernelFeatures, kernel_args, kernel_kwargs
    ) -> list[SIMDKernel]: ...
    def codegen_node_schedule_with_kernel(self, node_schedule, kernel):  # -> None:
        ...
    def codegen_template(
        self,
        template_node,
        epilogue_nodes,
        prologue_nodes,
        *,
        only_gen_src_code=...,
        hint_override: int | None = ...,
    ) -> str | None: ...
    def codegen_sync(self):  # -> None:
        ...
    def generate_combo_kernel_code(
        self,
        subkernel_nodes: list[BaseSchedulerNode],
        custom_part_algorithm: bool,
        enable_autotune: bool,
        mixed_sizes: bool,
        only_gen_src_code: bool = ...,
    ) -> list[tuple[str, Any, Any]]: ...
    def codegen_combo_kernel(self, combo_kernel_node):  # -> None:
        ...
    @classmethod
    @functools.lru_cache(32)
    def candidate_tilings(cls, node, numel, reduction_numel) -> list[CandidateTiling]: ...
    @classmethod
    def create_tiling(
        cls, pw_tiling: Sequence[sympy.Expr], reduction_tiling: Sequence[sympy.Expr]
    ) -> immutable_dict[str, sympy.Expr]: ...
    @classmethod
    def create_partial_tiling(
        cls, tiling: Sequence[sympy.Expr], is_pointwise: bool
    ) -> immutable_dict[str, sympy.Expr]: ...
    @classmethod
    def complete_partial_tiling(
        cls, tiling: dict[str, sympy.Expr], numel: sympy.Expr, reduction_numel: sympy.Expr
    ) -> immutable_dict[str, sympy.Expr]: ...
    @classmethod
    def get_nd_tilings(
        cls, node_schedule, pointwise_numel, reduction_numel
    ) -> list[immutable_dict[str, sympy.Expr]]: ...
    @classmethod
    def compute_tiling_strategy(
        cls,
        node_schedule: list[NodeScheduleEntry],
        pointwise_numel: sympy.Expr,
        reduction_numel: sympy.Expr,
        coalesce_analysis: CoalesceVarAnalysis,
    ) -> tuple[dict[str, sympy.Expr], dict[str, sympy.Expr] | None]: ...
    @classmethod
    def tiling_is_compatible(
        cls,
        node_schedule: list[NodeScheduleEntry],
        numel: sympy.Expr,
        reduction_numel: sympy.Expr,
        tiling: dict[str, sympy.Expr],
    ):  # -> bool:
        ...
    @classmethod
    def get_first_compatible_tiling(
        cls,
        node_schedule: list[NodeScheduleEntry],
        numel: sympy.Expr,
        reduction_numel: sympy.Expr,
        ranked_tilings: list[dict[str, sympy.Expr]],
    ):  # -> dict[str, Any] | None:
        ...
    @classmethod
    def select_tiling(
        cls, node_schedule, numel, reduction_numel=..., coalesce_analysis: CoalesceVarAnalysis | None = ...
    ) -> dict[str, sympy.Expr]: ...
    @classmethod
    def get_tiling_and_scores(
        cls, node_schedule, numel, reduction_numel=..., coalesce_analysis: CoalesceVarAnalysis | None = ...
    ) -> tuple[dict[str, sympy.Expr], dict[str, sympy.Expr] | None]: ...
    def flush(self):  # -> None:
        ...
    def ready_to_flush(self) -> bool: ...
    def generate_kernel_code_from_nodes(
        self, nodes, benchmark_kernel=..., hint_override: int | None = ...
    ):  # -> str | Any:
        ...
    def codegen_comment(self, node_schedule):  # -> None:
        ...
    def define_kernel(self, src_code, node_schedule, kernel): ...

@dataclasses.dataclass(frozen=True)
class CandidateTiling:
    tiling: dict[str, sympy.Expr]
    score: int
    name: str | None = ...
    @staticmethod
    def is_good_size(s):  # -> bool:

        ...

class CantSplit(Exception): ...
