import collections
import dataclasses
import typing
from collections.abc import Iterable, Sequence
from typing import Any

import sympy
import torch
from torch._inductor.tiling_utils import CoalesceVarAnalysis

from ...utils._ordered_set import OrderedSet
from ..dependencies import Dep, MemoryDep
from ..runtime.hints import ReductionHint
from ..scheduler import SchedulerNode
from ..utils import cache_on_self

if typing.TYPE_CHECKING: ...

class NodeScheduleMarker:
    @staticmethod
    def only_nodes(it: Iterable[NodeScheduleEntry]) -> Iterable[SchedulerNode]: ...
    @staticmethod
    def is_reduction() -> bool: ...

type NodeScheduleEntry = SchedulerNode | type[NodeScheduleMarker]

class DisableReduction(NodeScheduleMarker): ...

class EnableReduction(NodeScheduleMarker):
    @staticmethod
    def filter(node_schedule: list[NodeScheduleEntry]) -> Iterable[SchedulerNode]: ...

class SIMDKernelFeatures:
    def __init__(
        self,
        node_schedule: list[NodeScheduleEntry],
        numel: sympy.Expr,
        reduction_numel: sympy.Expr = ...,
        coalesce_analysis: CoalesceVarAnalysis | None = ...,
    ) -> None: ...
    @cache_on_self
    def is_reduction(self) -> bool: ...
    @cache_on_self
    def scheduler_nodes(self) -> Iterable[SchedulerNode]: ...
    def reduction_nodes(self) -> list[SchedulerNode]: ...
    @cache_on_self
    def buf_accesses(self) -> dict[str, list[Dep]]: ...
    @cache_on_self
    def op_counts(self) -> collections.Counter[str]: ...
    def contains_op(self, op_name: str) -> bool: ...
    def get_mutations(self) -> OrderedSet[str]: ...
    @cache_on_self
    def select_index_dtype(self) -> torch.dtype: ...
    @cache_on_self
    def get_reduction_hint(self) -> ReductionHint: ...
    @cache_on_self
    def buffer_read_counts(self) -> dict[str, int]: ...
    def has_non_contiguous_pw_in_reduction_kernel(self) -> bool: ...
    @staticmethod
    def reduction_hint(node: Any) -> ReductionHint: ...
    def memory_stats(self, groups_dict: dict[str, sympy.Expr] | None = ...) -> MemoryStats: ...

class MemoryEstimator:
    kernel_sizes: tuple[sympy.Expr, ...]
    outside_loop: MemoryEstimate
    loops: list[MemoryEstimate]
    persistent: MemoryEstimate
    symbols: list[sympy.Symbol]
    def __init__(self, features: SIMDKernelFeatures, groups: Sequence[sympy.Expr]) -> None: ...
    def simulate_codegen(self) -> None: ...
    def remove_kernel_local(self) -> None: ...
    def scope(self, dep: MemoryDep) -> MemoryEstimate: ...
    def has_reduction_var(self, index: sympy.Expr) -> bool: ...
    def set_ranges(self, *lengths: list[list[sympy.Expr]]) -> list[list[sympy.Expr]]: ...
    @staticmethod
    def make_flat_range(sym: sympy.Symbol, numel: sympy.Expr, lengths: list[sympy.Expr]) -> list[sympy.Expr]: ...

@dataclasses.dataclass
class MemoryEstimate:
    reads: dict[str, OrderedSet[MemoryDep]] = ...
    writes: dict[str, OrderedSet[MemoryDep]] = ...
    def remove(self, name: str) -> None: ...
    def __bool__(self) -> bool: ...

@dataclasses.dataclass
class StatsForDim:
    count_per_thread_contiguous: int = ...
    count_per_thread_broadcast: int = ...
    count_per_thread_non_contiguous: int = ...
    bytes_per_thread_contiguous: int = ...
    bytes_per_thread_broadcast: int = ...
    bytes_per_thread_non_contiguous: int = ...
    bytes_contiguous_or_broadcast: sympy.Expr = ...
    bytes_non_contiguous: sympy.Expr = ...
    def __add__(self, other: typing.Self) -> StatsForDim: ...
    @property
    def count_per_thread(self) -> int: ...
    @property
    def bytes_per_thread(self) -> int: ...
    @property
    def bytes(self) -> sympy.Expr: ...
    @property
    def contiguous_score(self) -> float: ...

@dataclasses.dataclass
class StatsForLoop:
    count_per_thread: int = ...
    bytes_per_thread: int = ...
    def __add__(self, other: typing.Self) -> StatsForLoop: ...

@dataclasses.dataclass
class StatsForReadsOrWrites:
    dim: list[StatsForDim]
    loop: list[StatsForLoop]
    bytes_contiguous_or_broadcast: sympy.Expr = ...
    bytes_non_contiguous: sympy.Expr = ...
    def __add__(self, other: typing.Self) -> StatsForReadsOrWrites: ...
    @property
    def count_per_thread(self) -> int: ...
    @property
    def bytes_per_thread(self) -> int: ...
    @property
    def bytes(self) -> sympy.Expr: ...
    @classmethod
    def compute(
        cls, loop_deps: list[dict[str, OrderedSet[MemoryDep]]], index_symbols: list[sympy.Symbol]
    ) -> typing.Self: ...

@dataclasses.dataclass
class StatsForKernelType:
    reads: StatsForReadsOrWrites
    writes: StatsForReadsOrWrites
    memory: StatsForReadsOrWrites
    @classmethod
    def compute(cls, loops: list[MemoryEstimate], estimator: MemoryEstimator) -> typing.Self: ...

@dataclasses.dataclass
class MemoryStats:
    persistent: StatsForKernelType
    looped: StatsForKernelType
    def get(self, persistent: bool) -> StatsForKernelType: ...
    @classmethod
    def compute(cls, estimator: MemoryEstimator) -> typing.Self: ...
