import typing
from concurrent.futures import Future, ProcessPoolExecutor
from enum import Enum, IntEnum
from typing import IO, Optional, TypeVar
from collections.abc import Callable
from typing import Never, ParamSpec

log = ...
_P = ParamSpec("_P")
_T = TypeVar("_T")

class MsgHeader(IntEnum):
    ERROR = ...
    SHUTDOWN = ...
    QUIESCE = ...
    WAKEUP = ...
    JOB = ...

msg_bytes = ...

class _SubprocExceptionInfo:
    def __init__(self, details: str) -> None: ...

class SubprocException(Exception):
    def __init__(self, details: str, name: str = ...) -> None: ...
    def with_name(self, name: str) -> SubprocException: ...

class SubprocPickler:
    def dumps(self, obj: object) -> bytes: ...
    def loads(self, data: bytes) -> object: ...

class SubprocKind(Enum):
    FORK = ...
    SPAWN = ...

class SubprocPool:
    def __init__(self, nprocs: int, pickler: SubprocPickler | None = ..., kind: SubprocKind = ...) -> None: ...
    def submit(self, job_fn: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -> Future[_T]: ...
    def quiesce(self) -> None: ...
    def wakeup(self) -> None: ...
    def shutdown(self) -> None: ...

class SubprocMain:
    def __init__(
        self, pickler: SubprocPickler, kind: SubprocKind, nprocs: int, read_pipe: IO[bytes], write_pipe: IO[bytes]
    ) -> None: ...
    def main(self) -> None: ...
    def submit(self, job_id: int, data: bytes) -> None: ...
    @staticmethod
    def do_job(pickler: SubprocPickler, data: bytes) -> bytes: ...

type AnyPool = ProcessPoolExecutor | SubprocPool

class TestException(RuntimeError): ...

def raise_testexc() -> Never: ...
