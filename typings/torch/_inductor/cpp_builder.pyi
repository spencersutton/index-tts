import functools
from collections.abc import Sequence
from typing import Any

from torch._inductor import config
from torch._inductor.cpu_vec_isa import VecISA

if config.is_fbcode(): ...
else:
    def log_global_cache_errors(*args: Any, **kwargs: Any) -> None: ...
    def log_global_cache_stats(*args: Any, **kwargs: Any) -> None: ...
    def log_global_cache_vals(*args: Any, **kwargs: Any) -> None: ...
    def use_global_cache() -> bool: ...

_BUILD_TEMP_DIR = ...
_HERE = ...
_TORCH_PATH = ...
_LINKER_SCRIPT = ...
_IS_LINUX = ...
_IS_MACOS = ...
_IS_WINDOWS = ...
SUBPROCESS_DECODE_ARGS = ...
log = ...

@functools.lru_cache(1)
def cpp_compiler_search(search: str) -> str: ...
def install_gcc_via_conda() -> str: ...
@functools.cache
def check_compiler_exist_windows(compiler: str) -> None: ...

class WinPeFileVersionInfo:
    def __init__(self, file_path: str) -> None: ...
    def get_language_id(self) -> int: ...

@functools.cache
def check_msvc_cl_language_id(compiler: str) -> None: ...
def get_cpp_compiler() -> str: ...
def get_ld_and_objcopy(use_relative_path: bool) -> tuple[str, str]: ...
def convert_cubin_to_obj(cubin_file: str, kernel_name: str, ld: str, objcopy: str) -> str: ...
@functools.cache
def is_gcc() -> bool: ...
@functools.cache
def is_clang() -> bool: ...
@functools.cache
def is_intel_compiler() -> bool: ...
@functools.cache
def is_apple_clang() -> bool: ...
@functools.cache
def is_msvc_cl() -> bool: ...
@functools.cache
def get_compiler_version_info(compiler: str) -> str: ...
def run_compile_cmd(cmd_line: str, cwd: str) -> None: ...
def normalize_path_separator(orig_path: str) -> str: ...

class BuildOptionsBase:
    def __init__(
        self,
        compiler: str = ...,
        definitions: list[str] | None = ...,
        include_dirs: list[str] | None = ...,
        cflags: list[str] | None = ...,
        ldflags: list[str] | None = ...,
        libraries_dirs: list[str] | None = ...,
        libraries: list[str] | None = ...,
        passthrough_args: list[str] | None = ...,
        aot_mode: bool = ...,
        use_relative_path: bool = ...,
        compile_only: bool = ...,
        precompiling: bool = ...,
        preprocessing: bool = ...,
    ) -> None: ...
    def get_compiler(self) -> str: ...
    def get_definitions(self) -> list[str]: ...
    def get_include_dirs(self) -> list[str]: ...
    def get_cflags(self) -> list[str]: ...
    def get_ldflags(self) -> list[str]: ...
    def get_libraries_dirs(self) -> list[str]: ...
    def get_libraries(self) -> list[str]: ...
    def get_passthrough_args(self) -> list[str]: ...
    def get_aot_mode(self) -> bool: ...
    def get_use_relative_path(self) -> bool: ...
    def get_compile_only(self) -> bool: ...
    def get_precompiling(self) -> bool: ...
    def get_preprocessing(self) -> bool: ...
    def save_flags_to_json(self, file: str) -> None: ...

def get_cpp_options(
    cpp_compiler: str,
    do_link: bool,
    warning_all: bool = ...,
    extra_flags: Sequence[str] = ...,
    min_optimize: bool = ...,
) -> tuple[list[str], list[str], list[str], list[str], list[str], list[str], list[str]]: ...

class CppOptions(BuildOptionsBase):
    def __init__(
        self,
        compile_only: bool = ...,
        warning_all: bool = ...,
        extra_flags: Sequence[str] = ...,
        use_relative_path: bool = ...,
        compiler: str = ...,
        min_optimize: bool = ...,
        precompiling: bool = ...,
        preprocessing: bool = ...,
    ) -> None: ...

@functools.cache
def is_conda_llvm_openmp_installed() -> bool: ...
@functools.cache
def homebrew_libomp() -> tuple[bool, str]: ...
@functools.cache
def perload_clang_libomp_win(cpp_compiler: str, omp_name: str) -> None: ...
@functools.cache
def perload_icx_libomp_win(cpp_compiler: str) -> None: ...
def get_mmap_self_macro(use_mmap_weights: bool) -> list[str]: ...
def get_cpp_torch_options(
    cpp_compiler: str,
    vec_isa: VecISA,
    include_pytorch: bool,
    aot_mode: bool,
    use_relative_path: bool,
    use_mmap_weights: bool,
) -> tuple[list[str], list[str], list[str], list[str], list[str], list[str], list[str]]: ...

class CppTorchOptions(CppOptions):
    def __init__(
        self,
        vec_isa: VecISA = ...,
        include_pytorch: bool = ...,
        warning_all: bool = ...,
        aot_mode: bool = ...,
        compile_only: bool = ...,
        use_relative_path: bool = ...,
        use_mmap_weights: bool = ...,
        shared: bool = ...,
        extra_flags: Sequence[str] = ...,
        compiler: str = ...,
        min_optimize: bool = ...,
        precompiling: bool = ...,
        preprocessing: bool = ...,
    ) -> None: ...

def get_cpp_torch_device_options(
    device_type: str, aot_mode: bool = ..., compile_only: bool = ...
) -> tuple[list[str], list[str], list[str], list[str], list[str], list[str], list[str]]: ...

class CppTorchDeviceOptions(CppTorchOptions):
    def __init__(
        self,
        vec_isa: VecISA = ...,
        include_pytorch: bool = ...,
        device_type: str = ...,
        aot_mode: bool = ...,
        compile_only: bool = ...,
        use_relative_path: bool = ...,
        use_mmap_weights: bool = ...,
        shared: bool = ...,
        extra_flags: Sequence[str] = ...,
        min_optimize: bool = ...,
        precompiling: bool = ...,
        preprocessing: bool = ...,
    ) -> None: ...

def get_name_and_dir_from_output_file_path(file_path: str) -> tuple[str, str]: ...

class CppBuilder:
    def __init__(
        self, name: str, sources: str | list[str], BuildOption: BuildOptionsBase, output_dir: str = ...
    ) -> None: ...
    def get_command_line(self) -> str: ...
    def get_target_file_path(self) -> str: ...
    def build_fbcode_re(self) -> None: ...
    def build(self) -> None: ...
    def save_compile_cmd_to_cmake(self, cmake_path: str, device_type: str) -> None: ...
    def save_src_to_cmake(self, cmake_path: str, src_path: str) -> None: ...
    def save_kernel_asm_to_cmake(self, cmake_path: str, asm_files: list[str]) -> None: ...
    def save_link_cmd_to_cmake(self, cmake_path: str) -> None: ...

def run_asm_build_object(src: str, target: str, cwd: str) -> None: ...
