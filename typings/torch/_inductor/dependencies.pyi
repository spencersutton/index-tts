import abc
import dataclasses
import sympy
import torch
from collections.abc import Iterable, Sequence
from typing import Any, Optional, TypeVar, Union
from collections.abc import Callable
from typing import Self
from torch.utils._ordered_set import OrderedSet
from .ops_handler import DefaultHandler
from .utils import VarRanges
from .virtualized import ReductionType, V

T = TypeVar("T")
log = ...
is_indirect = ...

class Dep(abc.ABC):
    name: str
    index: sympy.Expr
    @abc.abstractmethod
    def get_free_symbol_uses(self, unbacked_only: bool = ...) -> OrderedSet[sympy.Symbol]: ...
    @abc.abstractmethod
    def rename(self, renames: dict[str, str]) -> Self: ...
    @abc.abstractmethod
    def get_numel(self) -> sympy.Expr: ...
    @abc.abstractmethod
    def numbytes_hint(self) -> int: ...
    @abc.abstractmethod
    def has_unbacked_symbols(self) -> bool: ...
    @abc.abstractmethod
    def is_contiguous(self) -> bool: ...
    def normalize_with_stride_order(self, prefix: str = ...) -> Self: ...

@dataclasses.dataclass(frozen=True)
class MemoryDep(Dep):
    name: str
    index: sympy.Expr
    var_names: tuple[sympy.Symbol, ...]
    size: tuple[sympy.Expr, ...]
    mode: str | None = ...
    def get_free_symbol_uses(self, unbacked_only: bool = ...) -> OrderedSet[sympy.Symbol]: ...
    @property
    def num_vars(self) -> int: ...
    def decide_loop_order_to_match(self, other: MemoryDep) -> list[int] | None: ...
    def get_offset(self) -> sympy.Expr: ...
    def normalize(self) -> MemoryDep: ...
    def normalize_with_stride_order(self, prefix: str = ...) -> MemoryDep: ...
    @property
    def ranges(self) -> dict[sympy.Symbol, sympy.Expr]: ...
    def simplify_with_ranges(self) -> MemoryDep: ...
    def get_numel(self) -> sympy.Expr: ...
    def rename(self, renames: dict[str, str]) -> MemoryDep: ...
    def numbytes_hint(self) -> int: ...
    def has_unbacked_symbols(self) -> bool: ...
    def is_contiguous(self) -> bool: ...
    def stride1_for_last_dim(self, result_for_complex_expression: bool = ...) -> bool: ...
    def is_scalar(self) -> bool: ...
    def is_indirect(self) -> bool: ...

@dataclasses.dataclass(frozen=True)
class StarDep(Dep):
    name: str
    mode: str | None = ...
    @property
    def index(self) -> sympy.Expr: ...
    def get_numel(self) -> sympy.Expr: ...
    def rename(self, renames: dict[str, str]) -> StarDep: ...
    def get_free_symbol_uses(self, unbacked_only: bool = ...) -> OrderedSet[sympy.Symbol]: ...
    def numbytes_hint(self) -> int: ...
    def has_unbacked_symbols(self) -> bool: ...
    def is_contiguous(self) -> bool: ...
    def is_scalar(self) -> bool: ...
    def is_indirect(self) -> bool: ...

@dataclasses.dataclass(frozen=True)
class WeakDep(Dep):
    name: str
    mutating_buf: str
    is_fake: bool = ...
    def get_free_symbol_uses(self, unbacked_only: bool = ...) -> OrderedSet[sympy.Symbol]: ...
    @property
    def index(self) -> sympy.Expr: ...
    def get_numel(self) -> sympy.Expr: ...
    def rename(self, renames: dict[str, str]) -> WeakDep: ...
    def numbytes_hint(self) -> int: ...
    def has_unbacked_symbols(self) -> bool: ...
    def is_contiguous(self) -> bool: ...

@dataclasses.dataclass(frozen=True)
class IndexExprDep:
    index: sympy.Expr
    var_names: tuple[sympy.Symbol, ...]
    size: tuple[sympy.Expr, ...]

@dataclasses.dataclass
class ReadWrites:
    reads: OrderedSet[Dep]
    writes: OrderedSet[Dep]
    index_exprs: OrderedSet[IndexExprDep]
    range_vars: list[sympy.Expr] | None = ...
    var_ranges: VarRanges | None = ...
    def rename(self, renames: dict[str, str]) -> ReadWrites: ...
    def with_read(self, dep: Dep | OrderedSet[Dep]) -> ReadWrites: ...
    def merge(self, other: ReadWrites) -> ReadWrites: ...
    @staticmethod
    def merge_list(read_writes: list[ReadWrites]) -> ReadWrites: ...
    def remove_reads(self, rem_reads: OrderedSet[Dep]) -> ReadWrites: ...
    def reads_and_writes(self) -> Iterable[Dep]: ...
    def buffer_names(self, ignore_integer_index: bool = ...) -> OrderedSet[str]: ...
    def get_free_symbol_uses(self, unbacked_only: bool = ...) -> OrderedSet[sympy.Symbol]: ...

class _RecordLoadStoreInner(V.MockHandler):
    def __init__(self, var_ranges: VarRanges, normalize: bool) -> None: ...
    @staticmethod
    def drop_unused_symbols(index: int | sympy.Expr, var_names: list[sympy.Expr], sizes: list[sympy.Expr]) -> None: ...
    def canonicalize(
        self, index: sympy.Expr
    ) -> tuple[sympy.Expr, tuple[sympy.Symbol, ...], tuple[sympy.Expr, ...]]: ...
    def load(self, name: str, index: sympy.Expr) -> str: ...
    def load_seed(self, name: str, index: int) -> str: ...
    def store(self, name: str, index: sympy.Expr, value: str, mode: str | None = ...) -> str: ...
    def store_reduction(self, name: str, index: sympy.Expr, value: str) -> str: ...
    def index_expr(self, index: sympy.Expr, dtype: torch.dtype | None) -> str: ...
    def bucketize(
        self,
        values: T,
        boundaries: tuple[str, sympy.Expr, sympy.Expr, sympy.Expr],
        boundary_indices: T,
        indexing_dtype: torch.dtype,
        right: bool,
        sorter: tuple[str, sympy.Expr] | None = ...,
        sorter_indices: T | None = ...,
    ) -> None: ...

class RecordLoadStore(V.KernelFormatterHandler):
    def __init__(self, var_ranges: VarRanges, normalize: bool) -> None: ...

def var_builder(prefix: str) -> tuple[VarRanges, Callable[[sympy.Expr], sympy.Symbol]]: ...
def index_vars_no_squeeze(
    *argsizes: Sequence[sympy.Expr], prefix: str
) -> tuple[list[list[sympy.Symbol]], VarRanges]: ...
def index_vars_squeeze(
    *argsizes: Sequence[sympy.Expr], prefix: str = ...
) -> tuple[list[Sequence[sympy.Expr]], VarRanges]: ...
def extract_read_writes(
    fn: Callable[..., Any],
    *argsizes: Sequence[sympy.Expr],
    normalize: bool = ...,
    prefix: str = ...,
    hidden_args: Sequence[list[sympy.Expr]] = ...,
) -> ReadWrites: ...
def extract_loop_body_with_args(
    fn: Any, args: list[list[sympy.Expr]], var_ranges: VarRanges, normalize: bool = ...
) -> _RecordLoadStoreInner: ...
def extract_input_node_reduction_ranges(
    input_node: torch._inductor.ir.IRNode,
) -> tuple[list[sympy.Expr] | None, list[sympy.Expr] | None]: ...
def canonicalization_prefix() -> str: ...

class FreeSymbolsOpsHandler(DefaultHandler):
    symbols: OrderedSet[sympy.Symbol]
    def __init__(self, unbacked_only: bool = ...) -> None: ...
    def indirect_indexing(
        self, index_var: Any, size: int | sympy.Expr, check: bool = ..., wrap_neg: bool = ...
    ) -> sympy.Symbol: ...
    def frexp(self, x: Any) -> tuple[None, ...]: ...
    def scan(self, dtypes: Any, combine_fn: Any, values: Sequence[Any]) -> tuple[None, ...]: ...
    def sort(self, dtypes: Any, values: Sequence[Any], stable: Any, descending: Any) -> tuple[None, ...]: ...
    def reduction(
        self,
        dtype: torch.dtype,
        src_dtype: torch.dtype,
        reduction_type: ReductionType,
        value: None | tuple[None, ...],
    ) -> None | tuple[None, ...]: ...
    def masked(self, mask: Any, body: Callable[..., Any], other: Any) -> None: ...

def extract_free_symbols(
    fn: Callable[..., Any],
    index: Sequence[sympy.Expr],
    rindex: Sequence[sympy.Expr] | None = ...,
    unbacked_only: bool = ...,
) -> OrderedSet[sympy.Symbol]: ...
