import functools
import sympy
import torch
from collections.abc import Sequence
from typing import Any, Optional, Protocol, TYPE_CHECKING, TypeVar, Union, TypeAlias
from collections.abc import Callable
from torch._prims_common import ELEMENTWISE_TYPE_PROMOTION_KIND
from .ops_handler import OpsHandler
from .virtualized import OpsValue

T = TypeVar("T")

class DTypeVar(Protocol):
    @property
    def dtype(self) -> torch.dtype: ...

type DTypeArg = DTypeVar | torch.types.Number | str | OpsValue

@functools.cache
def get_promoted_dtype(
    *args: Sequence[tuple[torch.dtype, bool]], type_promotion_kind: ELEMENTWISE_TYPE_PROMOTION_KIND | None = ...
): ...
def promote_types(args: Sequence[DTypeArg], type_promotion_kind: ELEMENTWISE_TYPE_PROMOTION_KIND | None = ...): ...

class DtypePropagationOpsHandler:
    _instance: DtypePropagationOpsHandler | None = ...
    def __new__(cls):  # -> Self | DtypePropagationOpsHandler:
        ...
    def __init__(self) -> None: ...
    @staticmethod
    def op_dtype_rule(*args: DTypeArg, type_promotion_kind: ELEMENTWISE_TYPE_PROMOTION_KIND) -> torch.dtype: ...
    @staticmethod
    def return_dtype(*args: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def constant(value: torch.types.Number, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def load_seed(name: str, offset: int) -> torch.dtype: ...
    @staticmethod
    def randint64(seed: int, offset: int, low: int, high: int) -> torch.dtype: ...
    @staticmethod
    def masked(mask: DTypeArg, body: Callable[[], DTypeArg], other: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def where(a: DTypeArg, b: DTypeArg, c: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def index_expr(expr: sympy.Expr, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def to_dtype(
        x: DTypeArg, dtype: torch.dtype, src_dtype: torch.dtype | None = ..., use_compute_types=...
    ) -> torch.dtype: ...
    @staticmethod
    def to_dtype_bitcast(x: DTypeArg, dtype: torch.dtype, src_dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def gelu(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def mul(a: DTypeArg, b: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def truediv(a: DTypeArg, b: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def pow(a: DTypeArg, b: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def mod(a: DTypeArg, b: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def indirect_indexing(x: DTypeArg, size: int, check: bool = ..., wrap_neg: bool = ...) -> torch.dtype: ...
    @staticmethod
    def randn(seed: int, offset: int) -> torch.dtype: ...
    @staticmethod
    def rand(seed: int, offset: int) -> torch.dtype: ...
    @staticmethod
    def store_reduction(name: str, index, value: DTypeArg) -> None: ...
    @staticmethod
    def reduction(dtype: torch.dtype, src_dtype: torch.dtype, reduction_type: str, value: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def store(name: str, index, value: DTypeArg, mode: str | None = ...) -> None: ...
    @staticmethod
    def load(name: str, index) -> torch.dtype: ...
    @staticmethod
    def floor(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def ceil_to_int(x: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def int_truediv(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def scan(
        dtypes: tuple[torch.dtype, ...],
        combine_fn: Callable[[tuple[T, ...], tuple[T, ...]], tuple[T, ...]],
        values: tuple[T, ...],
    ) -> tuple[torch.dtype, ...]: ...
    @staticmethod
    def fmod(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def round_to_int(x: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def identity(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def frexp(x: DTypeArg) -> tuple[torch.dtype, torch.dtype]: ...
    @staticmethod
    def sort(
        dtypes: tuple[torch.dtype, ...], values: tuple[T, ...], stable: bool, descending: bool
    ) -> tuple[torch.dtype, ...]: ...
    @staticmethod
    def trunc(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def bucketize(
        values: DTypeArg,
        boundaries: tuple[str, sympy.Expr, sympy.Expr, sympy.Expr],
        boundary_indices: DTypeArg,
        indexing_dtype: torch.dtype,
        right: bool,
        sorter: tuple[str, sympy.Expr] | None = ...,
        sorter_indices: T | None = ...,
    ) -> torch.dtype: ...
    @staticmethod
    def rshift(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def round(x: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def trunc_to_int(x: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def floor_to_int(x: DTypeArg, dtype: torch.dtype) -> torch.dtype: ...
    @staticmethod
    def truncdiv(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def floordiv(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def halide_clamp(value, size, check):  # -> dtype:
        ...
    @staticmethod
    def inline_asm_elementwise(*inputs, asm, constraints=..., dtype=..., is_pure=..., pack=...):  # -> dtype:
        ...
    @staticmethod
    def lshift(x: DTypeArg, y: DTypeArg) -> torch.dtype: ...
    @staticmethod
    def check_bounds(expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool) -> None: ...
    def output(self, *args: DTypeArg) -> None: ...
    def placeholder(self, index: int) -> torch.dtype: ...
    @staticmethod
    def device_assert_async(cond, msg: str) -> torch.dtype: ...

if TYPE_CHECKING:
    class _typecheck_DtypePropagation(DtypePropagationOpsHandler, OpsHandler[Any]): ...
