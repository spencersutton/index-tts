import logging
import torch
import torch.fx as fx
from dataclasses import dataclass
from typing import Any, Callable, Optional, Union
from torch.utils._ordered_set import OrderedSet

aten = ...
logger: logging.Logger = ...

def move_block_after(block: list[fx.Node], target_node: fx.Node) -> None: ...
def move_block_before(block: list[fx.Node], target_node: fx.Node) -> None: ...
def call_function(
    graph: fx.Graph,
    target: Union[str, Callable[..., Any]],
    args: Optional[tuple[fx.node.Argument, ...]] = ...,
    kwargs: Optional[dict[str, fx.node.Argument]] = ...,
) -> fx.Node: ...

@dataclass(unsafe_hash=True)
class CommBlock:
    shape: Union[torch.Size, list[torch.Size]]
    node_list: list[fx.Node]
    inputs: list[fx.Node]
    wait_nodes: list[fx.Node]
    comm_node: fx.Node
    outputs: OrderedSet[fx.Node]

def get_comm_block(comm_node: fx.Node) -> Optional[CommBlock]: ...
def get_all_comm_blocks(
    graph: fx.Graph, comm_ops: tuple[torch._ops.OpOverload, ...], comm_filter: Optional[Callable[..., bool]] = ...
) -> list[CommBlock]: ...
def fuse_ddp_with_coalesced_op(graph: fx.Graph, bucket_size_mb: int) -> None: ...
def fuse_ddp_with_concat_op(graph: fx.Graph, bucket_size_mb: int) -> None: ...
def schedule_comm_wait(graph: fx.Graph) -> None: ...
def fuse_ddp_communication(
    graph: fx.Graph, passes: list[Union[Callable[..., None], str]], bucket_size_mb: int
) -> None: ...
