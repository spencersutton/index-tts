import torch
from torch import Tensor
from .. import config
from ..pattern_matcher import Arg, CallFunction, Match, register_graph_pattern
from .split_cat import construct_pattern_matcher_pass

aten = ...
log = ...
MIN_FIRST_DIMENSION_DECOMPOSITION = ...
MAX_OTHER_DIMENSION_DECOMPOSITION = ...
CPU_MAX_FIRST_DIMENSION_DECOMPOSITION = ...
CPU_MAX_OTHER_DIMENSION_DECOMPOSITION = ...
min_first_dimension_decomposition = ...
max_other_dimension_decomposition = ...
cpu_max_first_dimension_decomposition = ...
cpu_max_other_dimension_decomposition = ...
if "decompose_mm_pass" in config.post_grad_fusion_options:
    min_first_dimension_decomposition = ...
    max_other_dimension_decomposition = ...
    cpu_max_first_dimension_decomposition = ...
    cpu_max_other_dimension_decomposition = ...

def check_device(a: Tensor, b: Tensor, device=...) -> bool: ...
def realize_inputs(inputs: list[torch.fx.Node]):  # -> None:
    ...
def should_decompose_bmm(mat1, mat2) -> bool: ...
def should_decompose_mm(mat1, mat2) -> bool: ...
def print_decompose_pattern(match: Match, inputs: list[torch.fx.Node]):  # -> None:
    ...
@register_graph_pattern(
    CallFunction(aten.bmm, Arg(), Arg()), pass_dict=construct_pattern_matcher_pass("decompose_mm_pass")
)
def decompose_bmm(match: Match, mat1: torch.fx.Node, mat2: torch.fx.Node):  # -> None:
    ...
@register_graph_pattern(
    CallFunction(aten.addmm, Arg(), Arg(), Arg()), pass_dict=construct_pattern_matcher_pass("decompose_mm_pass")
)
def decompose_addmm(match: Match, mat1: torch.fx.Node, mat2: torch.fx.Node, mat3: torch.fx.Node):  # -> None:
    ...
@register_graph_pattern(
    CallFunction(aten.mm, Arg(), Arg()), pass_dict=construct_pattern_matcher_pass("decompose_mm_pass")
)
def decompose_mm(match: Match, mat1: torch.fx.Node, mat2: torch.fx.Node):  # -> None:
    ...
