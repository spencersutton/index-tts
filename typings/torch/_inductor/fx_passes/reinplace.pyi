from collections.abc import Callable
from dataclasses import dataclass
from typing import Any

import torch

log = ...
aten = ...

@dataclass(frozen=True)
class InplaceableOp:
    inplace_op: Callable[..., Any]
    mutated_arg: int
    extra_check: Callable[[torch.fx.Node], bool] = ...

_SCATTER_OP_TO_VIEW = ...
_VIEW_OP_TO_SCATTER = ...

def graph_call_function(graph: torch.fx.Graph, fn, *args, **kwargs):  # -> Node:
    ...

@dataclass
class ViewOp:
    target: torch._ops.OpOverload
    args: tuple[Any, ...]
    kwargs: dict[str, Any]

_ALWAYS_MUTATING_SCATTER_OPS = ...

def scatter_always_uses_mutation(node: torch.fx.Node) -> bool: ...
def should_reinplace_scatter(node: torch.fx.Node) -> bool: ...
def decompose_generalized_scatter(graph: torch.fx.Graph) -> None: ...
def canonicalize_view_scatter_ops(graph: torch.fx.Graph) -> None: ...

inplaceable_ops: dict[Callable[..., Any], InplaceableOp] = ...
c10d_functional = ...
inplaceable_collective_ops: dict[Callable[..., Any], InplaceableOp] = ...
inplaceable_foreach_ops: dict[torch._ops.OpOverload, InplaceableOp] = ...
inplaceable_triton_ops = ...
META_ONLY_OPS = ...

def reinplace_inplaceable_ops_core(graph: torch.fx.Graph) -> None: ...
def reinplace_inplaceable_ops(
    fake_tensor_updater: torch._inductor.fx_utils.FakeTensorUpdater, graph: torch.fx.Graph
) -> None: ...
