from collections.abc import Sequence
from dataclasses import dataclass
from typing import Any, Literal, overload

import sympy
import torch

from .ops_handler import DefaultHandler

type _ExprType = sympy.Expr | float | int | bool

def upper_bound(val: _ExprType): ...

@dataclass
class TypedExpr:
    expr: _ExprType
    dtype: torch.dtype
    def is_constant(self): ...
    def __post_init__(self): ...

class SymPyOps:
    @staticmethod
    def identity(value: Any) -> Any: ...
    @staticmethod
    def constant(value: float | bool, dtype: torch.dtype) -> TypedExpr: ...
    @staticmethod
    def index_expr(value: sympy.Expr | int, dtype: torch.dtype) -> TypedExpr: ...
    @staticmethod
    def to_dtype(
        value: TypedExpr, dtype: torch.dtype, src_dtype: torch.dtype | None = ..., use_compute_types: bool = ...
    ) -> TypedExpr: ...
    @staticmethod
    def abs(x: TypedExpr) -> TypedExpr: ...
    @staticmethod
    def square(x: TypedExpr) -> TypedExpr: ...
    @staticmethod
    def add(x: TypedExpr, y: TypedExpr) -> TypedExpr: ...
    @staticmethod
    def sub(x: TypedExpr, y: TypedExpr) -> TypedExpr: ...
    @staticmethod
    def mul(x: TypedExpr, y: TypedExpr) -> TypedExpr: ...
    @staticmethod
    def neg(x: TypedExpr) -> TypedExpr: ...
    @staticmethod
    def floordiv(x: TypedExpr, y: TypedExpr) -> TypedExpr: ...
    @staticmethod
    def mod(x: TypedExpr, y: TypedExpr) -> TypedExpr | None: ...
    @staticmethod
    def remainder(x: TypedExpr, y: TypedExpr) -> TypedExpr | None: ...
    @staticmethod
    def minimum(x: TypedExpr, y: TypedExpr) -> TypedExpr: ...
    @staticmethod
    def maximum(x: TypedExpr, y: TypedExpr) -> TypedExpr: ...

@dataclass
class IndexPropVar:
    value: Any
    is_symbolic: bool = ...
    @staticmethod
    def new_symbolic(expr: TypedExpr) -> IndexPropVar: ...
    def __post_init__(self): ...

type IndexPropResult = IndexPropVar | tuple[IndexPropResult, ...]

class IndexPropagation(DefaultHandler):
    def __init__(
        self,
        inner: Any,
        iter_ranges: dict[sympy.Symbol, sympy.Expr],
        indirect_var_ranges: dict[sympy.Symbol, sympy.Expr],
    ) -> None: ...
    def materialize_expr(self, expr: sympy.Expr, dtype: torch.dtype) -> Any: ...
    def unwrap(self, a: Any | IndexPropVar) -> Any: ...
    def wrap(self, a) -> IndexPropResult: ...
    @overload
    def fallback(
        self, name: Literal["indirect_indexing"], args: Sequence[Any], kwargs: dict[str, Any]
    ) -> IndexPropVar: ...
    @overload
    def fallback(self, name: str, args: Sequence[Any], kwargs: dict[str, Any]) -> IndexPropResult: ...
    def fallback(self, name: str, args: Sequence[Any], kwargs: dict[str, Any]) -> IndexPropResult: ...
    def propagate_sympy(self, name: str, args: Sequence[Any], kwargs: dict[str, Any]) -> IndexPropResult: ...
    def statically_true(self, e): ...
    def indirect_indexing(self, index: Any | IndexPropVar, size: Any, check: bool = ..., wrap_neg=...) -> Any: ...
