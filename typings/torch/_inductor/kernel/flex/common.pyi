from collections.abc import Sequence
from typing import Any

import torch

from ...ir import ComputedBuffer, IRNode, ShapeAsConstantBuffer, Subgraph, TensorBox

type SubgraphResults = list[ComputedBuffer | None] | ComputedBuffer | None

def zeros_and_scatter_lowering(shape: list[int], indices, values): ...
def get_fwd_subgraph_outputs(
    subgraph_buffer: SubgraphResults, mask_graph_buffer: SubgraphResults
) -> list[ComputedBuffer | None]: ...
def build_subgraph_module_buffer(
    args: list[TensorBox | ShapeAsConstantBuffer], graph_module: torch.fx.GraphModule
) -> SubgraphResults: ...
def build_subgraph_buffer(args: list[TensorBox | ShapeAsConstantBuffer], subgraph: Subgraph) -> SubgraphResults: ...
def maybe_realize(args: list[IRNode | None]): ...
def create_placeholder(
    name: str, dtype: torch.dtype, device: torch.device, size: list[int] | None = ...
) -> TensorBox | ShapeAsConstantBuffer: ...
def construct_strides(sizes: Sequence[int], fill_order: Sequence[int]) -> Sequence[int]: ...
def infer_dense_strides(size: Sequence[int], orig_strides: Sequence[int]): ...
def create_indices_fake(x) -> torch.Tensor: ...
def create_num_blocks_fake_generator(sparse_indices): ...
def contiguous_last_dim(x): ...
def set_head_dim_values(kernel_options: dict[str, Any], qk_head_dim, v_head_dim, graph_sizevars): ...
def is_power_of_2(n): ...
def next_power_of_two(n): ...

_TEMPLATE_DIR = ...

def load_template(name: str) -> str: ...
