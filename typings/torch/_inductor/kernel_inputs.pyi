import torch
import sympy
from typing import Any, Optional, TYPE_CHECKING, Union
from collections.abc import Sequence

if TYPE_CHECKING: ...

class KernelInputs:
    def __init__(self, input_nodes: list[Any], scalars: dict[str, float | int] | None = ...) -> None: ...
    def nodes(self, reorder: Sequence[int] | None = ...) -> list[Any]: ...
    @property
    def count(self) -> int: ...
    @property
    def device_type(self) -> str | None: ...
    def device(self) -> torch.device: ...
    def device_name(self) -> str | None: ...
    def shapes_symbolic(self) -> tuple[tuple[Any, ...], ...]: ...
    def shapes_hinted(self) -> tuple[tuple[int, ...], ...]: ...
    def strides_symbolic(self) -> tuple[tuple[sympy.Integer, ...], ...]: ...
    def strides_hinted(self) -> tuple[tuple[int, ...], ...]: ...
    def dtypes(self) -> tuple[torch.dtype, ...]: ...
    def dtype(self, idx: int = ...) -> torch.dtype: ...
    def get_scalar(self, name: str) -> float | int: ...

class MMKernelInputs(KernelInputs):
    def __init__(
        self,
        input_nodes: list[Any],
        scalars: dict[str, float | int] | None = ...,
        mat1_idx: int = ...,
        mat2_idx: int = ...,
    ) -> None: ...
    def mnk_symbolic(self) -> tuple[sympy.Integer, sympy.Integer, sympy.Integer]: ...
    def mat1mat2(self) -> tuple[Any, Any]: ...
    def mnk_hinted(self) -> tuple[int, int, int]: ...
