import sympy
import torch
from typing import Any, Generic, Literal, NamedTuple, Optional, TypeVar, Union, TypeAlias
from collections.abc import Callable
from ..utils._ordered_set import OrderedSet

T = TypeVar("T")
type StoreMode = Literal["atomic_add"] | None
type ReductionType = Literal[
    "argmax",
    "argmin",
    "welford_reduce",
    "welford_combine",
    "any",
    "max",
    "min",
    "prod",
    "sum",
    "xor_sum",
    "online_softmax_reduce",
]

class OpsHandler(Generic[T]):
    def constant(self, value: bool | float, dtype: torch.dtype) -> T: ...
    def load_seed(self, name: str, offset: T) -> T: ...
    def rand(self, seed: T, offset: T) -> T: ...
    def randn(self, seed: T, offset: T) -> T: ...
    def randint64(self, seed: T, offset: T, low: T, high: T) -> T: ...
    def masked(self, mask: T, body: Callable[[], T], other: T) -> T: ...
    def where(self, condition: T, input: T, other: T) -> T: ...
    def index_expr(self, expr: sympy.Expr, dtype: torch.dtype) -> T: ...
    def to_dtype(
        self, x: T, dtype: torch.dtype, src_dtype: torch.dtype | None = ..., use_compute_types: bool = ...
    ) -> T: ...
    def trunc_to_int(self, x: T, dtype: torch.dtype) -> T: ...
    def ceil_to_int(self, x: T, dtype: torch.dtype) -> T: ...
    def floor_to_int(self, x: T, dtype: torch.dtype) -> T: ...
    def round_to_int(self, x: T, dtype: torch.dtype) -> T: ...
    def to_dtype_bitcast(self, x: T, dtype: torch.dtype, src_dtype: torch.dtype) -> T: ...
    def identity(self, x: T) -> T: ...
    def indirect_indexing(self, x: T, size: sympy.Expr, check: bool = ..., wrap_neg=...) -> sympy.Expr: ...
    def load(self, name: str, index: sympy.Expr) -> T: ...
    def store(self, name: str, index: sympy.Expr, value: T, mode: StoreMode = ...) -> None: ...
    def reduction(
        self, dtype: torch.dtype, src_dtype: torch.dtype, reduction_type: ReductionType, value: T
    ) -> T | tuple[T, ...]: ...
    def store_reduction(self, name: str, index: sympy.Expr, value: T) -> None: ...
    def scan(
        self,
        dtypes: tuple[torch.dtype, ...],
        combine_fn: Callable[[tuple[T, ...], tuple[T, ...]], tuple[T, ...]],
        values: tuple[T, ...],
    ) -> tuple[T, ...]: ...
    def sort(
        self, dtypes: tuple[torch.dtype, ...], values: tuple[T, ...], stable: bool, descending: bool
    ) -> tuple[T, ...]: ...
    def bucketize(
        self,
        values: T,
        boundaries: tuple[str, sympy.Expr, sympy.Expr, sympy.Expr],
        boundary_indices: T,
        indexing_dtype: torch.dtype,
        right: bool,
        sorter: tuple[str, sympy.Expr] | None = ...,
        sorter_indices: T | None = ...,
    ) -> T: ...
    def abs(self, x0: T) -> T: ...
    def exp(self, x0: T) -> T: ...
    def exp2(self, x0: T) -> T: ...
    def expm1(self, x0: T) -> T: ...
    def sqrt(self, x0: T) -> T: ...
    def relu(self, x0: T) -> T: ...
    def minimum(self, x0: T, x1: T) -> T: ...
    def maximum(self, x0: T, x1: T) -> T: ...
    def cos(self, x0: T) -> T: ...
    def sin(self, x0: T) -> T: ...
    def lgamma(self, x0: T) -> T: ...
    def erf(self, x0: T) -> T: ...
    def cosh(self, x0: T) -> T: ...
    def sinh(self, x0: T) -> T: ...
    def acos(self, x0: T) -> T: ...
    def acosh(self, x0: T) -> T: ...
    def asin(self, x0: T) -> T: ...
    def asinh(self, x0: T) -> T: ...
    def atan2(self, x0: T, x1: T) -> T: ...
    def atan(self, x0: T) -> T: ...
    def atanh(self, x0: T) -> T: ...
    def copysign(self, x0: T, x1: T) -> T: ...
    def erfc(self, x0: T) -> T: ...
    def erfinv(self, x0: T) -> T: ...
    def frexp(self, x0: T): ...
    def hypot(self, x0: T, x1: T) -> T: ...
    def log10(self, x0: T) -> T: ...
    def log2(self, x0: T) -> T: ...
    def nextafter(self, x0: T, x1: T) -> T: ...
    def logical_and(self, x0: T, x1: T) -> T: ...
    def logical_not(self, x0: T) -> T: ...
    def logical_or(self, x0: T, x1: T) -> T: ...
    def logical_xor(self, x0: T, x1: T) -> T: ...
    def bitwise_and(self, x0: T, x1: T) -> T: ...
    def bitwise_not(self, x0: T) -> T: ...
    def bitwise_or(self, x0: T, x1: T) -> T: ...
    def bitwise_xor(self, x0: T, x1: T) -> T: ...
    def bitwise_left_shift(self, x0: T, x1: T) -> T: ...
    def bitwise_right_shift(self, x0: T, x1: T) -> T: ...
    def rsqrt(self, x0: T) -> T: ...
    def log1p(self, x0: T) -> T: ...
    def tan(self, x0: T) -> T: ...
    def tanh(self, x0: T) -> T: ...
    def sigmoid(self, x0: T) -> T: ...
    def signbit(self, x0: T) -> T: ...
    def fmod(self, x0: T, x1: T) -> T: ...
    def log(self, x0: T) -> T: ...
    def isinf(self, x0: T) -> T: ...
    def isnan(self, x0: T) -> T: ...
    def round(self, x0: T) -> T: ...
    def floor(self, x0: T) -> T: ...
    def sign(self, x0: T) -> T: ...
    def trunc(self, x0: T) -> T: ...
    def ceil(self, x0: T) -> T: ...
    def neg(self, x0: T) -> T: ...
    def reciprocal(self, x0: T) -> T: ...
    def eq(self, x0: T, x1: T) -> T: ...
    def ne(self, x0: T, x1: T) -> T: ...
    def lt(self, x0: T, x1: T) -> T: ...
    def gt(self, x0: T, x1: T) -> T: ...
    def le(self, x0: T, x1: T) -> T: ...
    def ge(self, x0: T, x1: T) -> T: ...
    def add(self, x0: T, x1: T) -> T: ...
    def sub(self, x0: T, x1: T) -> T: ...
    def mul(self, x0: T, x1: T) -> T: ...
    def pow(self, x0: T, x1: T) -> T: ...
    def and_(self, x0: T, x1: T) -> T: ...
    def or_(self, x0: T, x1: T) -> T: ...
    def xor(self, x0: T, x1: T) -> T: ...
    def lshift(self, x0: T, x1: T) -> T: ...
    def rshift(self, x0: T, x1: T) -> T: ...
    def airy_ai(self, x: T) -> T: ...
    def bessel_j0(self, x: T) -> T: ...
    def bessel_j1(self, x: T) -> T: ...
    def bessel_y0(self, x: T) -> T: ...
    def bessel_y1(self, x: T) -> T: ...
    def digamma(self, x: T) -> T: ...
    def erfcx(self, x: T) -> T: ...
    def fma(self, x: T, y: T, z: T) -> T: ...
    def igamma(self, x: T, y: T) -> T: ...
    def igammac(self, x: T, y: T) -> T: ...
    def gammainc(self, x: T, y: T) -> T: ...
    def gammaincc(self, x: T, y: T) -> T: ...
    def i0(self, x: T) -> T: ...
    def i0e(self, x: T) -> T: ...
    def i1(self, x: T) -> T: ...
    def i1e(self, x: T) -> T: ...
    def log_ndtr(self, x: T) -> T: ...
    def modified_bessel_i0(self, x: T) -> T: ...
    def modified_bessel_i1(self, x: T) -> T: ...
    def modified_bessel_k0(self, x: T) -> T: ...
    def modified_bessel_k1(self, x: T) -> T: ...
    def ndtr(self, x: T) -> T: ...
    def ndtri(self, x: T) -> T: ...
    def polygamma(self, x: T, y: T) -> T: ...
    def scaled_modified_bessel_k0(self, x: T) -> T: ...
    def scaled_modified_bessel_k1(self, x: T) -> T: ...
    def spherical_bessel_j0(self, x: T) -> T: ...
    def zeta(self, x: T, y: T) -> T: ...
    def chebyshev_polynomial_t(self, x: T, y: T) -> T: ...
    def chebyshev_polynomial_u(self, x: T, y: T) -> T: ...
    def chebyshev_polynomial_v(self, x: T, y: T) -> T: ...
    def chebyshev_polynomial_w(self, x: T, y: T) -> T: ...
    def legendre_polynomial_p(self, x: T, y: T) -> T: ...
    def shifted_chebyshev_polynomial_t(self, x: T, y: T) -> T: ...
    def shifted_chebyshev_polynomial_u(self, x: T, y: T) -> T: ...
    def shifted_chebyshev_polynomial_v(self, x: T, y: T) -> T: ...
    def shifted_chebyshev_polynomial_w(self, x: T, y: T) -> T: ...
    def hermite_polynomial_h(self, x: T, y: T) -> T: ...
    def hermite_polynomial_he(self, x: T, y: T) -> T: ...
    def laguerre_polynomial_l(self, x: T, y: T) -> T: ...
    def truncdiv(self, x0: T, x1: T) -> T: ...
    def floordiv(self, x0: T, x1: T) -> T: ...
    def truediv(self, x0: T, x1: T) -> T: ...
    def int_truediv(self, x0: T, x1: T) -> T: ...
    def mod(self, x0: T, x1: T) -> T: ...
    def remainder(self, x0: T, x1: T) -> T: ...
    def square(self, x0: T) -> T: ...
    def check_bounds(self, expr: sympy.Expr, size: sympy.Expr, lower: bool, upper: bool) -> None: ...
    def halide_clamp(self, value: T, size: sympy.Expr, check: bool) -> T: ...
    def inline_asm_elementwise(
        self,
        *inputs: T,
        asm: str,
        constraints: str | None = ...,
        dtype: torch.dtype = ...,
        is_pure: bool = ...,
        pack: int = ...,
    ) -> T: ...
    def output(self, *args: T) -> None: ...
    def placeholder(self, index: int) -> T: ...
    def device_assert_async(self, cond: T, msg: str) -> T: ...

_ignore_op_re = ...

def list_ops(cls: type[Any]):  # -> OrderedSet[str]:
    ...

OP_NAMES = ...

class DefaultHandler(OpsHandler[Any]):
    def __getattr__(self, name: str) -> Any: ...
    def device_assert_async(self, cond, msg):  # -> None:
        ...

class NoopHandler(DefaultHandler):
    name = ...
    @staticmethod
    def masked(mask, body, other) -> None: ...
    @staticmethod
    def frexp(x) -> tuple[None, None]: ...
    @staticmethod
    def scan(dtypes, combine_fn, values) -> tuple[None, ...]: ...
    @staticmethod
    def sort(dtypes, values, stable, descending) -> tuple[None, ...]: ...
    @staticmethod
    def indirect_indexing(index_var, size, check=..., wrap_neg=...) -> sympy.Symbol: ...

class BasicMathOpsMixin:
    @staticmethod
    def add(a, b):  # -> str:
        ...
    @staticmethod
    def sub(a, b):  # -> str:
        ...
    @staticmethod
    def mul(a, b):  # -> str:
        ...
    @staticmethod
    def floordiv(a, b):  # -> str:
        ...
    @staticmethod
    def truediv(a, b):  # -> str:
        ...
    @staticmethod
    def mod(a, b):  # -> str:
        ...
    @staticmethod
    def pow(a, b):  # -> str:
        ...
    @staticmethod
    def lshift(a, b):  # -> str:
        ...
    @staticmethod
    def rshift(a, b):  # -> str:
        ...
    @staticmethod
    def and_(a, b):  # -> str:
        ...
    @staticmethod
    def or_(a, b):  # -> str:
        ...
    @staticmethod
    def xor(a, b):  # -> str:
        ...
    @staticmethod
    def eq(a, b):  # -> str:
        ...
    @staticmethod
    def ne(a, b):  # -> str:
        ...
    @staticmethod
    def lt(a, b):  # -> str:
        ...
    @staticmethod
    def gt(a, b):  # -> str:
        ...
    @staticmethod
    def le(a, b):  # -> str:
        ...
    @staticmethod
    def ge(a, b):  # -> str:
        ...
    @staticmethod
    def neg(a):  # -> str:
        ...

class MockHandler(BasicMathOpsMixin, DefaultHandler):
    name = ...
    @staticmethod
    def masked(mask, body, other) -> str: ...
    @staticmethod
    def frexp(x):  # -> tuple[str, str]:
        ...
    @staticmethod
    def scan(dtypes, combine_fn, values):  # -> tuple[str, ...]:
        ...
    @staticmethod
    def sort(dtypes, values, stable, descending):  # -> tuple[str, ...]:
        ...
    @staticmethod
    def indirect_indexing(index_var, size, check=..., wrap_neg=...) -> sympy.Symbol: ...
    def device_assert_async(self, cond, msg):  # -> None:
        ...

class KernelFormatterHandler(DefaultHandler):
    def __init__(self, parent_handler: OpsHandler[Any]) -> None: ...
    @staticmethod
    def ir_to_string(ir_fn, index, rindex=...) -> str: ...
    def indirect_indexing(self, *args, **kwargs) -> sympy.Symbol: ...
    def reduction(
        self,
        dtype: torch.dtype,
        src_dtype: torch.dtype,
        reduction_type: ReductionType,
        value: str | tuple[str, ...],
    ) -> str | tuple[str, ...]: ...
    def getvalue(self, result):  # -> str:
        ...
    def device_assert_async(self, cond, msg: str):  # -> str:
        ...

class WrapperHandler(DefaultHandler):
    def __init__(self, inner: OpsHandler[Any]) -> None: ...

class AddParenHandler(WrapperHandler): ...

class OpCountResult(NamedTuple):
    num_ops: int
    used_ops: OrderedSet[str]
    read_buffers: list[str]
    nontrivial_read_count: int

class OpCounterCSE(DefaultHandler):
    def __init__(self, inner: OpsHandler[Any]) -> None: ...
    def indirect_indexing(self, *args, **kwargs): ...
    def load(self, name: str, index: sympy.Expr) -> str: ...
    def load_seed(self, name: str, offset: T):  # -> str:
        ...
    def bucketize(
        self,
        values: T,
        boundaries: tuple[str, sympy.Expr, sympy.Expr, sympy.Expr],
        boundary_indices: T,
        indexing_dtype: torch.dtype,
        right: bool,
        sorter: tuple[str, sympy.Expr] | None = ...,
        sorter_indices: T | None = ...,
    ) -> T: ...
    def getvalue(self):  # -> OpCountResult:
        ...

class ExtractConstantsHandler(NoopHandler):
    def __init__(self, device: torch.device | None) -> None: ...
    def constant(self, value: Any, dtype: torch.dtype) -> torch._inductor.ir.Constant: ...

class SimpleCSEHandler(WrapperHandler):
    def __init__(self, inner: Any) -> None: ...
    def indirect_indexing(self, *args, **kwargs) -> sympy.Expr: ...
    def store(self, *args, **kwargs) -> None: ...
    def store_reduction(self, *args, **kwargs) -> None: ...
