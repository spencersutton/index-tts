from collections.abc import Hashable
from typing import Any

import torch

from .triton_compat import Config

def conditional_product(*args: int) -> int: ...
def ceildiv(number: int, denom: int) -> int: ...
def is_power_of_2(n: int) -> bool: ...
def next_power_of_2(n: int) -> int: ...
def get_num_bytes(*args: torch.Tensor, num_in_out_args: int = ...) -> int: ...
def triton_config_to_hashable(cfg: Config) -> Hashable: ...
def validate_triton_config(cfg: Config) -> None: ...
def create_bandwidth_info_str(
    ms: float, num_gb: float, gb_per_s: float, prefix: str = ..., suffix: str = ..., color: bool = ...
) -> str: ...
def get_max_y_grid() -> int: ...

HAS_COLORAMA = ...
if HAS_COLORAMA: ...

def green_text(msg: str) -> str: ...
def yellow_text(msg: str) -> str: ...
def red_text(msg: str) -> str: ...
def blue_text(msg: str) -> str: ...
def get_first_attr(obj: Any, *attrs: str) -> Any: ...

dynamo_timed = ...

def triton_hash_to_path_key(key: str) -> str: ...
def compile_mps_shader(source: str) -> Any: ...
