from collections.abc import Callable
from typing import Any, TypeVar

from .triton_compat import tl, triton

_T = TypeVar("_T")
_LOG_2_E: tl.constexpr = ...

def set_driver_to_cpu(): ...
def set_driver_to_gpu(): ...
def get_backend_options(): ...
@triton.jit
def promote_to_tensor(x): ...
@triton.jit
def div_floor_integer(a, b): ...
@triton.jit
def remainder_integer(a, b): ...
@triton.jit
def is_floating(x): ...
@triton.jit
def prod(input, axis): ...
@triton.jit
def minimum(a, b): ...
@triton.jit
def maximum(a, b): ...
@triton.jit
def min2(a, dim): ...
@triton.jit
def max2(a, dim): ...
@triton.jit
def minimum_with_index(a_value, a_index, b_value, b_index): ...
@triton.jit
def maximum_with_index(a_value, a_index, b_value, b_index): ...
@triton.jit
def min_with_index(value, index, dim): ...
@triton.jit
def max_with_index(value, index, dim): ...
@triton.jit
def exp(x, use_fast_math: tl.constexpr): ...
@triton.jit
def online_softmax_reduce(lhs_max, lhs_sum, dim, use_fast_math: tl.constexpr): ...
@triton.jit
def online_softmax_combine(lhs_max, lhs_sum, rhs_max, use_fast_math: tl.constexpr): ...
@triton.jit
def welford_reduce(value, mean, m2, weight, first_iteration): ...
@triton.jit
def welford_combine(mean_1, m2_1, weight_1, mean_2, m2_2, weight_2): ...
@triton.jit
def welford(mean, m2, weight, dim): ...
@triton.jit
def device_assert_then(cond, msg, r): ...
@triton.jit
def randint64(seed, offset, low, high): ...
@triton.jit
def any(a, dim): ...
@triton.jit
def bucketize_binary_search(
    values: tl.tensor,
    boundaries_ptr: tl.tensor,
    BOUNDARIES_SIZE: int,
    BOUNDARIES_UNDERLYING_NUMEL: int,
    BOUNDARIES_STRIDE: int,
    boundary_indices: tl.tensor,
    indexing_dtype: tl.dtype,
    right: bool,
    sorter_ptr: tl.tensor,
    SORTER_STRIDE: int,
    sorter_indices: tl.tensor,
): ...
@triton.jit
def pack_value_flag(value, flag, DTYPE_VALUE_AS_UINT: tl.constexpr, DTYPE_PACK: tl.constexpr): ...
@triton.jit
def unpack_value(pack, DTYPE_VALUE, DTYPE_VALUE_AS_UINT): ...
@triton.jit
def unpack_flag(pack, DTYPE_FLAG): ...
@triton.jit
def exclusive_scan_decoupled_lookback(
    scratch_base, block_value, index, combine_fn, DTYPE_VALUE_AS_UINT: tl.constexpr, DTYPE_PACK: tl.constexpr
): ...
@triton.jit
def exclusive_scan_decoupled_lookback_64(scratch_base, block_value, index, combine_fn): ...
@triton.jit
def frexp(x): ...
@triton.jit
def sort_with_index(
    x, idxs, rnumel, dim: tl.constexpr = ..., stable: tl.constexpr = ..., descending: tl.constexpr = ...
): ...
@triton.jit
def select_one(x, mask, dim, keep_dims=...): ...
@triton.jit
def x_grid_barrier(sem): ...
def triton_builtin[T](f: Callable[..., _T]) -> Callable[..., _T]: ...
@triton_builtin
def constexpr_next_power_of_2(n: tl.constexpr, *, _builder: object = ...) -> tl.constexpr: ...
@triton_builtin
def if_mask(mask: Any, val, *, _builder: object = ...) -> tl.constexpr: ...
