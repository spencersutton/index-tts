import sympy
from collections.abc import Iterable, Sequence
from typing import Any, Optional, Union
from collections.abc import Callable
from sympy import Expr
from torch.fx.experimental.symbolic_shapes import ShapeEnv
from torch.utils._ordered_set import OrderedSet
from torch.utils._sympy.value_ranges import ValueRanges
from .utils import VarRanges
from .virtualized import V

log = ...

def statically_known_true(
    shape_env: ShapeEnv,
    expr: sympy.Basic | bool,
    axioms: tuple[sympy.Expr] | None = ...,
    var_to_range: tuple[tuple[sympy.Symbol, ValueRanges[Any]]] | None = ...,
) -> bool: ...

class SizeVarAllocator:
    def __init__(self, shape_env=...) -> None: ...
    def simplify(self, expr: Expr): ...
    def make_simplify_with_ranges_cache(self) -> Callable[[Expr, VarRanges], Expr]: ...
    def make_simplify_loops_cache(
        self,
    ):  # -> Callable[..., tuple[list[Any], Callable[..., list[Any]], Callable[..., list[Any]]] | Any]:

        ...
    def statically_known_true(self, expr: sympy.Basic | bool) -> bool: ...
    def statically_known_equals(self, left: Expr | int, right: Expr | int) -> bool: ...
    def statically_known_list_equals(self, left: Sequence[Expr], right: Sequence[Expr]) -> bool: ...
    def statically_known_leq(self, left: Expr, right: Expr | int) -> bool: ...
    def statically_known_geq(self, left: Expr, right: Expr | int) -> bool: ...
    def statically_known_lt(self, left: Expr, right: Expr | int) -> bool: ...
    def statically_known_gt(self, left: Expr, right: Expr | int) -> bool: ...
    def statically_known_multiple_of(self, numerator: Expr, denominator: Expr | int) -> bool: ...
    def statically_known_power_of_2(self, expr: Expr) -> bool: ...
    def expect_true(self, expr: Expr) -> bool: ...
    def check(self, expr: Expr) -> None: ...
    def check_equals(self, left: Expr, right: Expr) -> None: ...
    def check_equals_and_simplify(self, left: Expr, right: Expr) -> Expr: ...
    def check_leq(self, left: Expr, right: Expr) -> None: ...
    def check_lt(self, left: Expr, right: Expr) -> None: ...
    def guard_or_false(self, left):  # -> bool:
        ...
    def guard_or_true(self, left):  # -> bool:
        ...
    def evaluate_expr(
        self,
        left: Expr | sympy.logic.boolalg.Boolean,
        size_oblivious: bool = ...,
        fallback_value: bool | None = ...,
    ) -> bool: ...
    def is_size_one_or_false(self, size: Expr) -> bool: ...
    def evaluate_min(self, left: Expr, right: Expr) -> Expr: ...
    def evaluate_max(self, left: Expr, right: Expr) -> Expr: ...
    def guard_int(self, expr: Expr | int) -> int: ...
    def guard_int_seq(self, left: Sequence[Expr | int]) -> list[int]: ...
    def remove_precomputed_replacements(self, expr: Expr) -> Expr: ...
    def symbolic_hint(self, expr: Expr | int, hint_override: int | None = ...) -> Expr | int: ...
    def size_hint(self, expr: Expr | int, *, fallback: int | None = ..., hint_override: int | None = ...) -> int: ...
    def size_hint_or_throw(self, expr: Expr | int) -> int: ...
    def size_hints(
        self, exprs: Iterable[Expr | int], *, fallback: int | None = ..., hint_override: int | None = ...
    ) -> tuple[int, ...]: ...
    def size_hints_or_throw(self, exprs: Iterable[Expr | int]) -> tuple[int, ...]: ...
    def make_stride_vars_cache(self):  # -> Callable[..., list[Any]]:
        ...
    def atomically_apply_size_hint(self, expr: Expr | int, *, fallback: int | None = ...) -> Expr | int: ...
    def offset_var(self, index: Expr, vars: Sequence[sympy.Symbol]) -> Expr: ...
    def stride_hints(
        self, index: Expr, vars: Sequence[sympy.Symbol], support_vars: Sequence[sympy.Symbol] | None = ...
    ) -> list[int]: ...
    def stride_order(self, index: Expr, vars: list[sympy.Symbol]) -> list[int]: ...
    def lookup_precomputed_size(self, expr: Expr) -> Expr: ...
    def free_symbols(self) -> OrderedSet[sympy.Symbol]: ...
    def combine_modular_indexing_pairs(self, index: sympy.Expr) -> sympy.Expr: ...
    def expand_floor_div(self, index: sympy.Expr) -> bool | tuple[sympy.Expr, sympy.Expr]: ...

def join_dimensions(expr: Expr) -> Expr: ...

class SimplifyIndexing(V.WrapperHandler):
    def __init__(self, inner, var_ranges: VarRanges) -> None: ...
    def load(self, name: str, index: sympy.Expr):  # -> Any:
        ...
    def store(self, name, index, value, mode=...):  # -> None:
        ...
    def store_reduction(self, name, index, value):  # -> None:
        ...
    def index_expr(self, index, dtype):  # -> Any:
        ...
    def check_bounds(self, index, size, lower, upper):  # -> None:
        ...
