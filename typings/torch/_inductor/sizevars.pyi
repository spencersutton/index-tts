import sympy
from collections.abc import Iterable, Sequence
from typing import Any, Callable, Optional, Union
from sympy import Expr
from torch.fx.experimental.symbolic_shapes import ShapeEnv
from torch.utils._ordered_set import OrderedSet
from torch.utils._sympy.value_ranges import ValueRanges
from .utils import VarRanges
from .virtualized import V

log = ...

def statically_known_true(
    shape_env: ShapeEnv,
    expr: Union[sympy.Basic, bool],
    axioms: Optional[tuple[sympy.Expr]] = ...,
    var_to_range: Optional[tuple[tuple[sympy.Symbol, ValueRanges[Any]]]] = ...,
) -> bool: ...

class SizeVarAllocator:
    def __init__(self, shape_env=...) -> None: ...
    def simplify(self, expr: Expr): ...
    def make_simplify_with_ranges_cache(self) -> Callable[[Expr, VarRanges], Expr]: ...
    def make_simplify_loops_cache(
        self,
    ):  # -> Callable[..., tuple[list[Any], Callable[..., list[Any]], Callable[..., list[Any]]] | Any]:

        ...
    def statically_known_true(self, expr: Union[sympy.Basic, bool]) -> bool: ...
    def statically_known_equals(self, left: Union[Expr, int], right: Union[Expr, int]) -> bool: ...
    def statically_known_list_equals(self, left: Sequence[Expr], right: Sequence[Expr]) -> bool: ...
    def statically_known_leq(self, left: Expr, right: Union[Expr, int]) -> bool: ...
    def statically_known_geq(self, left: Expr, right: Union[Expr, int]) -> bool: ...
    def statically_known_lt(self, left: Expr, right: Union[Expr, int]) -> bool: ...
    def statically_known_gt(self, left: Expr, right: Union[Expr, int]) -> bool: ...
    def statically_known_multiple_of(self, numerator: Expr, denominator: Union[Expr, int]) -> bool: ...
    def statically_known_power_of_2(self, expr: Expr) -> bool: ...
    def expect_true(self, expr: Expr) -> bool: ...
    def check(self, expr: Expr) -> None: ...
    def check_equals(self, left: Expr, right: Expr) -> None: ...
    def check_equals_and_simplify(self, left: Expr, right: Expr) -> Expr: ...
    def check_leq(self, left: Expr, right: Expr) -> None: ...
    def check_lt(self, left: Expr, right: Expr) -> None: ...
    def guard_or_false(self, left):  # -> bool:
        ...
    def guard_or_true(self, left):  # -> bool:
        ...
    def evaluate_expr(
        self,
        left: Union[Expr, sympy.logic.boolalg.Boolean],
        size_oblivious: bool = ...,
        fallback_value: Optional[bool] = ...,
    ) -> bool: ...
    def is_size_one_or_false(self, size: Expr) -> bool: ...
    def evaluate_min(self, left: Expr, right: Expr) -> Expr: ...
    def evaluate_max(self, left: Expr, right: Expr) -> Expr: ...
    def guard_int(self, expr: Union[Expr, int]) -> int: ...
    def guard_int_seq(self, left: Sequence[Union[Expr, int]]) -> list[int]: ...
    def remove_precomputed_replacements(self, expr: Expr) -> Expr: ...
    def symbolic_hint(self, expr: Union[Expr, int], hint_override: Optional[int] = ...) -> Union[Expr, int]: ...
    def size_hint(
        self, expr: Union[Expr, int], *, fallback: Optional[int] = ..., hint_override: Optional[int] = ...
    ) -> int: ...
    def size_hint_or_throw(self, expr: Union[Expr, int]) -> int: ...
    def size_hints(
        self, exprs: Iterable[Union[Expr, int]], *, fallback: Optional[int] = ..., hint_override: Optional[int] = ...
    ) -> tuple[int, ...]: ...
    def size_hints_or_throw(self, exprs: Iterable[Union[Expr, int]]) -> tuple[int, ...]: ...
    def make_stride_vars_cache(self):  # -> Callable[..., list[Any]]:
        ...
    def atomically_apply_size_hint(
        self, expr: Union[Expr, int], *, fallback: Optional[int] = ...
    ) -> Union[Expr, int]: ...
    def offset_var(self, index: Expr, vars: Sequence[sympy.Symbol]) -> Expr: ...
    def stride_hints(
        self, index: Expr, vars: Sequence[sympy.Symbol], support_vars: Optional[Sequence[sympy.Symbol]] = ...
    ) -> list[int]: ...
    def stride_order(self, index: Expr, vars: list[sympy.Symbol]) -> list[int]: ...
    def lookup_precomputed_size(self, expr: Expr) -> Expr: ...
    def free_symbols(self) -> OrderedSet[sympy.Symbol]: ...
    def combine_modular_indexing_pairs(self, index: sympy.Expr) -> sympy.Expr: ...
    def expand_floor_div(self, index: sympy.Expr) -> Union[bool, tuple[sympy.Expr, sympy.Expr]]: ...

def join_dimensions(expr: Expr) -> Expr: ...

class SimplifyIndexing(V.WrapperHandler):
    def __init__(self, inner, var_ranges: VarRanges) -> None: ...
    def load(self, name: str, index: sympy.Expr):  # -> Any:
        ...
    def store(self, name, index, value, mode=...):  # -> None:
        ...
    def store_reduction(self, name, index, value):  # -> None:
        ...
    def index_expr(self, index, dtype):  # -> Any:
        ...
    def check_bounds(self, index, size, lower, upper):  # -> None:
        ...
