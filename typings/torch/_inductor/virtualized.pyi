from collections.abc import Callable
from contextlib import AbstractContextManager
from typing import TYPE_CHECKING, Any, Generic, TypeVar, Union

import torch
from torch._inductor.choices import InductorChoices
from torch._inductor.codegen.cpp_utils import LocalBufferContext
from torch._inductor.debug import DebugContext
from torch._inductor.graph import GraphLowering
from torch._inductor.ir import ExternKernelNode
from torch._inductor.loop_body import InterpreterShim
from torch._subclasses import FakeTensorMode

from .ops_handler import DefaultHandler, KernelFormatterHandler, MockHandler, OpsHandler, WrapperHandler

"""
This file provides a number of "global" variables/handlers that are actually
thread local and dynamically scoped, with Inductor patching them to various
implementations depending on the situation.

These handlers are interacted with in a fairly stylized way.  Typically,
we will import V from this module::

    from .virtualized import V

Various handlers are accessible as attributes on this module; for example,
you might access ``V.graph.sizevars.size_hint`` to resolve a size hint associated with
a number.

There are a few distinct usage patterns for virtualized global variables:

1. Implicit argument passing.  Examples: ``V.current_node``, ``V.aot_compilation``.
   Use ``V.set_current_node`` to change what the current node is while we're
   executing some region of code, so code inside that region can query ``V.current_node``
   to find out what it is.  This is often more convenient than manually threading
   the current node as an argument through all call stacks.

2. Per-compilation global state.  Examples: ``V.fake_mode``, ``V.graph``.  For a
   given ``compile_fx`` invocation, these typically don't change, but they are
   associated with some internal state so they cannot just be global functions.
   We install these objects at the beginning of compilation and then you can
   conveniently access them without having to pass them around.

3. Alternate define-by-run interpretations.  Examples: ``V.ops``, ``V.kernel``.
   A commonly used IR in Inductor is define-by-run: instead of maintaining
   explicit syntax data structures, we instead represent loop bodies as
   callable functions, which internally invoke operations defined on
   ``V.ops``.  To perform semantic analysis, print or code generate these
   operations, we dynamically patch ``V.ops`` with an alternate handler with
   the intended semantics and then run the callable function.  For example, to
   extract out a traditional (FX) graph representation of the define-by-run
   IR, simply install a handler that records each ``ops`` call to a graph.

   TODO: Define a parent class / protocol that defines all of the operations
   V.ops is expected to support.

It is typically an error to access a virtualized global without having installed
an appropriate handler (you will get a NullHandler), although in some cases we
provide a default implementation.

One last thing: although most virtualized globals are accessed via ``V``, ``ops`` is
ubiquitous enough to have its own top level variable, so you will typically see
``ops.constant(...)`` rather than ``V.ops.constant(...)``.  In fact, these are not
equivalent; the former interface supports arithmetic overloads like ``x + y``
instead of forcing ``ops.add(x, y)``, so it should be preferred.

Some operators are seemingly unused, but they are implicitly used by ops_wrapper.
In particular, we typically have an operator for every basic pointwise PyTorch operation
supported.
"""
if TYPE_CHECKING: ...
threadlocal = ...
T = TypeVar("T")

class NullHandler: ...

_PoisonedVirtual = ...

class Virtualized[T]:
    def __init__(self, vname: str, default: Callable[[], T] | type[NullHandler]) -> None: ...
    def __getattr__(self, name: str) -> Any: ...

class NullKernelHandler(NullHandler):
    def __init__(self) -> None: ...
    def get_index_dtype_as_torch_dtype(self):  # -> dtype:
        ...

_ops: Virtualized[OpsHandler[Any]] = ...
_graph: Virtualized[GraphLowering] = ...
_extern_kernel_nodes: Virtualized[list[ExternKernelNode]] = ...
_real_inputs: Virtualized[list[torch.Tensor]] = ...
_fake_mode: Virtualized[FakeTensorMode] = ...
_kernel: Virtualized[NullKernelHandler] = ...
_debug: Virtualized[DebugContext] = ...
_interpreter: Virtualized[InterpreterShim] = ...
_aot_compilation: Virtualized[bool] = ...
_current_node: Virtualized[torch.fx.Node] = ...
_local_buffer_context: Virtualized[LocalBufferContext] = ...
_choices: Virtualized[InductorChoices] = ...

class OpsValue:
    value: Any
    def __init__(self, value) -> None: ...
    def __repr__(self):  # -> str:
        ...
    def __add__(self, other):  # -> Any:
        ...
    def __mul__(self, other):  # -> Any:
        ...
    def __sub__(self, other):  # -> Any:
        ...
    def __neg__(self):  # -> Any:
        ...
    def __truediv__(self, other):  # -> Any:
        ...
    def __floordiv__(self, other):  # -> Any:
        ...
    def __mod__(self, other):  # -> Any:
        ...
    def __pow__(self, other):  # -> Any:
        ...
    def __lt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __and__(self, other):  # -> Any:
        ...
    def __or__(self, other):  # -> Any:
        ...
    def __xor__(self, other):  # -> Any:
        ...
    def __invert__(self):  # -> Any:
        ...
    def __rshfit__(self, n):  # -> Any:
        ...
    def __lshift__(self, n):  # -> Any:
        ...

class OpsWrapper(DefaultHandler):
    @staticmethod
    def indirect_indexing(index, size, check=..., wrap_neg=...):  # -> Any:
        ...

ops: OpsHandler[Any] = ...

class _V:
    MockHandler = MockHandler
    KernelFormatterHandler = KernelFormatterHandler
    WrapperHandler = WrapperHandler
    set_ops_handler: Callable[[OpsHandler[Any]], AbstractContextManager[None]] = ...
    get_ops_handler: Callable[[], OpsHandler[Any]] = ...
    set_graph_handler: Callable[[GraphLowering], Any] = ...
    set_extern_kernel_nodes: Callable[[list[ExternKernelNode]], Any] = ...
    set_real_inputs: Callable[[Any], Any] = ...
    get_real_inputs: Callable[[], Any] = ...
    set_fake_mode: Callable[[Any], Any] = ...
    get_fake_mode: Callable[[], Any] = ...
    set_kernel_handler: Callable[[Any], Any] = ...
    set_debug_handler: Callable[[Any], Any] = ...
    set_interpreter_handler: Callable[[Any], Any] = ...
    set_aot_compilation: Callable[[bool], Any] = ...
    get_aot_compilation: Callable[[], Any] = ...
    set_current_node: Callable[[Any], Any] = ...
    get_current_node: Callable[[], Any] = ...
    set_local_buffer_context: Callable[[Any], Any] = ...
    get_local_buffer_context: Callable[[], Any] = ...
    set_choices_handler: Callable[[Any], Any] = ...
    @property
    def ops(self) -> OpsHandler[Any]: ...
    @property
    def graph(self) -> GraphLowering: ...
    @property
    def extern_kernel_nodes(self) -> list[ExternKernelNode]: ...
    @property
    def real_inputs(self):  # -> list[Tensor]:

        ...
    @property
    def fake_mode(self):  # -> FakeTensorMode:

        ...
    @property
    def kernel(self):  # -> NullKernelHandler:

        ...
    @property
    def debug(self):  # -> DebugContext:
        ...
    @property
    def interpreter(self):  # -> InterpreterShim:
        ...
    @property
    def aot_compilation(self):  # -> bool:
        ...
    @property
    def current_node(self):  # -> Node:
        ...
    @property
    def local_buffer_context(self):  # -> LocalBufferContext:
        ...
    @property
    def choices(self) -> InductorChoices: ...

V = ...
