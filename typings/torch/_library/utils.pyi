import dataclasses
from collections.abc import Callable, Iterable, Iterator
from typing import Any, Literal, overload

import torch
from torch import _C
from torch._ops import OpOverload

@dataclasses.dataclass
class Kernel:
    func: Callable
    source: str
    def __call__(self, *args, **kwargs): ...

class RegistrationHandle:
    def __init__(self, on_destroy: Callable) -> None: ...
    def destroy(self) -> None: ...

def get_source(stacklevel: int) -> str: ...
def parse_namespace(qualname: str) -> tuple[str, str]: ...
def lookup_op(qualname: str) -> OpOverload: ...
def is_builtin(op: OpOverload) -> bool: ...
def is_functional_schema(schema: Any) -> bool: ...
def is_tensorlist_like_type(typ: Any) -> bool: ...
def is_tensor_like_type(typ: Any) -> bool: ...
def mutates_and_returns_first_arg(op: OpOverload): ...
def fill_defaults(schema, args, kwargs): ...
def zip_schema(
    schema: _C.FunctionSchema, args: tuple[Any, ...], kwargs: dict[str, Any]
) -> Iterable[tuple[_C.Argument, Any]]: ...
def hop_schema_from_fx_node(node): ...
def can_generate_trivial_fake_impl(op: OpOverload) -> bool: ...
def requires_set_python_module() -> bool: ...
def handle_dispatch_mode(curr_mode, op_overload, *args, **kwargs): ...
def has_kwarg_only_args(schema: _C.FunctionSchema): ...
def has_kwarg_only_tensors(schema: _C.FunctionSchema): ...
def has_tensor_arg(schema: _C.FunctionSchema) -> bool: ...
def get_device_arg_index(schema: _C.FunctionSchema) -> int | None: ...
def iter_tensors(args: tuple[Any], kwargs: dict[str, Any], allowed_nesting: int = ...) -> Iterator[torch.Tensor]: ...
def check_aliasing_constraint(name, prev, result, get_module=...): ...

class MutationChecker:
    def __init__(self, op, flat_args, args_spec) -> None: ...
    def check(self): ...

def hash_tensor(t: torch.Tensor) -> torch.Tensor: ...
def has_fake_kernel(op: torch._ops.OpOverload) -> bool: ...
def mutated_args_kwargs(schema: _C.FunctionSchema) -> tuple[list[int], list[str]]: ...

tags_by_priority = ...

@overload
def get_layout_constraint_tag(fn: Any, *, with_default: Literal[True] = ...) -> _C.Tag: ...
@overload
def get_layout_constraint_tag(fn: Any, *, with_default: Literal[False]) -> _C.Tag | None: ...
def get_layout_constraint_tag(fn, *, with_default=...): ...
