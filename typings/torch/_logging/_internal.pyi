import contextlib
import functools
import logging
from collections.abc import Callable
from dataclasses import dataclass
from typing import Any, ParamSpec

from torch._guards import CompileId

_P = ParamSpec("_P")
log = ...
trace_log = ...
DEFAULT_LOG_LEVEL = ...
LOG_ENV_VAR = ...
LOG_OUT_ENV_VAR = ...
LOG_FORMAT_ENV_VAR = ...
LOG_TRACE_ID_FILTER = ...
TRACE_ENV_VAR = ...
DTRACE_ENV_VAR = ...
LOG_TRACE_HANDLER: LazyTraceHandler | None = ...
GET_DTRACE_STRUCTURED = ...

@dataclass
class LogRegistry:
    log_alias_to_log_qnames: dict[str, list[str]] = ...
    artifact_log_qnames: set[str] = ...
    child_log_qnames: set[str] = ...
    artifact_names: set[str] = ...
    visible_artifacts: set[str] = ...
    artifact_descriptions: dict[str, str] = ...
    off_by_default_artifact_names: set[str] = ...
    artifact_log_formatters: dict[str, logging.Formatter] = ...
    def is_artifact(self, name): ...
    def is_log(self, alias): ...
    def register_log(self, alias, log_qnames: str | list[str]) -> None: ...
    def register_artifact_name(self, name, description, visible, off_by_default, log_format) -> None: ...
    def register_artifact_log(self, artifact_log_qname) -> None: ...
    def register_child_log(self, log_qname) -> None: ...
    def get_log_qnames(self) -> set[str]: ...
    def get_artifact_log_qnames(self): ...
    def get_child_log_qnames(self): ...
    def is_off_by_default(self, artifact_qname): ...

@dataclass
class LogState:
    log_qname_to_level: dict[str, str] = ...
    artifact_names: set[str] = ...
    def enable_artifact(self, artifact_name) -> None: ...
    def is_artifact_enabled(self, name): ...
    def enable_log(self, log_qnames, log_level) -> None: ...
    def get_log_level_pairs(self): ...
    def clear(self) -> None: ...

log_registry = ...
log_state = ...
DEFAULT_LOGGING = ...

def set_logs(
    *,
    all: int | None = ...,
    dynamo: int | None = ...,
    aot: int | None = ...,
    autograd: int | None = ...,
    dynamic: int | None = ...,
    inductor: int | None = ...,
    distributed: int | None = ...,
    c10d: int | None = ...,
    ddp: int | None = ...,
    fsdp: int | None = ...,
    dtensor: int | None = ...,
    onnx: int | None = ...,
    bytecode: bool = ...,
    aot_graphs: bool = ...,
    aot_joint_graph: bool = ...,
    ddp_graphs: bool = ...,
    graph: bool = ...,
    graph_code: bool = ...,
    graph_code_verbose: bool = ...,
    graph_breaks: bool = ...,
    graph_sizes: bool = ...,
    guards: bool = ...,
    recompiles: bool = ...,
    recompiles_verbose: bool = ...,
    trace_source: bool = ...,
    trace_call: bool = ...,
    trace_bytecode: bool = ...,
    output_code: bool = ...,
    kernel_code: bool = ...,
    schedule: bool = ...,
    perf_hints: bool = ...,
    pre_grad_graphs: bool = ...,
    post_grad_graphs: bool = ...,
    ir_pre_fusion: bool = ...,
    ir_post_fusion: bool = ...,
    onnx_diagnostics: bool = ...,
    fusion: bool = ...,
    overlap: bool = ...,
    export: int | None = ...,
    modules: dict[str, int | bool] | None = ...,
    cudagraphs: bool = ...,
    sym_node: bool = ...,
    compiled_autograd: bool = ...,
    compiled_autograd_verbose: bool = ...,
    cudagraph_static_inputs: bool = ...,
    benchmarking: bool = ...,
    autotuning: bool = ...,
    graph_region_expansion: bool = ...,
    inductor_metrics: bool = ...,
    hierarchical_compile: bool = ...,
    compute_dependencies: bool = ...,
) -> None: ...
def get_loggers() -> list[logging.Logger]: ...
def register_log(setting_name, log_name) -> None: ...
def register_artifact(setting_name, description, visible=..., off_by_default=..., log_format=...) -> None: ...
def getArtifactLogger(module_qname, artifact_name) -> logging.Logger: ...

INCR_VERBOSITY_CHAR = ...
DECR_VERBOSITY_CHAR = ...
VERBOSITY_REGEX = ...

def configure_artifact_log(log) -> None: ...
def help_message(verbose=...): ...
def process_env_var_string_for_windows(env_var_str: str) -> str: ...
def make_module_path_relative(abs_path): ...

class TorchLogsFormatter(logging.Formatter):
    def __init__(self, *, trace: bool = ..., trace_id_filter: set[str] | None = ...) -> None: ...
    def format(self, record): ...

DEFAULT_FORMATTER = ...
handlers = ...

class LazyTraceHandler(logging.StreamHandler):
    def __init__(self, root_dir: str | None) -> None: ...
    def close(self) -> None: ...
    def emit(self, record) -> None: ...

@functools.cache
def warning_once(logger_obj, *args, **kwargs) -> None: ...
def safe_grad_filter(message, category, filename, lineno, file=..., line=...) -> bool: ...
def user_warning_filter(message, category, filename, lineno, file=..., line=...) -> bool: ...
@contextlib.contextmanager
def hide_warnings(filter_fn=...): ...

class LazyString[**P]:
    def __init__(self, func: Callable[_P, str], *args: _P.args, **kwargs: _P.kwargs) -> None: ...

structured_logging_overhead: dict[str, float] = ...

def add_structured_logging_overhead(time_spent: float) -> None: ...
def get_structured_logging_overhead() -> float | None: ...
def trace_structured_artifact(
    name: str, encoding: str, payload_fn: Callable[[], str | object | None] = ..., compile_id: CompileId | None = ...
) -> None: ...
def trace_structured(
    name: str,
    metadata_fn: Callable[[], dict[str, Any] | tuple[str, int]] = ...,
    *,
    payload_fn: Callable[[], str | object | None] = ...,
    suppress_context: bool = ...,
    expect_trace_id: bool = ...,
    record_logging_overhead: bool = ...,
    compile_id: CompileId | None = ...,
) -> None: ...
def dtrace_structured(
    name: str,
    metadata_fn: Callable[[], dict[str, Any] | tuple[str, int]] = ...,
    *,
    payload_fn: Callable[[], str | object | None] = ...,
    suppress_context: bool = ...,
    expect_trace_id: bool = ...,
    record_logging_overhead: bool = ...,
) -> None: ...
