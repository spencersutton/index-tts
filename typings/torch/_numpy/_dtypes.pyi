"""
Define analogs of numpy dtypes supported by pytorch.
Define the scalar types and supported dtypes and numpy <--> torch dtype mappings.
"""

class generic:
    name = ...
    def __new__(cls, value): ...

class number(generic):
    name = ...

class integer(number):
    name = ...

class inexact(number):
    name = ...

class signedinteger(integer):
    name = ...

class unsignedinteger(integer):
    name = ...

class floating(inexact):
    name = ...

class complexfloating(inexact):
    name = ...

_abstract_dtypes = ...

class int8(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class int16(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class int32(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class int64(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class uint8(unsignedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class uint16(unsignedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class uint32(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class uint64(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class float16(floating):
    name = ...
    typecode = ...
    torch_dtype = ...

class float32(floating):
    name = ...
    typecode = ...
    torch_dtype = ...

class float64(floating):
    name = ...
    typecode = ...
    torch_dtype = ...

class complex64(complexfloating):
    name = ...
    typecode = ...
    torch_dtype = ...

class complex128(complexfloating):
    name = ...
    typecode = ...
    torch_dtype = ...

class bool_(generic):
    name = ...
    typecode = ...
    torch_dtype = ...

_name_aliases = ...
sctypes = ...
_names = ...
_typecodes = ...
_torch_dtypes = ...
_aliases = ...
_python_types = ...

def sctype_from_string(s):
    """Normalize a string value: a type 'name' or a typecode or a width alias."""

def sctype_from_torch_dtype(torch_dtype): ...
def dtype(arg): ...

class DType:
    def __init__(self, arg) -> None: ...
    @property
    def name(self): ...
    @property
    def type(self): ...
    @property
    def kind(self): ...
    @property
    def typecode(self): ...
    def __eq__(self, other) -> bool: ...
    @property
    def torch_dtype(self): ...
    def __hash__(self) -> int: ...

    __str__ = ...
    @property
    def itemsize(self): ...
    def __getstate__(self): ...
    def __setstate__(self, value): ...

typecodes = ...

def set_default_dtype(fp_dtype=..., int_dtype=...):
    """
    Set the (global) defaults for fp, complex, and int dtypes.

    The complex dtype is inferred from the float (fp) dtype. It has
    a width at least twice the width of the float dtype,
    i.e., it's complex128 for float64 and complex64 for float32.

    Parameters
    ----------
    fp_dtype
        Allowed values are "numpy", "pytorch" or dtype_like things which
        can be converted into a DType instance.
        Default is "numpy" (i.e. float64).
    int_dtype
        Allowed values are "numpy", "pytorch" or dtype_like things which
        can be converted into a DType instance.
        Default is "numpy" (i.e. int64).

    Returns
    -------
    The old default dtype state: a namedtuple with attributes ``float_dtype``,
    ``complex_dtypes`` and ``int_dtype``. These attributes store *pytorch*
    dtypes.

    Notes
    ------------
    This functions has a side effect: it sets the global state with the provided dtypes.

    The complex dtype has bit width of at least twice the width of the float
    dtype, i.e. it's complex128 for float64 and complex64 for float32.
    """

def issubclass_(arg, klass): ...
def issubdtype(arg1, arg2): ...

__all__ = ["DType", "dtype", "issubdtype", "sctypes", "set_default_dtype", "typecodes"]
__all__ += list(_names.keys())
__all__ += list(_name_aliases.keys())
__all__ += _abstract_dtypes
