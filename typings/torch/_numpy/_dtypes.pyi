class generic:
    name = ...
    def __new__(cls, value):  # -> ndarray:
        ...

class number(generic):
    name = ...

class integer(number):
    name = ...

class inexact(number):
    name = ...

class signedinteger(integer):
    name = ...

class unsignedinteger(integer):
    name = ...

class floating(inexact):
    name = ...

class complexfloating(inexact):
    name = ...

_abstract_dtypes = ...

class int8(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class int16(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class int32(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class int64(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class uint8(unsignedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class uint16(unsignedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class uint32(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class uint64(signedinteger):
    name = ...
    typecode = ...
    torch_dtype = ...

class float16(floating):
    name = ...
    typecode = ...
    torch_dtype = ...

class float32(floating):
    name = ...
    typecode = ...
    torch_dtype = ...

class float64(floating):
    name = ...
    typecode = ...
    torch_dtype = ...

class complex64(complexfloating):
    name = ...
    typecode = ...
    torch_dtype = ...

class complex128(complexfloating):
    name = ...
    typecode = ...
    torch_dtype = ...

class bool_(generic):
    name = ...
    typecode = ...
    torch_dtype = ...

_name_aliases = ...
sctypes = ...
_names = ...
_typecodes = ...
_torch_dtypes = ...
_aliases = ...
_python_types = ...

def sctype_from_string(
    s,
):  # -> type[int8] | type[int16] | type[int32] | type[int64] | type[uint8] | type[uint16] | type[uint32] | type[uint64] | type[float16] | type[float32] | type[float64] | type[complex64] | type[complex128] | type[bool_]:

    ...
def sctype_from_torch_dtype(
    torch_dtype,
):  # -> type[int8] | type[int16] | type[int32] | type[int64] | type[uint8] | type[uint16] | type[uint32] | type[uint64] | type[float16] | type[float32] | type[float64] | type[complex64] | type[complex128] | type[bool_]:
    ...
def dtype(arg):  # -> DType:
    ...

class DType:
    def __init__(self, arg) -> None: ...
    @property
    def name(self):  # -> str:
        ...
    @property
    def type(
        self,
    ):  # -> type[int8] | type[int16] | type[int32] | type[int64] | type[uint8] | type[uint16] | type[uint32] | type[uint64] | type[float16] | type[float32] | type[float64] | type[complex64] | type[complex128] | type[bool_] | Any:
        ...
    @property
    def kind(self):  # -> str:
        ...
    @property
    def typecode(self):  # -> str:
        ...
    def __eq__(self, other) -> bool: ...
    @property
    def torch_dtype(self):  # -> dtype:
        ...
    def __hash__(self) -> int: ...
    def __repr__(self):  # -> str:
        ...

    __str__ = ...
    @property
    def itemsize(self): ...
    def __getstate__(
        self,
    ):  # -> type[int8] | type[int16] | type[int32] | type[int64] | type[uint8] | type[uint16] | type[uint32] | type[uint64] | type[float16] | type[float32] | type[float64] | type[complex64] | type[complex128] | type[bool_] | Any:
        ...
    def __setstate__(self, value):  # -> None:
        ...

typecodes = ...

def set_default_dtype(fp_dtype=..., int_dtype=...):  # -> Callable[[], DefaultDTypes]:

    ...
def issubclass_(arg, klass):  # -> bool:
    ...
def issubdtype(arg1, arg2):  # -> bool:
    ...

__all__ = ["dtype", "DType", "typecodes", "issubdtype", "set_default_dtype", "sctypes"]
__all__ += list(_names.keys())
__all__ += list(_name_aliases.keys())
__all__ += _abstract_dtypes
