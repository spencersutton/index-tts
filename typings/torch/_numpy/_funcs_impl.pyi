from collections.abc import Sequence

from ._normalizations import (
    ArrayLike,
    ArrayLikeOrScalar,
    CastingModes,
    DTypeLike,
    NDArray,
    NotImplementedType,
    OutArray,
)

def copy(a: ArrayLike, order: NotImplementedType = ..., subok: NotImplementedType = ...): ...
def copyto(dst: NDArray, src: ArrayLike, casting: CastingModes | None = ..., where: NotImplementedType = ...): ...
def atleast_1d(*arys: ArrayLike): ...
def atleast_2d(*arys: ArrayLike): ...
def atleast_3d(*arys: ArrayLike): ...
def concatenate(
    ar_tuple: Sequence[ArrayLike],
    axis=...,
    out: OutArray | None = ...,
    dtype: DTypeLike | None = ...,
    casting: CastingModes | None = ...,
): ...
def vstack(tup: Sequence[ArrayLike], *, dtype: DTypeLike | None = ..., casting: CastingModes | None = ...): ...

row_stack = ...

def hstack(tup: Sequence[ArrayLike], *, dtype: DTypeLike | None = ..., casting: CastingModes | None = ...): ...
def dstack(tup: Sequence[ArrayLike], *, dtype: DTypeLike | None = ..., casting: CastingModes | None = ...): ...
def column_stack(tup: Sequence[ArrayLike], *, dtype: DTypeLike | None = ..., casting: CastingModes | None = ...): ...
def stack(
    arrays: Sequence[ArrayLike],
    axis=...,
    out: OutArray | None = ...,
    *,
    dtype: DTypeLike | None = ...,
    casting: CastingModes | None = ...,
): ...
def append(arr: ArrayLike, values: ArrayLike, axis=...): ...
def array_split(ary: ArrayLike, indices_or_sections, axis=...): ...
def split(ary: ArrayLike, indices_or_sections, axis=...): ...
def hsplit(ary: ArrayLike, indices_or_sections): ...
def vsplit(ary: ArrayLike, indices_or_sections): ...
def dsplit(ary: ArrayLike, indices_or_sections): ...
def kron(a: ArrayLike, b: ArrayLike): ...
def vander(x: ArrayLike, N=..., increasing=...): ...
def linspace(
    start: ArrayLike, stop: ArrayLike, num=..., endpoint=..., retstep=..., dtype: DTypeLike | None = ..., axis=...
): ...
def geomspace(start: ArrayLike, stop: ArrayLike, num=..., endpoint=..., dtype: DTypeLike | None = ..., axis=...): ...
def logspace(start, stop, num=..., endpoint=..., base=..., dtype: DTypeLike | None = ..., axis=...): ...
def arange(
    start: ArrayLikeOrScalar | None = ...,
    stop: ArrayLikeOrScalar | None = ...,
    step: ArrayLikeOrScalar | None = ...,
    dtype: DTypeLike | None = ...,
    *,
    like: NotImplementedType = ...,
): ...
def empty(shape, dtype: DTypeLike | None = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...): ...
def empty_like(
    prototype: ArrayLike,
    dtype: DTypeLike | None = ...,
    order: NotImplementedType = ...,
    subok: NotImplementedType = ...,
    shape=...,
): ...
def full(
    shape,
    fill_value: ArrayLike,
    dtype: DTypeLike | None = ...,
    order: NotImplementedType = ...,
    *,
    like: NotImplementedType = ...,
): ...
def full_like(
    a: ArrayLike,
    fill_value,
    dtype: DTypeLike | None = ...,
    order: NotImplementedType = ...,
    subok: NotImplementedType = ...,
    shape=...,
): ...
def ones(shape, dtype: DTypeLike | None = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...): ...
def ones_like(
    a: ArrayLike,
    dtype: DTypeLike | None = ...,
    order: NotImplementedType = ...,
    subok: NotImplementedType = ...,
    shape=...,
): ...
def zeros(shape, dtype: DTypeLike | None = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...): ...
def zeros_like(
    a: ArrayLike,
    dtype: DTypeLike | None = ...,
    order: NotImplementedType = ...,
    subok: NotImplementedType = ...,
    shape=...,
): ...
def corrcoef(
    x: ArrayLike, y: ArrayLike | None = ..., rowvar=..., bias=..., ddof=..., *, dtype: DTypeLike | None = ...
): ...
def cov(
    m: ArrayLike,
    y: ArrayLike | None = ...,
    rowvar=...,
    bias=...,
    ddof=...,
    fweights: ArrayLike | None = ...,
    aweights: ArrayLike | None = ...,
    *,
    dtype: DTypeLike | None = ...,
): ...
def convolve(a: ArrayLike, v: ArrayLike, mode=...): ...
def correlate(a: ArrayLike, v: ArrayLike, mode=...): ...
def bincount(x: ArrayLike, /, weights: ArrayLike | None = ..., minlength=...): ...
def where(condition: ArrayLike, x: ArrayLikeOrScalar | None = ..., y: ArrayLikeOrScalar | None = ..., /): ...
def ndim(a: ArrayLike): ...
def shape(a: ArrayLike): ...
def size(a: ArrayLike, axis=...): ...
def expand_dims(a: ArrayLike, axis): ...
def flip(m: ArrayLike, axis=...): ...
def flipud(m: ArrayLike): ...
def fliplr(m: ArrayLike): ...
def rot90(m: ArrayLike, k=..., axes=...): ...
def broadcast_to(array: ArrayLike, shape, subok: NotImplementedType = ...): ...
def broadcast_arrays(*args: ArrayLike, subok: NotImplementedType = ...): ...
def meshgrid(*xi: ArrayLike, copy=..., sparse=..., indexing=...): ...
def indices(dimensions, dtype: DTypeLike | None = ..., sparse=...): ...
def tril(m: ArrayLike, k=...): ...
def triu(m: ArrayLike, k=...): ...
def tril_indices(n, k=..., m=...): ...
def triu_indices(n, k=..., m=...): ...
def tril_indices_from(arr: ArrayLike, k=...): ...
def triu_indices_from(arr: ArrayLike, k=...): ...
def tri(N, M=..., k=..., dtype: DTypeLike | None = ..., *, like: NotImplementedType = ...): ...
def isclose(a: ArrayLike, b: ArrayLike, rtol=..., atol=..., equal_nan=...): ...
def allclose(a: ArrayLike, b: ArrayLike, rtol=..., atol=..., equal_nan=...): ...
def array_equal(a1: ArrayLike, a2: ArrayLike, equal_nan=...): ...
def array_equiv(a1: ArrayLike, a2: ArrayLike): ...
def nan_to_num(x: ArrayLike, copy: NotImplementedType = ..., nan=..., posinf=..., neginf=...): ...
def take(a: ArrayLike, indices: ArrayLike, axis=..., out: OutArray | None = ..., mode: NotImplementedType = ...): ...
def take_along_axis(arr: ArrayLike, indices: ArrayLike, axis): ...
def put(a: NDArray, indices: ArrayLike, values: ArrayLike, mode: NotImplementedType = ...): ...
def put_along_axis(arr: ArrayLike, indices: ArrayLike, values: ArrayLike, axis): ...
def choose(a: ArrayLike, choices: Sequence[ArrayLike], out: OutArray | None = ..., mode: NotImplementedType = ...): ...
def unique(
    ar: ArrayLike,
    return_index: NotImplementedType = ...,
    return_inverse=...,
    return_counts=...,
    axis=...,
    *,
    equal_nan: NotImplementedType = ...,
): ...
def nonzero(a: ArrayLike): ...
def argwhere(a: ArrayLike): ...
def flatnonzero(a: ArrayLike): ...
def clip(a: ArrayLike, min: ArrayLike | None = ..., max: ArrayLike | None = ..., out: OutArray | None = ...): ...
def repeat(a: ArrayLike, repeats: ArrayLikeOrScalar, axis=...): ...
def tile(A: ArrayLike, reps): ...
def resize(a: ArrayLike, new_shape=...): ...
def diagonal(a: ArrayLike, offset=..., axis1=..., axis2=...): ...
def trace(
    a: ArrayLike, offset=..., axis1=..., axis2=..., dtype: DTypeLike | None = ..., out: OutArray | None = ...
): ...
def eye(
    N, M=..., k=..., dtype: DTypeLike | None = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...
): ...
def identity(n, dtype: DTypeLike | None = ..., *, like: NotImplementedType = ...): ...
def diag(v: ArrayLike, k=...): ...
def diagflat(v: ArrayLike, k=...): ...
def diag_indices(n, ndim=...): ...
def diag_indices_from(arr: ArrayLike): ...
def fill_diagonal(a: ArrayLike, val: ArrayLike, wrap=...): ...
def vdot(a: ArrayLike, b: ArrayLike, /): ...
def tensordot(a: ArrayLike, b: ArrayLike, axes=...): ...
def dot(a: ArrayLike, b: ArrayLike, out: OutArray | None = ...): ...
def inner(a: ArrayLike, b: ArrayLike, /): ...
def outer(a: ArrayLike, b: ArrayLike, out: OutArray | None = ...): ...
def cross(a: ArrayLike, b: ArrayLike, axisa=..., axisb=..., axisc=..., axis=...): ...
def einsum(*operands, out=..., dtype=..., order=..., casting=..., optimize=...): ...
def sort(a: ArrayLike, axis=..., kind=..., order: NotImplementedType = ...): ...
def argsort(a: ArrayLike, axis=..., kind=..., order: NotImplementedType = ...): ...
def searchsorted(a: ArrayLike, v: ArrayLike, side=..., sorter: ArrayLike | None = ...): ...
def moveaxis(a: ArrayLike, source, destination): ...
def swapaxes(a: ArrayLike, axis1, axis2): ...
def rollaxis(a: ArrayLike, axis, start=...): ...
def roll(a: ArrayLike, shift, axis=...): ...
def squeeze(a: ArrayLike, axis=...): ...
def reshape(a: ArrayLike, newshape, order: NotImplementedType = ...): ...
def transpose(a: ArrayLike, axes=...): ...
def ravel(a: ArrayLike, order: NotImplementedType = ...): ...
def diff(a: ArrayLike, n=..., axis=..., prepend: ArrayLike | None = ..., append: ArrayLike | None = ...): ...
def angle(z: ArrayLike, deg=...): ...
def sinc(x: ArrayLike): ...
def gradient(f: ArrayLike, *varargs, axis=..., edge_order=...): ...
def round(a: ArrayLike, decimals=..., out: OutArray | None = ...): ...

around = ...
round_ = ...

def real_if_close(a: ArrayLike, tol=...): ...
def real(a: ArrayLike): ...
def imag(a: ArrayLike): ...
def iscomplex(x: ArrayLike): ...
def isreal(x: ArrayLike): ...
def iscomplexobj(x: ArrayLike): ...
def isrealobj(x: ArrayLike): ...
def isneginf(x: ArrayLike, out: OutArray | None = ...): ...
def isposinf(x: ArrayLike, out: OutArray | None = ...): ...
def i0(x: ArrayLike): ...
def isscalar(a): ...
def hamming(M): ...
def hanning(M): ...
def kaiser(M, beta): ...
def blackman(M): ...
def bartlett(M): ...

array_type = ...
array_precision = ...

def common_type(*tensors: ArrayLike): ...
def histogram(
    a: ArrayLike, bins: ArrayLike = ..., range=..., normed=..., weights: ArrayLike | None = ..., density=...
): ...
def histogram2d(
    x, y, bins=..., range: ArrayLike | None = ..., normed=..., weights: ArrayLike | None = ..., density=...
): ...
def histogramdd(
    sample, bins=..., range: ArrayLike | None = ..., normed=..., weights: ArrayLike | None = ..., density=...
): ...
def min_scalar_type(a: ArrayLike, /): ...
def pad(array: ArrayLike, pad_width: ArrayLike, mode=..., **kwargs): ...
