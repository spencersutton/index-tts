from typing import Optional, TYPE_CHECKING
from collections.abc import Sequence
from ._normalizations import (
    ArrayLike,
    ArrayLikeOrScalar,
    CastingModes,
    DTypeLike,
    NDArray,
    NotImplementedType,
    OutArray,
)

"""A thin pytorch / numpy compat layer.

Things imported from here have numpy-compatible signatures but operate on
pytorch tensors.
"""
if TYPE_CHECKING: ...

def copy(a: ArrayLike, order: NotImplementedType = ..., subok: NotImplementedType = ...): ...
def copyto(
    dst: NDArray, src: ArrayLike, casting: Optional[CastingModes] = ..., where: NotImplementedType = ...
):  # -> None:
    ...
def atleast_1d(*arys: ArrayLike):  # -> list[Any] | Any:
    ...
def atleast_2d(*arys: ArrayLike):  # -> list[Any] | Any:
    ...
def atleast_3d(*arys: ArrayLike):  # -> list[Any] | Any:
    ...
def concatenate(
    ar_tuple: Sequence[ArrayLike],
    axis=...,
    out: Optional[OutArray] = ...,
    dtype: Optional[DTypeLike] = ...,
    casting: Optional[CastingModes] = ...,
):  # -> Tensor:
    ...
def vstack(
    tup: Sequence[ArrayLike], *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...
):  # -> Tensor:
    ...

row_stack = ...

def hstack(
    tup: Sequence[ArrayLike], *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...
):  # -> Tensor:
    ...
def dstack(
    tup: Sequence[ArrayLike], *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...
):  # -> Tensor:
    ...
def column_stack(
    tup: Sequence[ArrayLike], *, dtype: Optional[DTypeLike] = ..., casting: Optional[CastingModes] = ...
):  # -> Tensor:
    ...
def stack(
    arrays: Sequence[ArrayLike],
    axis=...,
    out: Optional[OutArray] = ...,
    *,
    dtype: Optional[DTypeLike] = ...,
    casting: Optional[CastingModes] = ...,
): ...
def append(arr: ArrayLike, values: ArrayLike, axis=...):  # -> Tensor:
    ...
def array_split(ary: ArrayLike, indices_or_sections, axis=...):  # -> tuple[Tensor, ...]:
    ...
def split(ary: ArrayLike, indices_or_sections, axis=...):  # -> tuple[Tensor, ...]:
    ...
def hsplit(ary: ArrayLike, indices_or_sections):  # -> tuple[Tensor, ...]:
    ...
def vsplit(ary: ArrayLike, indices_or_sections):  # -> tuple[Tensor, ...]:
    ...
def dsplit(ary: ArrayLike, indices_or_sections):  # -> tuple[Tensor, ...]:
    ...
def kron(a: ArrayLike, b: ArrayLike):  # -> Tensor:
    ...
def vander(x: ArrayLike, N=..., increasing=...):  # -> Tensor:
    ...
def linspace(
    start: ArrayLike, stop: ArrayLike, num=..., endpoint=..., retstep=..., dtype: Optional[DTypeLike] = ..., axis=...
): ...
def geomspace(
    start: ArrayLike, stop: ArrayLike, num=..., endpoint=..., dtype: Optional[DTypeLike] = ..., axis=...
):  # -> Tensor:
    ...
def logspace(start, stop, num=..., endpoint=..., base=..., dtype: Optional[DTypeLike] = ..., axis=...): ...
def arange(
    start: Optional[ArrayLikeOrScalar] = ...,
    stop: Optional[ArrayLikeOrScalar] = ...,
    step: Optional[ArrayLikeOrScalar] = ...,
    dtype: Optional[DTypeLike] = ...,
    *,
    like: NotImplementedType = ...,
): ...
def empty(
    shape, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...
): ...
def empty_like(
    prototype: ArrayLike,
    dtype: Optional[DTypeLike] = ...,
    order: NotImplementedType = ...,
    subok: NotImplementedType = ...,
    shape=...,
):  # -> Tensor:
    ...
def full(
    shape,
    fill_value: ArrayLike,
    dtype: Optional[DTypeLike] = ...,
    order: NotImplementedType = ...,
    *,
    like: NotImplementedType = ...,
): ...
def full_like(
    a: ArrayLike,
    fill_value,
    dtype: Optional[DTypeLike] = ...,
    order: NotImplementedType = ...,
    subok: NotImplementedType = ...,
    shape=...,
):  # -> Tensor:
    ...
def ones(
    shape, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...
): ...
def ones_like(
    a: ArrayLike,
    dtype: Optional[DTypeLike] = ...,
    order: NotImplementedType = ...,
    subok: NotImplementedType = ...,
    shape=...,
):  # -> Tensor:
    ...
def zeros(
    shape, dtype: Optional[DTypeLike] = ..., order: NotImplementedType = ..., *, like: NotImplementedType = ...
): ...
def zeros_like(
    a: ArrayLike,
    dtype: Optional[DTypeLike] = ...,
    order: NotImplementedType = ...,
    subok: NotImplementedType = ...,
    shape=...,
):  # -> Tensor:
    ...
def corrcoef(
    x: ArrayLike, y: Optional[ArrayLike] = ..., rowvar=..., bias=..., ddof=..., *, dtype: Optional[DTypeLike] = ...
):  # -> Tensor:
    ...
def cov(
    m: ArrayLike,
    y: Optional[ArrayLike] = ...,
    rowvar=...,
    bias=...,
    ddof=...,
    fweights: Optional[ArrayLike] = ...,
    aweights: Optional[ArrayLike] = ...,
    *,
    dtype: Optional[DTypeLike] = ...,
):  # -> Tensor:
    ...
def convolve(a: ArrayLike, v: ArrayLike, mode=...): ...
def correlate(a: ArrayLike, v: ArrayLike, mode=...): ...
def bincount(x: ArrayLike, /, weights: Optional[ArrayLike] = ..., minlength=...):  # -> Tensor:
    ...
def where(
    condition: ArrayLike, x: Optional[ArrayLikeOrScalar] = ..., y: Optional[ArrayLikeOrScalar] = ..., /
):  # -> tuple[Tensor, ...]:
    ...
def ndim(a: ArrayLike): ...
def shape(a: ArrayLike):  # -> tuple[Any, ...]:
    ...
def size(a: ArrayLike, axis=...): ...
def expand_dims(a: ArrayLike, axis): ...
def flip(m: ArrayLike, axis=...):  # -> Tensor:
    ...
def flipud(m: ArrayLike):  # -> Tensor:
    ...
def fliplr(m: ArrayLike):  # -> Tensor:
    ...
def rot90(m: ArrayLike, k=..., axes=...):  # -> Tensor:
    ...
def broadcast_to(array: ArrayLike, shape, subok: NotImplementedType = ...):  # -> Tensor:
    ...
def broadcast_arrays(*args: ArrayLike, subok: NotImplementedType = ...):  # -> Any:
    ...
def meshgrid(*xi: ArrayLike, copy=..., sparse=..., indexing=...):  # -> list[Any]:
    ...
def indices(dimensions, dtype: Optional[DTypeLike] = ..., sparse=...):  # -> tuple[()] | tuple[Any, ...]:
    ...
def tril(m: ArrayLike, k=...):  # -> Tensor:
    ...
def triu(m: ArrayLike, k=...):  # -> Tensor:
    ...
def tril_indices(n, k=..., m=...):  # -> Tensor:
    ...
def triu_indices(n, k=..., m=...):  # -> Tensor:
    ...
def tril_indices_from(arr: ArrayLike, k=...):  # -> Tensor:
    ...
def triu_indices_from(arr: ArrayLike, k=...):  # -> Tensor:
    ...
def tri(N, M=..., k=..., dtype: Optional[DTypeLike] = ..., *, like: NotImplementedType = ...):  # -> Tensor:
    ...
def isclose(a: ArrayLike, b: ArrayLike, rtol=..., atol=..., equal_nan=...):  # -> Tensor:
    ...
def allclose(a: ArrayLike, b: ArrayLike, rtol=..., atol=..., equal_nan=...): ...
def array_equal(a1: ArrayLike, a2: ArrayLike, equal_nan=...):  # -> Literal[False]:
    ...
def array_equiv(a1: ArrayLike, a2: ArrayLike):  # -> Literal[False]:
    ...
def nan_to_num(x: ArrayLike, copy: NotImplementedType = ..., nan=..., posinf=..., neginf=...):  # -> Tensor:
    ...
def take(a: ArrayLike, indices: ArrayLike, axis=..., out: Optional[OutArray] = ..., mode: NotImplementedType = ...): ...
def take_along_axis(arr: ArrayLike, indices: ArrayLike, axis):  # -> Tensor:
    ...
def put(a: NDArray, indices: ArrayLike, values: ArrayLike, mode: NotImplementedType = ...):  # -> None:
    ...
def put_along_axis(arr: ArrayLike, indices: ArrayLike, values: ArrayLike, axis):  # -> None:
    ...
def choose(
    a: ArrayLike, choices: Sequence[ArrayLike], out: Optional[OutArray] = ..., mode: NotImplementedType = ...
): ...
def unique(
    ar: ArrayLike,
    return_index: NotImplementedType = ...,
    return_inverse=...,
    return_counts=...,
    axis=...,
    *,
    equal_nan: NotImplementedType = ...,
):  # -> ...:
    ...
def nonzero(a: ArrayLike): ...
def argwhere(a: ArrayLike):  # -> Tensor:
    ...
def flatnonzero(a: ArrayLike):  # -> Tensor:
    ...
def clip(
    a: ArrayLike, min: Optional[ArrayLike] = ..., max: Optional[ArrayLike] = ..., out: Optional[OutArray] = ...
): ...
def repeat(a: ArrayLike, repeats: ArrayLikeOrScalar, axis=...): ...
def tile(A: ArrayLike, reps):  # -> Tensor:
    ...
def resize(a: ArrayLike, new_shape=...):  # -> ArrayLike | Tensor:
    ...
def diagonal(a: ArrayLike, offset=..., axis1=..., axis2=...):  # -> Tensor:
    ...
def trace(
    a: ArrayLike, offset=..., axis1=..., axis2=..., dtype: Optional[DTypeLike] = ..., out: Optional[OutArray] = ...
): ...
def eye(
    N,
    M=...,
    k=...,
    dtype: Optional[DTypeLike] = ...,
    order: NotImplementedType = ...,
    *,
    like: NotImplementedType = ...,
):  # -> Tensor:
    ...
def identity(n, dtype: Optional[DTypeLike] = ..., *, like: NotImplementedType = ...):  # -> Tensor:
    ...
def diag(v: ArrayLike, k=...):  # -> Tensor:
    ...
def diagflat(v: ArrayLike, k=...):  # -> Tensor:
    ...
def diag_indices(n, ndim=...):  # -> tuple[Tensor, ...]:
    ...
def diag_indices_from(arr: ArrayLike):  # -> tuple[Tensor, ...]:
    ...
def fill_diagonal(a: ArrayLike, val: ArrayLike, wrap=...):  # -> ArrayLike:
    ...
def vdot(a: ArrayLike, b: ArrayLike, /):  # -> Tensor:
    ...
def tensordot(a: ArrayLike, b: ArrayLike, axes=...):  # -> Any:
    ...
def dot(a: ArrayLike, b: ArrayLike, out: Optional[OutArray] = ...):  # -> Tensor:
    ...
def inner(a: ArrayLike, b: ArrayLike, /):  # -> Tensor:
    ...
def outer(a: ArrayLike, b: ArrayLike, out: Optional[OutArray] = ...):  # -> Tensor:
    ...
def cross(a: ArrayLike, b: ArrayLike, axisa=..., axisb=..., axisc=..., axis=...):  # -> Tensor:
    ...
def einsum(
    *operands, out=..., dtype=..., order=..., casting=..., optimize=...
):  # -> ndarray | list[Any] | tuple[Any, ...]:
    ...
def sort(a: ArrayLike, axis=..., kind=..., order: NotImplementedType = ...): ...
def argsort(a: ArrayLike, axis=..., kind=..., order: NotImplementedType = ...):  # -> Tensor:
    ...
def searchsorted(a: ArrayLike, v: ArrayLike, side=..., sorter: Optional[ArrayLike] = ...): ...
def moveaxis(a: ArrayLike, source, destination): ...
def swapaxes(a: ArrayLike, axis1, axis2):  # -> Tensor:
    ...
def rollaxis(a: ArrayLike, axis, start=...):  # -> ArrayLike:
    ...
def roll(a: ArrayLike, shift, axis=...):  # -> Tensor:
    ...
def squeeze(a: ArrayLike, axis=...):  # -> ArrayLike:
    ...
def reshape(a: ArrayLike, newshape, order: NotImplementedType = ...): ...
def transpose(a: ArrayLike, axes=...): ...
def ravel(a: ArrayLike, order: NotImplementedType = ...):  # -> Tensor:
    ...
def diff(
    a: ArrayLike, n=..., axis=..., prepend: Optional[ArrayLike] = ..., append: Optional[ArrayLike] = ...
):  # -> ArrayLike:
    ...
def angle(z: ArrayLike, deg=...):  # -> Tensor:
    ...
def sinc(x: ArrayLike):  # -> Tensor:
    ...
def gradient(f: ArrayLike, *varargs, axis=..., edge_order=...):  # -> list[Any]:
    ...
def round(a: ArrayLike, decimals=..., out: Optional[OutArray] = ...):  # -> Tensor | ArrayLike:
    ...

around = ...
round_ = ...

def real_if_close(a: ArrayLike, tol=...):  # -> ArrayLike:
    ...
def real(a: ArrayLike):  # -> Tensor:
    ...
def imag(a: ArrayLike):  # -> Tensor:
    ...
def iscomplex(x: ArrayLike):  # -> Tensor:
    ...
def isreal(x: ArrayLike):  # -> Tensor:
    ...
def iscomplexobj(x: ArrayLike): ...
def isrealobj(x: ArrayLike):  # -> bool:
    ...
def isneginf(x: ArrayLike, out: Optional[OutArray] = ...):  # -> Tensor:
    ...
def isposinf(x: ArrayLike, out: Optional[OutArray] = ...):  # -> Tensor:
    ...
def i0(x: ArrayLike):  # -> ...:
    ...
def isscalar(a):  # -> Literal[False]:
    ...
def hamming(M):  # -> Tensor:
    ...
def hanning(M):  # -> Tensor:
    ...
def kaiser(M, beta):  # -> Tensor:
    ...
def blackman(M):  # -> Tensor:
    ...
def bartlett(M):  # -> Tensor:
    ...

array_type = ...
array_precision = ...

def common_type(*tensors: ArrayLike):  # -> dtype | None:
    ...
def histogram(
    a: ArrayLike, bins: ArrayLike = ..., range=..., normed=..., weights: Optional[ArrayLike] = ..., density=...
):  # -> tuple[Tensor | Any, Tensor | Any]:
    ...
def histogram2d(
    x, y, bins=..., range: Optional[ArrayLike] = ..., normed=..., weights: Optional[ArrayLike] = ..., density=...
):  # -> tuple[Any, Any, Any]:
    ...
def histogramdd(
    sample, bins=..., range: Optional[ArrayLike] = ..., normed=..., weights: Optional[ArrayLike] = ..., density=...
):  # -> tuple[Any, list[Any] | Any]:
    ...
def min_scalar_type(a: ArrayLike, /):  # -> DType:
    ...
def pad(array: ArrayLike, pad_width: ArrayLike, mode=..., **kwargs): ...
