from ._normalizations import ArrayLike, NotImplementedType, normalizer

newaxis = ...
FLAGS = ...
SHORTHAND_TO_FLAGS = ...

class Flags:
    def __init__(self, flag_to_value: dict) -> None: ...
    def __getattr__(self, attr: str): ...
    def __getitem__(self, key): ...
    def __setattr__(self, attr, value):  # -> None:
        ...
    def __setitem__(self, key, value): ...

def create_method(fn, name=...):  # -> Callable[..., Any]:
    ...

methods = ...
dunder = ...
ri_dunder = ...

class _Unspecified: ...

class ndarray:
    def __init__(self, t=...) -> None: ...

    conj = ...
    conjugate = ...
    __divmod__ = ...
    __rdivmod__ = ...
    @property
    def shape(self):  # -> tuple[Any, ...]:
        ...
    @property
    def size(self): ...
    @property
    def ndim(self): ...
    @property
    def dtype(self):  # -> DType:
        ...
    @property
    def strides(self):  # -> tuple[Any, ...]:
        ...
    @property
    def itemsize(self): ...
    @property
    def flags(self):  # -> Flags:
        ...
    @property
    def data(self): ...
    @property
    def nbytes(self):  # -> int | Any:
        ...
    @property
    def T(self): ...
    @property
    def real(self): ...
    @real.setter
    def real(self, value):  # -> None:
        ...
    @property
    def imag(self): ...
    @imag.setter
    def imag(self, value):  # -> None:
        ...
    def astype(self, dtype, order=..., casting=..., subok=..., copy=...):  # -> ndarray:
        ...
    @normalizer
    def copy(self: ArrayLike, order: NotImplementedType = ...): ...
    @normalizer
    def flatten(self: ArrayLike, order: NotImplementedType = ...):  # -> Tensor:
        ...
    def resize(self, *new_shape, refcheck=...):  # -> None:
        ...
    def view(self, dtype=..., type=...):  # -> ndarray:
        ...
    @normalizer
    def fill(self, value: ArrayLike):  # -> None:
        ...
    def tolist(self):  # -> list[Any]:
        ...
    def __iter__(self):  # -> Generator[ndarray, None, None]:
        ...

    __repr__ = ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __index__(self):  # -> int:
        ...
    def __bool__(self):  # -> bool:
        ...
    def __int__(self) -> int: ...
    def __float__(self):  # -> float:
        ...
    def __complex__(self):  # -> complex:
        ...
    def is_integer(self):  # -> bool:
        ...
    def __len__(self): ...
    def __contains__(self, x):  # -> bool:
        ...
    def transpose(self, *axes): ...
    def reshape(self, *shape, order=...): ...
    def sort(self, axis=..., kind=..., order=...):  # -> None:
        ...
    def item(self, *args):  # -> Number:
        ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, value):  # -> None:
        ...

    take = ...
    put = ...
    def __dlpack__(self, *, stream=...):  # -> Any:
        ...
    def __dlpack_device__(self):  # -> tuple[IntEnum, int]:
        ...

def array(obj, dtype=..., *, copy=..., order=..., subok=..., ndmin=..., like=...):  # -> ndarray:
    ...
def asarray(a, dtype=..., order=..., *, like=...):  # -> ndarray:
    ...
def ascontiguousarray(a, dtype=..., *, like=...):  # -> ndarray:
    ...
def from_dlpack(x, /):  # -> ndarray:
    ...
def can_cast(from_, to, casting=...):  # -> bool:
    ...
def result_type(*arrays_and_dtypes):  # -> DType:
    ...
