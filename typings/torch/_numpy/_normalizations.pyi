import typing

""" "Normalize" arguments: convert array_likes to tensors, dtypes to torch dtypes and so on."""
ArrayLike = typing.TypeVar("ArrayLike")
type Scalar = int | float | complex | bool
type ArrayLikeOrScalar[ArrayLike] = ArrayLike | Scalar
DTypeLike = typing.TypeVar("DTypeLike")
AxisLike = typing.TypeVar("AxisLike")
NDArray = typing.TypeVar("NDArray")
CastingModes = typing.TypeVar("CastingModes")
KeepDims = typing.TypeVar("KeepDims")
OutArray = typing.TypeVar("OutArray")

def normalize_array_like(x, parm=...):  # -> Tensor:
    ...
def normalize_array_like_or_scalar(x, parm=...):  # -> Tensor:
    ...
def normalize_optional_array_like_or_scalar(x, parm=...):  # -> Tensor | None:
    ...
def normalize_optional_array_like(x, parm=...):  # -> Tensor | None:
    ...
def normalize_seq_array_like(x, parm=...):  # -> tuple[Tensor, ...]:
    ...
def normalize_dtype(dtype, parm=...):  # -> dtype | None:
    ...
def normalize_not_implemented(arg, parm):  # -> None:
    ...
def normalize_axis_like(arg, parm=...):  # -> int:
    ...
def normalize_ndarray(arg, parm=...):  # -> Tensor:
    ...
def normalize_outarray(arg, parm=...):  # -> ndarray:
    ...
def normalize_casting(arg, parm=...): ...

normalizers = ...

def maybe_normalize(arg, parm):  # -> dtype | Tensor | None:

    ...
def maybe_copy_to(out, result, promote_scalar_result=...):  # -> list[Any] | tuple[Any, ...]:
    ...
def wrap_tensors(result):  # -> ndarray | list[Any] | tuple[Any, ...]:
    ...
def array_or_scalar(values, py_type=..., return_scalar=...):  # -> float | ndarray:
    ...
def normalizer(
    _func=..., *, promote_scalar_result=...
):  # -> Callable[..., _Wrapped[..., Any, ..., ndarray | list[Any] | tuple[Any, ...] | Any]] | _Wrapped[..., Any, ..., ndarray | list[Any] | tuple[Any, ...] | Any]:
    ...
