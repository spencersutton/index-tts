import abc
import contextlib
import types
from collections.abc import Callable, Iterator
from typing import Any, ClassVar, Concatenate, ParamSpec, TypeVar, final

import torch
from torch._C import DispatchKey
from torch._functorch.pyfunctorch import TransformType
from torch._subclasses.functional_tensor import BaseFunctionalizeAPI
from torch.utils._python_dispatch import TorchDispatchMode

_T = TypeVar("_T", default=Any)
_P = ParamSpec("_P", default=...)
_SET_GLOBAL_FLAGS = ...

@contextlib.contextmanager
def dl_open_guard():
    """
    Context manager to set the RTLD_GLOBAL dynamic linker flag while we open a
    shared library to load custom operators.
    """

class OperatorBase:
    """
    Base class for OpOverload (which represents C++ ATen operators) and HigherOrderOperator
    (which represents Python-only operators that are unrepresentable in TorchScript).
    """
    def __init__(self) -> None: ...
    def __call__(self, *args, **kwargs): ...
    def has_kernel_for_dispatch_key(self, k): ...
    def has_kernel_for_any_dispatch_key(self, ks): ...
    def py_impl(
        self, k: type[TorchDispatchMode | torch.Tensor] | TransformType | DispatchKey
    ) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]: ...
    def py_functionalize_impl(
        self, fn: Callable[Concatenate[BaseFunctionalizeAPI, _P], _T]
    ) -> Callable[Concatenate[BaseFunctionalizeAPI, _P], _T]: ...
    def name(self): ...

def resolve_key(op: OperatorBase, k: DispatchKey): ...

_higher_order_ops: dict[str, HigherOrderOperator] = ...
_HIGHER_ORDER_OP_DEFAULT_FALLTHROUGH_DISPATCH_KEYS = ...

class HigherOrderOperator(OperatorBase, abc.ABC):
    def __init__(self, name, *, cacheable=...) -> None: ...
    def py_impl(
        self, k: type[TorchDispatchMode | torch.Tensor] | TransformType | DispatchKey
    ) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]: ...
    def py_autograd_impl(self, fn: Callable[_P, _T]) -> Callable[_P, _T]: ...
    @property
    def namespace(self): ...
    @final
    def cacheable(self) -> bool: ...
    def fallthrough(self, dispatch_key): ...
    def dispatch(self, /, dispatch_key, *args, **kwargs): ...
    @abc.abstractmethod
    def __call__(self, /, *args, **kwargs): ...
    def gen_schema(self, *args, **kwargs): ...
    def name(self): ...

def key_extractor(tensors, key_mask): ...

class _ModeStackStateForPreDispatch:
    def __init__(self) -> None: ...
    def set(self, index, mode): ...
    def get(self, index): ...
    def count(self): ...

_mode_stack_state_for_pre_dispatch = ...

def unset_mode_pre_dispatch(mode_key, schema_check=...): ...
def mode_stack_state_for_pre_dispatch(): ...

cached_ops: set[OpOverload] = ...

def add_cached_op(op_overload): ...
def reset_cached_ops(): ...
def get_cached_ops(): ...

class OpOverload[P = ..., T = Any](OperatorBase):
    def __init__(
        self,
        overloadpacket: OpOverloadPacket,
        op: Callable[_P, _T],
        op_dk: Callable[Concatenate[DispatchKey, _P], _T],
        schema: torch._C.FunctionSchema,
        tags: list[Any],
    ) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __call__(self, /, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
    def redispatch(self, /, keyset: torch._C.DispatchKeySet, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
    def __hash__(self) -> int: ...
    def has_kernel_for_dispatch_key(self, k: DispatchKey) -> bool: ...
    def has_kernel_for_any_dispatch_key(self, ks: torch._C.DispatchKeySet) -> bool: ...
    @property
    def namespace(self) -> str: ...
    def decompose(self, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
    def name(self): ...
    @property
    def overloadpacket(self): ...
    @property
    def op(self): ...
    @property
    def tags(self): ...

class TorchBindOpOverload(OpOverload[_P, _T]):
    def __call__(self, /, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...

class OpOverloadPacket[P = ..., T = Any]:
    __file__: ClassVar[str] = ...
    def __init__(
        self, qualified_op_name: str, op_name: str, op: Callable[_P, _T], overload_names: list[str]
    ) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __hash__(self) -> int: ...
    @property
    def op(self): ...
    def __getattr__(self, key: str) -> OpOverload[_P, _T]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __call__(self, /, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
    def overloads(self): ...

class _OpNamespace(types.ModuleType):
    """
    An op namespace to dynamically bind Operators into Python.

    Say a user has created a custom Operator called "my_namespace::my_op". To
    call this op, the user will write torch.ops.my_namespace.my_op(...).
    At startup, this operation will not yet be bound into Python. Instead, the
    following sequence of magic tricks will occur:
    1. `torch.ops.my_namespace` will invoke the `__getattr__` magic method
       on the `torch.ops` object, which will create a new `_OpNamespace`
       object called `my_namespace` and set it as an attribute on the `ops`
       object.
    2. `torch.ops.my_namespace.my_op` will then invoke `__getattr__` on
       the `my_namespace` object, which will retrieve the operation via
       `torch.get_operation`, a function bound from C++, and then in a similar
       fashion bind this new object onto the `my_namespace` object.
    3. `torch.ops.my_namespace.my_op(...)` then calls this new operation
        and subsequent accesses will incur no further lookup (the namespace and
        operation will already exist).
    """

    __file__ = ...
    def __init__(self, name: str) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __getattr__(self, op_name: str) -> OpOverloadPacket: ...

class _HigherOrderNamespace(types.ModuleType):
    __file__ = ...
    def __init__(self) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __getattr__(self, name: str) -> HigherOrderOperator: ...

class _Ops(types.ModuleType):
    __file__ = ...
    def __init__(self) -> None: ...
    def __getattr__(self, name: str) -> _OpNamespace: ...
    def __iter__(self) -> Iterator[str]: ...
    def import_module(self, module):
        """
        Imports a Python module that has torch.library registrations.

        Generally, to extend PyTorch with custom operators, a user will
        create a Python module whose import triggers registration of
        the custom operators via a torch.ops.load_library call or a call
        to one or more torch.library.* APIs.

        It is unexpected for Python modules to have side effects, so some
        linters and formatters will complain. Use this API to import Python
        modules that contain these torch.library side effects.

        Args:
            module (str): The name of the Python module to import
        """
    def load_library(self, path):
        """
        Loads a shared library from the given path into the current process.

        The library being loaded may run global initialization code to register
        custom operators with the PyTorch JIT runtime. This allows dynamically
        loading custom operators. For this, you should compile your operator
        and the static registration code into a shared library object, and then
        call ``torch.ops.load_library('path/to/libcustom.so')`` to load the
        shared object.

        After the library is loaded, it is added to the
        ``torch.ops.loaded_libraries`` attribute, a set that may be inspected
        for the paths of all libraries loaded using this function.

        Args:
            path (str): A path to a shared library to load.
        """

ops: _Ops = ...
