import abc
import contextlib
import types
from collections.abc import Callable, Iterator
from typing import Any, ClassVar, Concatenate, ParamSpec, TypeVar, final

import torch
from torch._C import DispatchKey
from torch._functorch.pyfunctorch import TransformType
from torch._subclasses.functional_tensor import BaseFunctionalizeAPI
from torch.utils._python_dispatch import TorchDispatchMode

_T = TypeVar("_T", default=Any)
_P = ParamSpec("_P", default=...)
_SET_GLOBAL_FLAGS = ...

@contextlib.contextmanager
def dl_open_guard(): ...

class OperatorBase:
    def __init__(self) -> None: ...
    def __call__(self, *args, **kwargs): ...
    def has_kernel_for_dispatch_key(self, k): ...
    def has_kernel_for_any_dispatch_key(self, ks): ...
    def py_impl(
        self, k: type[TorchDispatchMode | torch.Tensor] | TransformType | DispatchKey
    ) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]: ...
    def py_functionalize_impl(
        self, fn: Callable[Concatenate[BaseFunctionalizeAPI, _P], _T]
    ) -> Callable[Concatenate[BaseFunctionalizeAPI, _P], _T]: ...
    def name(self): ...

def resolve_key(op: OperatorBase, k: DispatchKey): ...

_higher_order_ops: dict[str, HigherOrderOperator] = ...
_HIGHER_ORDER_OP_DEFAULT_FALLTHROUGH_DISPATCH_KEYS = ...

class HigherOrderOperator(OperatorBase, abc.ABC):
    def __init__(self, name, *, cacheable=...) -> None: ...
    def py_impl(
        self, k: type[TorchDispatchMode | torch.Tensor] | TransformType | DispatchKey
    ) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]: ...
    def py_autograd_impl(self, fn: Callable[_P, _T]) -> Callable[_P, _T]: ...
    @property
    def namespace(self): ...
    @final
    def cacheable(self) -> bool: ...
    def fallthrough(self, dispatch_key): ...
    def dispatch(self, /, dispatch_key, *args, **kwargs): ...
    @abc.abstractmethod
    def __call__(self, /, *args, **kwargs): ...
    def gen_schema(self, *args, **kwargs): ...
    def name(self): ...

def key_extractor(tensors, key_mask): ...

class _ModeStackStateForPreDispatch:
    def __init__(self) -> None: ...
    def set(self, index, mode): ...
    def get(self, index): ...
    def count(self): ...

_mode_stack_state_for_pre_dispatch = ...

def unset_mode_pre_dispatch(mode_key, schema_check=...): ...
def mode_stack_state_for_pre_dispatch(): ...

cached_ops: set[OpOverload] = ...

def add_cached_op(op_overload): ...
def reset_cached_ops(): ...
def get_cached_ops(): ...

class OpOverload[**P = ..., T = Any](OperatorBase):
    def __init__(
        self,
        overloadpacket: OpOverloadPacket,
        op: Callable[_P, _T],
        op_dk: Callable[Concatenate[DispatchKey, _P], _T],
        schema: torch._C.FunctionSchema,
        tags: list[Any],
    ) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __call__(self, /, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
    def redispatch(self, /, keyset: torch._C.DispatchKeySet, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
    def __hash__(self) -> int: ...
    def has_kernel_for_dispatch_key(self, k: DispatchKey) -> bool: ...
    def has_kernel_for_any_dispatch_key(self, ks: torch._C.DispatchKeySet) -> bool: ...
    @property
    def namespace(self) -> str: ...
    def decompose(self, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
    def name(self): ...
    @property
    def overloadpacket(self): ...
    @property
    def op(self): ...
    @property
    def tags(self): ...

class TorchBindOpOverload(OpOverload[_P, _T]):
    def __call__(self, /, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...

class OpOverloadPacket[**P = ..., T = Any]:
    __file__: ClassVar[str] = ...
    def __init__(
        self, qualified_op_name: str, op_name: str, op: Callable[_P, _T], overload_names: list[str]
    ) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __hash__(self) -> int: ...
    @property
    def op(self): ...
    def __getattr__(self, key: str) -> OpOverload[_P, _T]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __call__(self, /, *args: _P.args, **kwargs: _P.kwargs) -> _T: ...
    def overloads(self): ...

class _OpNamespace(types.ModuleType):
    __file__ = ...
    def __init__(self, name: str) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __getattr__(self, op_name: str) -> OpOverloadPacket: ...

class _HigherOrderNamespace(types.ModuleType):
    __file__ = ...
    def __init__(self) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __getattr__(self, name: str) -> HigherOrderOperator: ...

class _Ops(types.ModuleType):
    __file__ = ...
    def __init__(self) -> None: ...
    def __getattr__(self, name: str) -> _OpNamespace: ...
    def __iter__(self) -> Iterator[str]: ...
    def import_module(self, module): ...
    def load_library(self, path): ...

ops: _Ops = ...
