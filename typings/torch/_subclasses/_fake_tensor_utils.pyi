import torch
import sympy
from dataclasses import dataclass
from typing import Optional, TYPE_CHECKING, Union
from torch import SymInt
from torch.fx.experimental.sym_node import SymNode
from torch.types import PySymType
from torch.utils._backport_slots import dataclass_slots
from torch.fx.experimental.symbolic_shapes import ShapeEnv
from .fake_tensor import _DispatchCacheKey, _MetadataIntLike

if TYPE_CHECKING: ...

@dataclass_slots
@dataclass(frozen=True)
class _DeconstructedSymNode:
    _expr: sympy.Expr
    pytype: type
    _hint: Optional[Union[int, float, bool]]
    constant: Optional[Union[int, float, bool]]
    fx_node: torch.fx.Node
    @staticmethod
    def from_node(node: SymNode) -> _DeconstructedSymNode: ...
    def extract(self, shape_env: ShapeEnv) -> SymNode: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

@dataclass_slots
@dataclass(frozen=True)
class _DeconstructedSymType:
    ty: type[PySymType]
    node: _DeconstructedSymNode
    @staticmethod
    def from_sym_type(value: PySymType) -> _DeconstructedSymType: ...
    def extract(self, shape_env: ShapeEnv) -> PySymType: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

@dataclass_slots
@dataclass(frozen=True)
class _InputBackref:
    value: int

@dataclass_slots
@dataclass
class _PySymInputStub:
    value: Union[PySymType, _DeconstructedSymType, _InputBackref]
    def __init__(self, value: Union[PySymType, _DeconstructedSymType, _InputBackref]) -> None: ...
    def strip_shape_env(self) -> None: ...
    def extract(self, shape_env: ShapeEnv) -> PySymType: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

@dataclass_slots
@dataclass
class _SymIntOutputStub:
    value: Union[int, _DeconstructedSymNode]
    def __init__(self, value: SymInt, key_path: Optional[int]) -> None: ...
    def extract(self, key: _DispatchCacheKey, shape_env: ShapeEnv) -> SymInt: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

@dataclass_slots
@dataclass
class _CacheKeyState:
    sym_node_lookup: dict[int, int]
    known_symbols: set[sympy.Symbol]
    shape_env: Optional[ShapeEnv]
    def __init__(self, shape_env: Optional[ShapeEnv] = ...) -> None: ...
    def cache_on_shape_env(self) -> bool: ...
    def convert_sym_int(self, result: list[object], arg: SymInt) -> None: ...
    def convert_output(self, arg: _MetadataIntLike) -> _MetadataIntLike: ...
