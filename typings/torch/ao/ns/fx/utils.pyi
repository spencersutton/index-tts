import enum
from collections.abc import Callable

import torch
from torch.fx import GraphModule
from torch.fx.graph import Node

from .ns_types import NSNodeTargetType, NSResultsType

toq = ...

class NodeInputOrOutputType(enum.Enum):
    FP32 = ...
    INT8 = ...
    FP16 = ...
    UNKNOWN = ...
    FP32_OR_INT8 = ...

def get_node_first_input_and_output_type(
    node: Node,
    gm: GraphModule,
    logger_cls: Callable,
    node_type_to_io_type_map: dict[str, set[NSNodeTargetType]],
) -> tuple[NodeInputOrOutputType, NodeInputOrOutputType]: ...
def get_node_input_qparams(
    node: Node,
    gm: GraphModule,
    node_type_to_io_type_map: dict[str, set[NSNodeTargetType]],
) -> tuple[torch.Tensor | float, torch.Tensor | int] | None: ...
def return_first_non_observer_node(node: Node, gm: GraphModule) -> Node: ...
def get_number_of_non_param_args(node: Node, gm: GraphModule) -> int: ...
def get_arg_indices_of_inputs_to_log(node: Node) -> list[int]: ...
def get_target_type_str(node: Node, gm: GraphModule) -> str: ...
def rekey_logger_info_on_node_name_of_model(results: NSResultsType, model_name: str) -> NSResultsType: ...
def maybe_add_missing_fqns(results: NSResultsType) -> None: ...
def maybe_dequantize_first_two_tensor_args_and_handle_tuples(
    f,
) -> Callable[..., list[Any] | Any | None]: ...
@maybe_dequantize_first_two_tensor_args_and_handle_tuples
def compute_sqnr(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor: ...
@maybe_dequantize_first_two_tensor_args_and_handle_tuples
def compute_normalized_l2_error(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor: ...
@maybe_dequantize_first_two_tensor_args_and_handle_tuples
def compute_cosine_similarity(x: torch.Tensor, y: torch.Tensor) -> torch.Tensor: ...
def op_type_supports_shadowing(node: Node) -> bool: ...
def get_normalized_nth_input(node: Node, gm: GraphModule, idx: int) -> Node: ...
