from collections.abc import Iterable
from contextlib import ContextDecorator as _ContextDecorator
from dataclasses import dataclass
from typing import Any
from torch.autograd import ProfilerActivity

__all__ = [
    "EnforceUnique",
    "EventList",
    "FunctionEvent",
    "KinetoStepTracker",
    "MemRecordsAcc",
    "emit_itt",
    "emit_nvtx",
    "load_nvprof",
    "parse_nvprof_trace",
    "profile",
    "record_function",
]
_is_profiler_enabled: bool = ...

@dataclass
class _ProfilerStats:
    profiling_window_duration_sec: float = ...
    number_of_events: int = ...
    profiler_prepare_call_duration_us: int = ...
    profiler_enable_call_duration_us: int = ...
    profiler_disable_call_duration_us: int = ...
    parse_kineto_call_duration_us: int = ...
    function_events_build_tree_call_duration_us: int = ...

class profile:
    def __init__(
        self,
        enabled=...,
        *,
        use_cuda=...,
        use_device=...,
        record_shapes=...,
        with_flops=...,
        profile_memory=...,
        with_stack=...,
        with_modules=...,
        use_kineto=...,
        use_cpu=...,
        experimental_config=...,
        acc_events=...,
        custom_trace_id_callback=...,
    ) -> None: ...
    def default_trace_id(self) -> str: ...
    def create_trace_id(self) -> str: ...
    def config(self, create_trace_id=...) -> ProfilerConfig: ...
    def __enter__(self) -> Self | None: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> Literal[False] | None: ...
    @property
    def function_events(self) -> EventList | None: ...
    def table(
        self,
        sort_by=...,
        row_limit=...,
        max_src_column_width=...,
        max_name_column_width=...,
        max_shapes_column_width=...,
        header=...,
        top_level_events_only=...,
    ): ...
    def export_chrome_trace(self, path) -> None: ...
    def export_stacks(self, path: str, metric: str = ...) -> None: ...
    def toggle_collection_dynamic(self, enabled: bool, activities: Iterable[ProfilerActivity]) -> None: ...
    def key_averages(self, group_by_input_shape=..., group_by_stack_n=..., group_by_overload_name=...) -> EventList: ...
    def total_average(self) -> FunctionEventAvg: ...
    @property
    def self_cpu_time_total(self) -> int: ...

class record_function(_ContextDecorator):
    def __init__(self, name: str, args: str | None = ...) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None: ...

class emit_itt:
    def __init__(self, enabled=..., record_shapes=...) -> None: ...
    def __enter__(self) -> Self | None: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> Literal[False] | None: ...

class emit_nvtx:
    def __init__(self, enabled=..., record_shapes=...) -> None: ...
    def __enter__(self) -> Self | None: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> Literal[False] | None: ...

def load_nvprof(path) -> EventList: ...

class EnforceUnique:
    def __init__(self) -> None: ...
    def see(self, *key) -> None: ...

def parse_nvprof_trace(path) -> list[Any]: ...

class KinetoStepTracker:
    _current_step = ...
    _step_dict: dict[str, int] = ...
    @classmethod
    def init_step_count(cls, requester: str) -> None: ...
    @classmethod
    def erase_step_count(cls, requester: str) -> bool: ...
    @classmethod
    def increment_step(cls, requester: str) -> int: ...
    @classmethod
    def current_step(cls) -> int: ...
