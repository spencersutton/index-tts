from collections.abc import Sequence

import torch
from torch import Tensor
from torch.distributions import constraints
from torch.distributions.distribution import Distribution
from torch.distributions.utils import lazy_property

__all__ = [
    "AbsTransform",
    "AffineTransform",
    "CatTransform",
    "ComposeTransform",
    "CorrCholeskyTransform",
    "CumulativeDistributionTransform",
    "ExpTransform",
    "IndependentTransform",
    "LowerCholeskyTransform",
    "PositiveDefiniteTransform",
    "PowerTransform",
    "ReshapeTransform",
    "SigmoidTransform",
    "SoftmaxTransform",
    "SoftplusTransform",
    "StackTransform",
    "StickBreakingTransform",
    "TanhTransform",
    "Transform",
    "identity_transform",
]

class Transform:
    bijective = ...
    domain: constraints.Constraint
    codomain: constraints.Constraint
    def __init__(self, cache_size: int = ...) -> None: ...
    def __getstate__(self) -> dict[str, Any]: ...
    @property
    def event_dim(self) -> int: ...
    @property
    def inv(self) -> Transform: ...
    @property
    def sign(self) -> int: ...
    def with_cache(self, cache_size=...) -> Self: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __call__(self, x) -> None: ...
    def log_abs_det_jacobian(self, x, y): ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

class _InverseTransform(Transform):
    def __init__(self, transform: Transform) -> None: ...
    @constraints.dependent_property(is_discrete=False)
    def domain(self) -> Constraint: ...
    @constraints.dependent_property(is_discrete=False)
    def codomain(self) -> Constraint: ...
    @property
    def bijective(self) -> bool: ...
    @property
    def sign(self) -> int: ...
    @property
    def inv(self) -> Transform: ...
    def with_cache(self, cache_size=...) -> Transform: ...
    def __eq__(self, other) -> bool: ...
    def __call__(self, x) -> None: ...
    def log_abs_det_jacobian(self, x, y): ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

class ComposeTransform(Transform):
    def __init__(self, parts: list[Transform], cache_size: int = ...) -> None: ...
    def __eq__(self, other) -> bool: ...
    @constraints.dependent_property(is_discrete=False)
    def domain(self) -> _Real | independent | Constraint: ...
    @constraints.dependent_property(is_discrete=False)
    def codomain(self) -> _Real | independent | Constraint: ...
    @lazy_property
    def bijective(self) -> bool: ...
    @lazy_property
    def sign(self) -> int: ...
    @property
    def inv(self) -> Transform: ...
    def with_cache(self, cache_size=...) -> Self | ComposeTransform: ...
    def __call__(self, x) -> None: ...
    def log_abs_det_jacobian(self, x, y) -> Tensor | Any: ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

identity_transform = ...

class IndependentTransform(Transform):
    def __init__(
        self,
        base_transform: Transform,
        reinterpreted_batch_ndims: int,
        cache_size: int = ...,
    ) -> None: ...
    def with_cache(self, cache_size=...) -> Self | IndependentTransform: ...
    @constraints.dependent_property(is_discrete=False)
    def domain(self) -> independent: ...
    @constraints.dependent_property(is_discrete=False)
    def codomain(self) -> independent: ...
    @property
    def bijective(self) -> bool: ...
    @property
    def sign(self) -> int: ...
    def log_abs_det_jacobian(self, x, y) -> Tensor: ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

class ReshapeTransform(Transform):
    bijective = ...
    def __init__(self, in_shape: torch.Size, out_shape: torch.Size, cache_size: int = ...) -> None: ...
    @constraints.dependent_property
    def domain(self) -> independent: ...
    @constraints.dependent_property
    def codomain(self) -> independent: ...
    def with_cache(self, cache_size=...) -> Self | ReshapeTransform: ...
    def log_abs_det_jacobian(self, x, y): ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

class ExpTransform(Transform):
    domain = ...
    codomain = ...
    bijective = ...
    sign = ...
    def __eq__(self, other) -> bool: ...
    def log_abs_det_jacobian(self, x, y): ...

class PowerTransform(Transform):
    domain = ...
    codomain = ...
    bijective = ...
    def __init__(self, exponent: Tensor, cache_size: int = ...) -> None: ...
    def with_cache(self, cache_size=...) -> Self | PowerTransform: ...
    @lazy_property
    def sign(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def log_abs_det_jacobian(self, x, y): ...
    def forward_shape(self, shape) -> Size | Any: ...
    def inverse_shape(self, shape) -> Size | Any: ...

class SigmoidTransform(Transform):
    domain = ...
    codomain = ...
    bijective = ...
    sign = ...
    def __eq__(self, other) -> bool: ...
    def log_abs_det_jacobian(self, x, y) -> Tensor: ...

class SoftplusTransform(Transform):
    domain = ...
    codomain = ...
    bijective = ...
    sign = ...
    def __eq__(self, other) -> bool: ...
    def log_abs_det_jacobian(self, x, y) -> Tensor: ...

class TanhTransform(Transform):
    domain = ...
    codomain = constraints.interval(-1, 1)
    bijective = ...
    sign = ...
    def __eq__(self, other) -> bool: ...
    def log_abs_det_jacobian(self, x, y): ...

class AbsTransform(Transform):
    domain = ...
    codomain = ...
    def __eq__(self, other) -> bool: ...

class AffineTransform(Transform):
    bijective = ...
    def __init__(
        self,
        loc: Tensor | float,
        scale: Tensor | float,
        event_dim: int = ...,
        cache_size: int = ...,
    ) -> None: ...
    @property
    def event_dim(self) -> int: ...
    @constraints.dependent_property(is_discrete=False)
    def domain(self) -> _Real | independent: ...
    @constraints.dependent_property(is_discrete=False)
    def codomain(self) -> _Real | independent: ...
    def with_cache(self, cache_size=...) -> Self | AffineTransform: ...
    def __eq__(self, other) -> bool: ...
    @property
    def sign(self) -> Tensor | int: ...
    def log_abs_det_jacobian(self, x, y) -> Tensor: ...
    def forward_shape(self, shape) -> Size | Any: ...
    def inverse_shape(self, shape) -> Size | Any: ...

class CorrCholeskyTransform(Transform):
    domain = constraints.real_vector
    codomain = ...
    bijective = ...
    def log_abs_det_jacobian(self, x, y, intermediates=...): ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

class SoftmaxTransform(Transform):
    domain = constraints.real_vector
    codomain = ...
    def __eq__(self, other) -> bool: ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

class StickBreakingTransform(Transform):
    domain = constraints.real_vector
    codomain = ...
    bijective = ...
    def __eq__(self, other) -> bool: ...
    def log_abs_det_jacobian(self, x, y): ...
    def forward_shape(self, shape): ...
    def inverse_shape(self, shape): ...

class LowerCholeskyTransform(Transform):
    domain = constraints.independent(constraints.real, 2)
    codomain = ...
    def __eq__(self, other) -> bool: ...

class PositiveDefiniteTransform(Transform):
    domain = constraints.independent(constraints.real, 2)
    codomain = ...
    def __eq__(self, other) -> bool: ...

class CatTransform(Transform):
    transforms: list[Transform]
    def __init__(
        self,
        tseq: Sequence[Transform],
        dim: int = ...,
        lengths: Sequence[int] | None = ...,
        cache_size: int = ...,
    ) -> None: ...
    @lazy_property
    def event_dim(self) -> int: ...
    @lazy_property
    def length(self) -> int: ...
    def with_cache(self, cache_size=...) -> Self | CatTransform: ...
    def log_abs_det_jacobian(self, x, y) -> Tensor | int: ...
    @property
    def bijective(self) -> bool: ...
    @constraints.dependent_property
    def domain(self) -> cat: ...
    @constraints.dependent_property
    def codomain(self) -> cat: ...

class StackTransform(Transform):
    transforms: list[Transform]
    def __init__(self, tseq: Sequence[Transform], dim: int = ..., cache_size: int = ...) -> None: ...
    def with_cache(self, cache_size=...) -> Self | StackTransform: ...
    def log_abs_det_jacobian(self, x, y) -> Tensor: ...
    @property
    def bijective(self) -> bool: ...
    @constraints.dependent_property
    def domain(self) -> stack: ...
    @constraints.dependent_property
    def codomain(self) -> stack: ...

class CumulativeDistributionTransform(Transform):
    bijective = ...
    codomain = ...
    sign = ...
    def __init__(self, distribution: Distribution, cache_size: int = ...) -> None: ...
    @property
    def domain(self) -> constraints.Constraint | None: ...
    def log_abs_det_jacobian(self, x, y) -> Tensor: ...
    def with_cache(self, cache_size=...) -> Self | CumulativeDistributionTransform: ...
