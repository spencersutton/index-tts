from collections.abc import Callable
from typing import Any, Final, TypeVar, overload

from torch import Tensor
from torch.types import Number

euler_constant: Final[float] = ...
__all__ = [
    "broadcast_all",
    "clamp_probs",
    "lazy_property",
    "logits_to_probs",
    "probs_to_logits",
    "tril_matrix_to_vec",
    "vec_to_tril_matrix",
]

def broadcast_all(*values: Tensor | Number) -> tuple[Tensor, ...]: ...
def logits_to_probs(logits: Tensor, is_binary: bool = ...) -> Tensor: ...
def clamp_probs(probs: Tensor) -> Tensor: ...
def probs_to_logits(probs: Tensor, is_binary: bool = ...) -> Tensor: ...

T = TypeVar("T", contravariant=True)
R = TypeVar("R", covariant=True)

class lazy_property[T, R]:
    def __init__(self, wrapped: Callable[[T], R]) -> None: ...
    @overload
    def __get__(self, instance: None, obj_type: Any = ...) -> _lazy_property_and_property[T, R]: ...
    @overload
    def __get__(self, instance: T, obj_type: Any = ...) -> R: ...
    def __get__(self, instance: T | None, obj_type: Any = ...) -> R | _lazy_property_and_property[T, R]: ...

class _lazy_property_and_property(lazy_property[T, R], property):
    def __init__(self, wrapped: Callable[[T], R]) -> None: ...

def tril_matrix_to_vec(mat: Tensor, diag: int = ...) -> Tensor: ...
def vec_to_tril_matrix(vec: Tensor, diag: int = ...) -> Tensor: ...
