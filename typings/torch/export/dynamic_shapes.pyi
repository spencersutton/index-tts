import dataclasses
from collections.abc import Callable
from enum import Enum
from typing import TYPE_CHECKING, Any

from torch.fx.experimental.symbolic_shapes import StrictMinMaxConstraint

if TYPE_CHECKING: ...
__all__ = [
    "AdditionalInputs",
    "Constraint",
    "Dim",
    "dims",
    "refine_dynamic_shapes_from_suggested_fixes",
]
log = ...

class _DimHintType(Enum):
    AUTO = ...
    STATIC = ...
    DYNAMIC = ...

@dataclasses.dataclass
class _DimHint:
    type: _DimHintType
    min: int | None = ...
    max: int | None = ...
    _factory: bool | None = ...
    @staticmethod
    def AUTO() -> _DimHint: ...
    @staticmethod
    def DYNAMIC() -> _DimHint: ...
    @staticmethod
    def STATIC() -> _DimHint: ...
    def __call__(self, min=..., max=...) -> _DimHint: ...

class Dim:
    AUTO = ...
    DYNAMIC = ...
    STATIC = ...
    def __init__(self, name: str, *, min: int | None = ..., max: int | None = ...) -> None: ...
    def __add__(self, other) -> Dim: ...
    def __radd__(self, other) -> Dim: ...
    def __sub__(self, other) -> Dim: ...
    def __rsub__(self, other) -> Dim: ...
    def __mul__(self, other) -> Dim: ...
    def __rmul__(self, other) -> Dim: ...

_Dim = Dim

class _StaticDim(Dim):
    def __init__(self, value: int) -> None: ...
    @property
    def min(self) -> int: ...
    @property
    def max(self) -> int: ...

class _DerivedDim(Dim):
    def __init__(self, name: str, root: Dim, fn: Callable) -> None: ...
    @property
    def min(self) -> int: ...
    @property
    def max(self) -> int: ...

def dims(*names: str, min: int | None = ..., max: int | None = ...) -> tuple[Dim, ...]: ...

@dataclasses.dataclass
class _ConstraintTarget:
    t_id: int
    dim: int

@dataclasses.dataclass
class _Constraint(_ConstraintTarget):
    name: str
    constraint_range: StrictMinMaxConstraint
    def __ge__(self, lower) -> bool: ...
    def __gt__(self, lower) -> bool: ...
    def __le__(self, upper) -> bool: ...
    def __lt__(self, upper) -> bool: ...
    def __bool__(self) -> bool: ...
    @property
    def serializable_spec(self) -> dict[str, int | Any]: ...

@dataclasses.dataclass
class _PhantomRoot:
    name: str
    constraint_range: StrictMinMaxConstraint
    val: int

@dataclasses.dataclass
class _DerivedConstraint(_ConstraintTarget):
    name: str
    constraint_range: StrictMinMaxConstraint
    root: _ConstraintTarget | _PhantomRoot
    fn: Callable
    @property
    def serializable_spec(self) -> dict[str, int | Any]: ...

@dataclasses.dataclass
class _RelaxedConstraint(_ConstraintTarget):
    @property
    def serializable_spec(self) -> dict[str, int]: ...

type Constraint = _Constraint | _DerivedConstraint | _RelaxedConstraint

@dataclasses.dataclass
class _IntWrapper:
    val: int
    dynamism: _DimHint | int | None = ...

class ShapesCollection:
    def __init__(self) -> None: ...
    def __setitem__(self, t, shape) -> None:  # -> None:
        ...
    def __getitem__(self, t): ...
    def __len__(self) -> int:  # -> int:
        ...
    def dynamic_shapes(self, m, args, kwargs=...) -> Any: ...

class AdditionalInputs:
    def __init__(self) -> None: ...
    def add(self, args, kwargs=...) -> None: ...
    def dynamic_shapes(self, m, args, kwargs=...) -> PyTree: ...
    def verify(self, ep) -> None: ...

def refine_dynamic_shapes_from_suggested_fixes(
    msg: str, dynamic_shapes: dict[str, Any] | tuple[Any] | list[Any]
) -> dict[str, Any] | tuple[Any] | list[Any]: ...
