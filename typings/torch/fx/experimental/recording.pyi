from collections.abc import Callable
from dataclasses import dataclass
from typing import Any

import torch

log = ...
trace_shape_events_log = ...
__all__ = [
    "FakeTensorMeta",
    "NotEqualError",
    "ShapeEnvEvent",
    "record_shapeenv_event",
    "replay_shape_env_events",
    "shape_env_check_state_equal",
]

@dataclass
class ShapeEnvEvent:
    """ShapeEnvEvent(f: Callable, args: Optional[list[Any]] = None, kwargs: Optional[dict[str, Any]] = None, tracked_fakes: Optional[list[Any]] = None, name: Optional[str] = None)"""

    f: Callable
    args: list[Any] | None = ...
    kwargs: dict[str, Any] | None = ...
    tracked_fakes: list[Any] | None = ...
    name: str | None = ...
    def run(self, shape_env=...) -> Any: ...
    def is_create_fx_call_function(self) -> bool: ...
    def is_evaluate_expr(self) -> bool: ...
    def is_defer_runtime_assert(self) -> bool: ...

NEST = ...

def record_shapeenv_event(*, save_tracked_fakes: bool = ..., name: str | None = ...) -> Callable: ...
def replay_shape_env_events(events): ...

@dataclass
class FakeTensorMeta:
    """FakeTensorMeta(tensor_size: tuple[typing.Union[int, torch.SymInt], ...], tensor_stride: tuple[typing.Union[int, torch.SymInt], ...], tensor_storage_offset: Union[int, torch.SymInt], is_nested: bool)"""

    tensor_size: tuple[int | torch.SymInt, ...]
    tensor_stride: tuple[int | torch.SymInt, ...]
    tensor_storage_offset: int | torch.SymInt
    is_nested: bool
    def size(self) -> tuple[int | torch.SymInt, ...]: ...
    def stride(self) -> tuple[int | torch.SymInt, ...]: ...
    def storage_offset(self) -> int | torch.SymInt: ...
    def dim(self) -> int: ...
    @staticmethod
    def from_fake(fake) -> FakeTensorMeta: ...

def shape_env_check_state_equal(env1, env2, non_state_variable_names, map_value) -> None: ...

class NotEqualError(Exception):
    def __init__(self, msg: str, mismatched: list[tuple[str, str, str]]) -> None: ...
