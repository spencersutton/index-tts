from typing import TYPE_CHECKING
from torch.fx.experimental.symbolic_shapes import ShapeEnv

if TYPE_CHECKING: ...
log = ...
sym_node_log = ...
__all__ = ["SymNode", "magic_methods", "method_to_operator"]

class SymNode:
    _optimized_summation: bool = ...
    def __init__(
        self, expr, shape_env, pytype, hint: float | bool | None, constant=..., fx_node=..., optimized_summation=...
    ) -> None: ...
    def with_shape_env(self, shape_env: ShapeEnv) -> SymNode: ...
    @property
    def expr(self): ...
    @property
    def hint(self) -> int | float | bool | None: ...
    def has_hint(self) -> bool: ...
    def require_hint(self, fallback=...) -> int | float | bool: ...
    def maybe_as_int(self) -> int | None: ...
    def maybe_as_float(self) -> float | None: ...
    def maybe_as_bool(self) -> bool | None: ...
    def is_int(self) -> bool: ...
    def is_float(self) -> bool: ...
    def is_bool(self) -> bool: ...
    def is_nested_int(self) -> Literal[False]: ...
    def wrap_int(self, num) -> SymNode: ...
    def wrap_float(self, num) -> SymNode: ...
    def wrap_bool(self, num) -> SymNode: ...
    def clone(self) -> Self: ...
    def str(self) -> str: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def abs(self) -> SymNode: ...
    def pos(self) -> SymNode: ...
    def round(self, ndigits=...) -> SymNode: ...
    def trunc(self) -> SymNode: ...
    def add(self, other) -> SymNode: ...
    def sub(self, other) -> SymNode: ...
    def mul(self, other) -> SymNode: ...
    def mod(self, other) -> SymNode: ...
    def float_pow(self, other) -> SymNode: ...
    def pow_by_natural(self, other) -> SymNode: ...
    def and_(self, other) -> SymNode: ...
    def or_(self, other) -> SymNode: ...
    def float_truediv(self, other) -> SymNode: ...
    def int_truediv(self, other) -> SymNode: ...
    def int_floordiv(self, other) -> SymNode: ...
    def lshift(self, other) -> SymNode: ...
    def rshift(self, other) -> SymNode: ...
    def sym_not(self) -> SymNode: ...
    def eq(self, other) -> SymNode: ...
    def ne(self, other) -> SymNode: ...
    def gt(self, other) -> SymNode: ...
    def lt(self, other) -> SymNode: ...
    def le(self, other) -> SymNode: ...
    def ge(self, other) -> SymNode: ...
    def floor(self) -> SymNode: ...
    def is_integer(self) -> SymNode: ...
    def sym_float(self) -> SymNode: ...
    def sym_int(self) -> SymNode: ...
    def ceil(self) -> SymNode: ...
    def neg(self) -> SymNode: ...
    def sym_min(self, other) -> SymNode: ...
    def sym_max(self, other) -> SymNode: ...
    def sym_ite(self, then_val, else_val) -> SymNode: ...
    def is_contiguous(self, sizes, strides) -> SymNode: ...
    def is_channels_last_contiguous_2d(self, sizes, strides) -> SymNode: ...
    def is_channels_last_contiguous_3d(self, sizes, strides) -> SymNode: ...
    def is_channels_last_strides_2d(self, sizes, strides) -> SymNode: ...
    def is_channels_last_strides_3d(self, sizes, strides) -> SymNode: ...
    def is_non_overlapping_and_dense_indicator(self, sizes, strides) -> SymNode: ...
    def sym_or(self, other) -> SymNode: ...
    def sym_and(self, other) -> SymNode: ...
    def bitwise_and(self, other): ...
    def bitwise_or(self, other): ...
    def truediv(self, other) -> SymNode: ...
    def floordiv(self, other) -> SymNode: ...
    def pow(self, other) -> SymNode: ...
    def is_non_overlapping_and_dense(self, sizes, strides) -> SymNode: ...
    def int_(self) -> int: ...
    def sym_sum(self, args) -> SymNode: ...
    def evaluate(self, size_oblivious=...): ...
    def guard_int(self, file, line) -> int: ...
    def guard_float(self, file, line) -> float: ...
    def guard_bool(self, file, line) -> bool: ...
    def expect_true(self, file, line) -> bool: ...
    def expect_size(self, file, line) -> bool: ...
    def statically_known_true(self, file, line) -> bool: ...
    def guard_size_oblivious(self, file, line) -> bool: ...
    def guard_or_false(self, file, line) -> bool: ...
    def guard_or_true(self, file, line) -> bool: ...
    def bool_(self) -> bool: ...
    def is_symbolic(self) -> Literal[True]: ...
    def nested_int(self) -> None: ...
    def is_constant(self) -> Literal[False]: ...

METHOD_TO_OPERATOR = ...
unary_magic_methods = ...
math_op_names = ...
unary_nonmagic_methods = ...
unary_methods = ...
only_bool_magic_methods = ...
bool_becomes_int_magic_methods = ...
also_bool_magic_methods = ...
bool_magic_methods = ...
only_float_magic_methods = ...
magic_methods_on_operator_with_trailing_underscore = ...
bitwise_ops = ...
always_float_magic_methods = ...
always_int_magic_methods = ...
always_bool_magic_methods = ...
reflectable_magic_methods = ...
current_module = ...
magic_methods = ...

def sympy_is_contiguous(sizes, strides) -> BooleanFalse | BooleanTrue | Boolean: ...
def sympy_is_contiguous_generic(sizes, strides, dim_order) -> BooleanFalse | BooleanTrue | Boolean: ...
def sympy_is_channels_last_contiguous_2d(sizes, strides) -> BooleanFalse | BooleanTrue | Boolean: ...
def sympy_is_channels_last_contiguous_3d(sizes, strides) -> BooleanFalse | BooleanTrue | Boolean: ...
def sympy_is_channels_last_strides_generic(sizes, strides, dim_order) -> BooleanFalse | Boolean: ...
def sympy_is_channels_last_strides_2d(sizes, strides) -> BooleanFalse | Boolean: ...
def sympy_is_channels_last_strides_3d(sizes, strides) -> BooleanFalse | Boolean: ...

sizes_strides_methods = ...

def to_node(self, num) -> _NotImplementedType: ...
def wrap_node(x) -> int | float | bool | SymInt | SymFloat | SymBool: ...
def method_to_operator(
    method,
) -> (
    Callable[[_SupportsPos[_T_co]], _T_co]
    | Callable[[SupportsAbs[_T]], _T]
    | Callable[[Any, Any], Any]
    | Callable[..., Any]
    | Callable[[object, object], Any]
    | Callable[[_SupportsTrunc[_T]], _T]
    | Callable[[_SupportsComparison, _SupportsComparison], Any]
    | Callable[[_SupportsNeg[_T_co]], _T_co]
    | Callable[..., Any | SymFloat | float]
    | Callable[..., Any | float]
    | Callable[..., Any | bool]
): ...
