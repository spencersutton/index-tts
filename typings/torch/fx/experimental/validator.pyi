from collections.abc import Callable
from dataclasses import dataclass
from typing import Any

import sympy
import torch
import torch.fx
import z3
from torch._dynamo.exc import TorchDynamoException
from torch.fx.node import Argument, Target

log = ...

def z3str(e: z3.ExprRef) -> str: ...

@dataclass
class _Z3Ops:
    validator: TranslationValidator
    @staticmethod
    def to_real(x: z3.ArithRef) -> z3.ArithRef: ...
    @staticmethod
    def to_int(x: z3.ArithRef) -> z3.ArithRef: ...
    def sym_sum(self, args: z3.ArithRef) -> z3.ArithRef: ...
    def div(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def floor(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def floordiv(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def ceil(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def trunc(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def max(self, a: z3.ArithRef, b: z3.ArithRef) -> z3.ArithRef: ...
    def min(self, a: z3.ArithRef, b: z3.ArithRef) -> z3.ArithRef: ...
    def mod(self, p: z3.ArithRef, q: z3.ArithRef) -> z3.ArithRef: ...
    def pow(self, base: z3.ArithRef, exp: z3.ArithRef) -> z3.ArithRef: ...
    def sqrt(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def abs(self, number: z3.ArithRef) -> z3.ArithRef: ...
    def round_to_int(self, number: z3.ArithRef) -> z3.ArithRef: ...

    bitwise_and = ...
    bitwise_or = ...
    lshift = ...
    rshift = ...

def z3op(op: Callable, validator: TranslationValidator) -> Callable: ...

class PopulateValidator(torch.fx.Interpreter):
    def __init__(self, graph: torch.fx.Graph, validator: TranslationValidator) -> None: ...
    def placeholder(self, target: Target, args: tuple[Argument, ...], kwargs: dict[str, Any]) -> Any: ...
    def call_function(self, target: Target, args: tuple[Argument, ...], kwargs: dict[str, Any]) -> Any: ...

class SympyToZ3:
    OPERATOR_HANDLES = ...
    def __init__(self, validator: TranslationValidator) -> None: ...
    def constant(self, value: Any, dtype: torch.dtype) -> z3.ExprRef: ...
    def to_dtype(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def trunc_to_int(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def round_to_int(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def int_truediv(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def truediv(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def floordiv(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def div(self, numerator: z3.ArithRef, denominator: z3.ArithRef) -> z3.ArithRef: ...
    def pow(self, base: z3.ArithRef, exp: z3.ArithRef) -> z3.ArithRef: ...
    def pow_by_natural(self, base: z3.ArithRef, exp: z3.ArithRef) -> z3.ArithRef: ...
    def mod(self, p: z3.ArithRef, q: z3.ArithRef) -> z3.ArithRef: ...
    def ceil_to_int(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def floor_to_int(self, x: z3.ArithRef, dtype: torch.dtype) -> z3.ArithRef: ...
    def __getattr__(self, name: str) -> Any: ...
    def run(self, expr: sympy.Basic) -> z3.ExprRef: ...

class TranslationValidator:
    def __init__(self) -> None: ...
    def z3var(self, symbol: sympy.Symbol) -> z3.ExprRef: ...
    def add_var(self, symbol: sympy.Symbol, type: type) -> z3.ExprRef: ...
    def to_z3_boolean_expr(self, e: sympy.Basic) -> z3.BoolRef: ...
    def add_source_expr(self, e: z3.BoolRef) -> None: ...
    def add_target_expr(self, e: sympy.logic.boolalg.Boolean) -> None: ...
    def add_assertion(self, e: z3.BoolRef | sympy.Basic) -> None: ...
    def validate(self) -> None: ...

def translation_validation_enabled() -> bool: ...
def translation_validation_timeout() -> int: ...

class ValidationException(TorchDynamoException):
    def __init__(self, model, assertions, target_exprs, failed_source_exprs) -> None: ...

class BisectValidationException(TorchDynamoException):
    def __init__(self, validation_exc, expr, failed_action, traced_node) -> None: ...

def bisect(shape_env) -> None: ...
