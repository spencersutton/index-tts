import torch
import torch.utils._pytree as pytree
from collections.abc import Callable
from dataclasses import dataclass
from typing import Any, Literal, NamedTuple, TYPE_CHECKING, TypeAlias
from ._compatibility import compatibility
from ._symbolic_trace import Tracer
from .graph_module import GraphModule
from .node import Argument, Node, Target

__all__ = ["CodeGen", "Graph", "PythonCode"]
if TYPE_CHECKING: ...
_origin_type_map = ...
_legal_ops = ...
TransformCodeFunc: TypeAlias = Callable[[list[str]], list[str]]

class _CustomBuiltin(NamedTuple):
    import_str: str
    obj: Any

_illegal_names = ...
_custom_builtins: dict[str, _CustomBuiltin] = ...
_snake_case_sub = ...
_illegal_char_regex = ...
_name_regex = ...
_torch_but_not_dynamo = ...

class _Namespace:
    def __init__(self) -> None: ...
    def create_name(self, candidate: str, obj: Any | None) -> str: ...
    def associate_name_with_obj(self, name: str, obj: Any) -> None: ...

@compatibility(is_backward_compatible=True)
@dataclass
class PythonCode:
    src: str
    globals: dict[str, Any]
    _lineno_map: dict[int, int | None] | None

class _InsertPoint:
    def __init__(self, graph, new_insert) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type, value, tb) -> None: ...

class _node_list:
    def __init__(self, graph: Graph, direction: Literal["_prev", "_next"] = ...) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> _NodeIter: ...
    def __reversed__(self) -> _node_list: ...

class _PyTreeInfo(NamedTuple):
    orig_args: list[str]
    in_spec: pytree.TreeSpec
    out_spec: pytree.TreeSpec | None

@dataclass(frozen=True)
class _ParsedStackTrace:
    file: str
    lineno: str
    name: str
    code: str
    def get_summary_str(self) -> str: ...

@compatibility(is_backward_compatible=False)
class CodeGen:
    _sym_repr: Callable[[torch.types.PySymType], str] = ...
    def __init__(self) -> None: ...
    def gen_fn_def(self, free_vars: list[str], maybe_return_annotation: str, *, expanded_def: bool = ...) -> str: ...
    def generate_output(self, output_args: Argument, *, descs: Any | None = ...) -> str: ...
    def process_inputs(self, *args: Any) -> Any: ...
    def process_outputs(self, outputs: Any) -> Any: ...
    def additional_globals(self) -> list[tuple[str, Any]]: ...

class _PyTreeCodeGen(CodeGen):
    def __init__(self, pytree_info: _PyTreeInfo) -> None: ...
    def process_inputs(self, *inputs: Any) -> Any: ...
    def process_outputs(self, out: Any) -> Any: ...
    def gen_fn_def(self, free_vars, maybe_return_annotation, *, expanded_def: bool = ...) -> str: ...
    def generate_output(self, output_args, *, descs: Any | None = ...) -> str: ...

class _FindNodesLookupTable:
    def __init__(self) -> None: ...
    def __contains__(self, node) -> bool: ...
    def insert(self, node: Node) -> None: ...
    def remove(self, node: Node) -> None: ...
    def find_nodes(self, *, op: str, target: Target | None = ...) -> list[Node]: ...

@compatibility(is_backward_compatible=True)
class Graph:
    @compatibility(is_backward_compatible=True)
    def __init__(
        self,
        owning_module: GraphModule | None = ...,
        tracer_cls: type[Tracer] | None = ...,
        tracer_extras: dict[str, Any] | None = ...,
    ) -> None: ...
    @property
    def owning_module(self) -> GraphModule | None: ...
    @owning_module.setter
    def owning_module(self, mod: GraphModule | None) -> None: ...
    @property
    def nodes(self) -> _node_list: ...
    @compatibility(is_backward_compatible=False)
    def output_node(self) -> Node: ...
    @compatibility(is_backward_compatible=False)
    def find_nodes(self, *, op: str, target: Target | None = ..., sort: bool = ...) -> list[Node]: ...
    @compatibility(is_backward_compatible=True)
    def graph_copy(self, g: Graph, val_map: dict[Node, Node], return_output_node=...) -> Argument | None: ...
    def __deepcopy__(self, memo=...) -> Graph: ...
    @compatibility(is_backward_compatible=True)
    def create_node(
        self,
        op: str,
        target: Target,
        args: tuple[Argument, ...] | None = ...,
        kwargs: dict[str, Argument] | None = ...,
        name: str | None = ...,
        type_expr: Any | None = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=False)
    def process_inputs(self, *args) -> Any: ...
    @compatibility(is_backward_compatible=False)
    def process_outputs(self, out) -> Any: ...
    @compatibility(is_backward_compatible=True)
    def erase_node(self, to_erase: Node) -> None: ...
    @compatibility(is_backward_compatible=True)
    def inserting_before(self, n: Node | None = ...) -> _InsertPoint: ...
    @compatibility(is_backward_compatible=True)
    def inserting_after(self, n: Node | None = ...) -> _InsertPoint: ...
    @compatibility(is_backward_compatible=True)
    def placeholder(self, name: str, type_expr: Any | None = ..., default_value: Any = ...) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def get_attr(self, qualified_name: str, type_expr: Any | None = ...) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def call_module(
        self,
        module_name: str,
        args: tuple[Argument, ...] | None = ...,
        kwargs: dict[str, Argument] | None = ...,
        type_expr: Any | None = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def call_method(
        self,
        method_name: str,
        args: tuple[Argument, ...] | None = ...,
        kwargs: dict[str, Argument] | None = ...,
        type_expr: Any | None = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def call_function(
        self,
        the_function: Callable[..., Any],
        args: tuple[Argument, ...] | None = ...,
        kwargs: dict[str, Argument] | None = ...,
        type_expr: Any | None = ...,
        name: str | None = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def node_copy(self, node: Node, arg_transform: Callable[[Node], Argument] = ...) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def output(self, result: Argument, type_expr: Any | None = ...) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def python_code(
        self,
        root_module: str,
        *,
        verbose: bool = ...,
        include_stride: bool = ...,
        include_device: bool = ...,
        colored: bool = ...,
        expanded_def: bool = ...,
    ) -> PythonCode: ...
    @compatibility(is_backward_compatible=True)
    def print_tabular(self) -> None: ...
    @compatibility(is_backward_compatible=True)
    def lint(self) -> None: ...
    @compatibility(is_backward_compatible=True)
    def eliminate_dead_code(self, is_impure_node: Callable[[Node], bool] | None = ...) -> bool: ...
    @compatibility(is_backward_compatible=False)
    def set_codegen(self, codegen: CodeGen) -> None: ...
    @compatibility(is_backward_compatible=False)
    def on_generate_code(
        self, make_transformer: Callable[[TransformCodeFunc | None], TransformCodeFunc]
    ) -> _GeneratorContextManager[None, None, None]: ...

_color_codes = ...
_color_fns = ...
_counter_regexp = ...
reflectable_magic_methods = ...
magic_methods = ...
inplace_methods = ...
