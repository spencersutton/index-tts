import torch
import torch.utils._pytree as pytree
from dataclasses import dataclass
from typing import Any, Callable, Literal, NamedTuple, Optional, TYPE_CHECKING, TypeAlias
from ._compatibility import compatibility
from .node import Argument, Node, Target
from ._symbolic_trace import Tracer
from .graph_module import GraphModule

__all__ = ["PythonCode", "CodeGen", "Graph"]
if TYPE_CHECKING: ...
_origin_type_map = ...
_legal_ops = ...
TransformCodeFunc: TypeAlias = Callable[[list[str]], list[str]]

class _CustomBuiltin(NamedTuple):
    import_str: str
    obj: Any

_illegal_names = ...
_custom_builtins: dict[str, _CustomBuiltin] = ...
_snake_case_sub = ...
_illegal_char_regex = ...
_name_regex = ...
_torch_but_not_dynamo = ...

class _Namespace:
    def __init__(self) -> None: ...
    def create_name(self, candidate: str, obj: Optional[Any]) -> str: ...
    def associate_name_with_obj(self, name: str, obj: Any):  # -> None:

        ...

@compatibility(is_backward_compatible=True)
@dataclass
class PythonCode:
    src: str
    globals: dict[str, Any]
    _lineno_map: Optional[dict[int, Optional[int]]]

class _InsertPoint:
    def __init__(self, graph, new_insert) -> None: ...
    def __enter__(self):  # -> None:
        ...
    def __exit__(self, type, value, tb):  # -> None:
        ...

class _node_list:
    def __init__(self, graph: Graph, direction: Literal["_prev", "_next"] = ...) -> None: ...
    def __len__(self):  # -> int:
        ...
    def __iter__(self):  # -> _NodeIter:
        ...
    def __reversed__(self):  # -> _node_list:
        ...

class _PyTreeInfo(NamedTuple):
    orig_args: list[str]
    in_spec: pytree.TreeSpec
    out_spec: Optional[pytree.TreeSpec]

@dataclass(frozen=True)
class _ParsedStackTrace:
    file: str
    lineno: str
    name: str
    code: str
    def get_summary_str(self):  # -> str:
        ...

@compatibility(is_backward_compatible=False)
class CodeGen:
    _sym_repr: Callable[[torch.types.PySymType], str] = ...
    def __init__(self) -> None: ...
    def gen_fn_def(self, free_vars: list[str], maybe_return_annotation: str, *, expanded_def: bool = ...) -> str: ...
    def generate_output(self, output_args: Argument, *, descs: Optional[Any] = ...) -> str: ...
    def process_inputs(self, *args: Any) -> Any: ...
    def process_outputs(self, outputs: Any) -> Any: ...
    def additional_globals(self) -> list[tuple[str, Any]]: ...

class _PyTreeCodeGen(CodeGen):
    def __init__(self, pytree_info: _PyTreeInfo) -> None: ...
    def process_inputs(self, *inputs: Any) -> Any: ...
    def process_outputs(self, out: Any) -> Any: ...
    def gen_fn_def(self, free_vars, maybe_return_annotation, *, expanded_def: bool = ...):  # -> str:
        ...
    def generate_output(self, output_args, *, descs: Optional[Any] = ...):  # -> str:
        ...

class _FindNodesLookupTable:
    def __init__(self) -> None: ...
    def __contains__(self, node) -> bool: ...
    def insert(self, node: Node) -> None: ...
    def remove(self, node: Node) -> None: ...
    def find_nodes(self, *, op: str, target: Optional[Target] = ...):  # -> list[Node]:
        ...

@compatibility(is_backward_compatible=True)
class Graph:
    @compatibility(is_backward_compatible=True)
    def __init__(
        self,
        owning_module: Optional[GraphModule] = ...,
        tracer_cls: Optional[type[Tracer]] = ...,
        tracer_extras: Optional[dict[str, Any]] = ...,
    ) -> None: ...
    @property
    def owning_module(self):  # -> GraphModule | None:
        ...
    @owning_module.setter
    def owning_module(self, mod: Optional[GraphModule]):  # -> None:
        ...
    @property
    def nodes(self) -> _node_list: ...
    @compatibility(is_backward_compatible=False)
    def output_node(self) -> Node: ...
    @compatibility(is_backward_compatible=False)
    def find_nodes(self, *, op: str, target: Optional[Target] = ..., sort: bool = ...):  # -> list[Node]:

        ...
    @compatibility(is_backward_compatible=True)
    def graph_copy(self, g: Graph, val_map: dict[Node, Node], return_output_node=...) -> Optional[Argument]: ...
    def __deepcopy__(self, memo=...) -> Graph: ...
    @compatibility(is_backward_compatible=True)
    def create_node(
        self,
        op: str,
        target: Target,
        args: Optional[tuple[Argument, ...]] = ...,
        kwargs: Optional[dict[str, Argument]] = ...,
        name: Optional[str] = ...,
        type_expr: Optional[Any] = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=False)
    def process_inputs(self, *args):  # -> Any:

        ...
    @compatibility(is_backward_compatible=False)
    def process_outputs(self, out):  # -> Any:
        ...
    @compatibility(is_backward_compatible=True)
    def erase_node(self, to_erase: Node) -> None: ...
    @compatibility(is_backward_compatible=True)
    def inserting_before(self, n: Optional[Node] = ...):  # -> _InsertPoint:

        ...
    @compatibility(is_backward_compatible=True)
    def inserting_after(self, n: Optional[Node] = ...):  # -> _InsertPoint:

        ...
    @compatibility(is_backward_compatible=True)
    def placeholder(self, name: str, type_expr: Optional[Any] = ..., default_value: Any = ...) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def get_attr(self, qualified_name: str, type_expr: Optional[Any] = ...) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def call_module(
        self,
        module_name: str,
        args: Optional[tuple[Argument, ...]] = ...,
        kwargs: Optional[dict[str, Argument]] = ...,
        type_expr: Optional[Any] = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def call_method(
        self,
        method_name: str,
        args: Optional[tuple[Argument, ...]] = ...,
        kwargs: Optional[dict[str, Argument]] = ...,
        type_expr: Optional[Any] = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def call_function(
        self,
        the_function: Callable[..., Any],
        args: Optional[tuple[Argument, ...]] = ...,
        kwargs: Optional[dict[str, Argument]] = ...,
        type_expr: Optional[Any] = ...,
        name: Optional[str] = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def node_copy(self, node: Node, arg_transform: Callable[[Node], Argument] = ...) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def output(self, result: Argument, type_expr: Optional[Any] = ...):  # -> Node:

        ...
    @compatibility(is_backward_compatible=True)
    def python_code(
        self,
        root_module: str,
        *,
        verbose: bool = ...,
        include_stride: bool = ...,
        include_device: bool = ...,
        colored: bool = ...,
        expanded_def: bool = ...,
    ) -> PythonCode: ...
    @compatibility(is_backward_compatible=True)
    def print_tabular(self):  # -> None:

        ...
    @compatibility(is_backward_compatible=True)
    def lint(self):  # -> None:

        ...
    @compatibility(is_backward_compatible=True)
    def eliminate_dead_code(self, is_impure_node: Optional[Callable[[Node], bool]] = ...) -> bool: ...
    @compatibility(is_backward_compatible=False)
    def set_codegen(self, codegen: CodeGen):  # -> None:
        ...
    @compatibility(is_backward_compatible=False)
    def on_generate_code(
        self, make_transformer: Callable[[Optional[TransformCodeFunc]], TransformCodeFunc]
    ):  # -> _GeneratorContextManager[None, None, None]:

        ...

_color_codes = ...
_color_fns = ...
_counter_regexp = ...
reflectable_magic_methods = ...
magic_methods = ...
inplace_methods = ...
