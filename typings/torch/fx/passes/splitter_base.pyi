from collections.abc import Iterable, Sequence
from dataclasses import dataclass
from typing import Any, Literal, NamedTuple

import torch
from torch.fx._compatibility import compatibility

from .operator_support import OperatorSupportBase
from .tools_common import NodeList, NodeSet

__all__ = [
    "FxNetAccNodesFinder",
    "FxNetSplitterInternalError",
    "NodeEvent",
    "NodeEventTracker",
    "SplitResult",
    "Subgraph",
    "generate_inputs_for_submodules",
]
_LOGGER = ...
DEFAULT_MIN_ACC_MODULE_SIZE = ...
DEFAULT_SKIP_FUSION = ...
DEFAULT_ALLOW_NON_TENSOR = ...
TRACKER_DUMP_PATH = ...
NODES_SUFFIX = ...
ALL_SUFFIX = ...
ENV_FX_NET_ACC_SPLITTER_TRACKER_MODE = ...
ENV_FX_NET_ACC_SPLITTER_TRACKER_DUMP_PATH = ...
ENV_FX_NET_ACC_SPLITTER_TRACKER_TRACKED_NODES = ...
DUMP_PREFIX = ...
TRACKER_MODE: Literal["0", "1", "2", "3"] = ...

class _SplitterSettingBase:
    def __init__(
        self,
        min_acc_module_size=...,
        skip_fusion=...,
        allow_non_tensor=...,
        max_acc_splits: int = ...,
    ) -> None: ...

@compatibility(is_backward_compatible=False)
class NodeEvent:
    def __init__(self, source: torch.fx.Node, desc: str, dep: torch.fx.Node | None = ...) -> None: ...
    def to_str(self) -> str: ...

@compatibility(is_backward_compatible=False)
class NodeEventTracker:
    def __init__(self, tracker_mode, dump_prefix) -> None: ...
    def add(self, node: torch.fx.Node, desc: str, dep: torch.fx.Node | None = ...) -> None: ...
    def print_node(self, node_name, recursive=..., tab=..., writer=...) -> None: ...
    def to_dict(self) -> dict[str, list[str]]: ...
    def print_all(self, writer=...) -> None: ...
    def dump(self) -> None: ...

@compatibility(is_backward_compatible=False)
class FxNetAccNodesFinder:
    def __init__(
        self,
        module: torch.fx.GraphModule,
        operator_support: OperatorSupportBase,
        allow_non_tensor: bool,
    ) -> None: ...
    def reduce_acc_nodes_non_tensor_input_helper(self, cpu_worklist: NodeList) -> None: ...
    def reduce_acc_nodes_non_tensor_input(self) -> None: ...
    def reduce_acc_nodes_non_tensor_output(self) -> None: ...
    def __call__(self) -> NodeSet: ...

@compatibility(is_backward_compatible=False)
class FxNetSplitterInternalError(Exception): ...

@compatibility(is_backward_compatible=False)
@dataclass
class Subgraph:
    is_acc: bool
    nodes: NodeList
    device_ordinal: int | None = ...

@compatibility(is_backward_compatible=False)
class SplitResult(NamedTuple):
    split_module: torch.fx.GraphModule
    submodule_inputs: dict[str, Any]
    non_acc_submodule_prefix: str

@compatibility(is_backward_compatible=False)
def generate_inputs_for_submodules(
    model: torch.nn.Module,
    inputs: Sequence[Any],
    target_submodules: Iterable[str],
    deepcopy: bool = ...,
) -> dict[str, Any]: ...

class _SplitterBase:
    PCIe_BW = ...
    def __init__(
        self,
        module: torch.fx.GraphModule,
        sample_input: Sequence[Any],
        operator_support: OperatorSupportBase,
        settings: _SplitterSettingBase,
        non_acc_submodule_name: str = ...,
        return_tuple: bool = ...,
        nodes_finder: FxNetAccNodesFinder | None = ...,
    ) -> None: ...
    def get_node_submodule_map(self) -> dict[str, str]: ...
    def find_deps(self) -> dict[torch.fx.Node, NodeSet]: ...
    def update_deps_for_fusions(self) -> None: ...
    def node_support_preview(self, dump_graph: bool = ...) -> str: ...
    def split_preview(self, dump_graph: bool = ...) -> str: ...
    def find_reverse_deps(self, tag_id: int | None = ...) -> dict[torch.fx.Node, NodeSet]: ...
    def update_reverse_deps_for_fusions(self, deps: dict[torch.fx.Node, NodeSet]) -> None: ...
    def find_parent_nodes_of_subgraph(self, tag: str) -> NodeSet: ...
    def extend_acc_subgraph(self, tag: str) -> None: ...
    def starter_nodes(self) -> tuple[NodeSet, NodeSet]: ...
    def put_nodes_into_subgraphs(self) -> list[Subgraph]: ...
    def remove_small_acc_subgraphs(self, subgraphs: list[Subgraph]) -> list[Subgraph]: ...
    def tag(self, subgraphs: list[Subgraph]) -> None: ...
    def split(self, remove_tag: bool = ...) -> torch.fx.GraphModule: ...
    def __call__(self) -> torch.fx.GraphModule: ...
    def generate_split_results(self) -> SplitResult: ...
