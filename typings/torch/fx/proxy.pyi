from collections import OrderedDict
from collections.abc import Callable, Iterator
from typing import Any

from ._compatibility import compatibility
from .graph import Graph
from .node import Argument, Node, Target

__all__ = [
    "Attribute",
    "GraphAppendingTracer",
    "MetaProxy",
    "ParameterProxy",
    "Proxy",
    "Scope",
    "ScopeContextManager",
    "TraceError",
    "TracerBase",
]
log = ...

@compatibility(is_backward_compatible=False)
class Scope:
    def __init__(self, module_path: str, module_type: Any) -> None: ...

@compatibility(is_backward_compatible=False)
class ScopeContextManager:
    def __init__(self, scope: Scope, current_scope: Scope) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *args): ...

_COPY_META_FIELDS = ...

@compatibility(is_backward_compatible=True)
class TracerBase:
    graph: Graph
    record_stack_traces: bool = ...
    _record_forward_stack_traces_only: bool = ...
    check_mutable_operations: bool = ...
    trace_asserts: bool = ...
    proxy_buffer_attributes: bool = ...
    traced_func_name: str = ...
    scope: Scope
    module_stack: OrderedDict[str, tuple[str, Any]]
    node_name_to_scope: dict[str, tuple[str, type]]
    @compatibility(is_backward_compatible=True)
    def create_node(
        self,
        kind: str,
        target: Target,
        args: tuple[Argument, ...],
        kwargs: dict[str, Argument],
        name: str | None = ...,
        type_expr: Any | None = ...,
    ) -> Node: ...
    @compatibility(is_backward_compatible=True)
    def proxy(self, node: Node) -> Proxy: ...
    @compatibility(is_backward_compatible=True)
    def create_proxy(
        self,
        kind: str,
        target: Target,
        args: tuple[Any, ...],
        kwargs: dict[str, Any],
        name: str | None = ...,
        type_expr: Any | None = ...,
        proxy_factory_fn: Callable[[Node], Proxy] = ...,
    ): ...
    @compatibility(is_backward_compatible=True)
    def create_arg(self, a: Any) -> Argument: ...
    @compatibility(is_backward_compatible=True)
    def to_bool(self, obj: Proxy) -> bool: ...
    @compatibility(is_backward_compatible=True)
    def iter(self, obj: Proxy) -> Iterator: ...
    @compatibility(is_backward_compatible=True)
    def keys(self, obj: Proxy) -> Any: ...

@compatibility(is_backward_compatible=True)
class GraphAppendingTracer(TracerBase):
    def __init__(self, graph: Graph) -> None: ...

@compatibility(is_backward_compatible=False)
def assert_fn(x): ...

@compatibility(is_backward_compatible=True)
class TraceError(ValueError): ...

@compatibility(is_backward_compatible=True)
class Proxy:
    @compatibility(is_backward_compatible=True)
    def __init__(self, node: Node, tracer: TracerBase | None = ...) -> None: ...
    def __getattr__(self, k) -> Attribute: ...
    def __getstate__(self) -> dict: ...
    def __deepcopy__(self, memo) -> dict: ...
    def __setstate__(self, d): ...
    def __call__(self, *args, **kwargs) -> Proxy: ...
    def __iter__(self) -> Iterator[Proxy]: ...
    def __abs__(self): ...
    def __bool__(self) -> bool: ...
    @compatibility(is_backward_compatible=True)
    def keys(self): ...
    def __len__(self) -> int: ...
    @classmethod
    def __torch_function__(cls, orig_method, types, args=..., kwargs=...): ...

@compatibility(is_backward_compatible=False)
class MetaProxy(Proxy):
    def __init__(self, node: Node, tracer: TracerBase | None = ..., fake_mode=...) -> None: ...
    @classmethod
    def __torch_function__(cls, orig_method, types, args=..., kwargs=...): ...

@compatibility(is_backward_compatible=True)
class Attribute(Proxy):
    @compatibility(is_backward_compatible=True)
    def __init__(self, root: Proxy, attr: str) -> None: ...
    @property
    def node(self): ...
    def __call__(self, *args, **kwargs): ...

@compatibility(is_backward_compatible=False)
class ParameterProxy(Proxy):
    def __init__(self, tracer: TracerBase, node: Node, name, param) -> None: ...
    @property
    def shape(self): ...
    def size(self): ...
    def dim(self): ...
    @property
    def ndim(self): ...
    def numel(self): ...
    def nelement(self): ...

_create_arg_bypass = ...
