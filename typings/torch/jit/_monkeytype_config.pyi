from collections.abc import Iterable
from types import CodeType
from typing import Optional

import monkeytype
from monkeytype import trace as monkeytype_trace
from monkeytype.db.base import CallTraceStore, CallTraceStoreLogger, CallTraceThunk
from monkeytype.tracing import CallTrace, CodeFilter

_IS_MONKEYTYPE_INSTALLED = ...

def is_torch_native_class(cls):  # -> bool:
    ...
def get_type(type):  # -> str:

    ...
def get_optional_of_element_type(types):  # -> str:

    ...
def get_qualified_name(func): ...

if _IS_MONKEYTYPE_INSTALLED:
    class JitTypeTraceStoreLogger(CallTraceStoreLogger):
        def __init__(self, store: CallTraceStore) -> None: ...
        def log(self, trace: CallTrace) -> None: ...

    class JitTypeTraceStore(CallTraceStore):
        def __init__(self) -> None: ...
        def add(self, traces: Iterable[CallTrace]):  # -> None:
            ...
        def filter(
            self, qualified_name: str, qualname_prefix: str | None = ..., limit: int = ...
        ) -> list[CallTraceThunk]: ...
        def analyze(self, qualified_name: str) -> dict: ...
        def consolidate_types(self, qualified_name: str) -> dict: ...
        def get_args_types(self, qualified_name: str) -> dict: ...

    class JitTypeTraceConfig(monkeytype.config.Config):
        def __init__(self, s: JitTypeTraceStore) -> None: ...
        def trace_logger(self) -> JitTypeTraceStoreLogger: ...
        def trace_store(self) -> CallTraceStore: ...
        def code_filter(self) -> CodeFilter | None: ...

else:
    class JitTypeTraceStoreLogger:
        def __init__(self) -> None: ...

    class JitTypeTraceStore:
        def __init__(self) -> None: ...

    class JitTypeTraceConfig:
        def __init__(self) -> None: ...

    monkeytype_trace = ...

def jit_code_filter(code: CodeType) -> bool: ...
