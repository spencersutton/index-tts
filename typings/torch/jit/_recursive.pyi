import torch
from torch.nn import Module

ScriptMethodStub = ...
PropertyStub = ...
ignored_attributes = ...

def make_stub(func, name): ...
def make_stub_from_method(nn_module, method_name): ...
def make_stubs_from_exported_methods(mod): ...
def jit_ignored_properties(module): ...

_constant_types = ...

class SourceContext(torch._C._jit_tree_views.SourceRangeFactory):
    def __init__(self, source, filename, file_lineno, leading_whitespace_len) -> None: ...

def get_annotations(obj): ...
def infer_concrete_type_builder(nn_module, share_types=...): ...

class ConcreteTypeStore:
    type_store: dict[type[Module], list[torch._C.ConcreteModuleType]]
    methods_compiled: set[torch._C.ConcreteModuleType]
    def __init__(self) -> None: ...
    def get_or_create_concrete_type(self, nn_module): ...

concrete_type_store = ...

def create_methods_and_properties_from_stubs(concrete_type, method_stubs, property_stubs): ...
def create_hooks_from_stubs(concrete_type, hook_stubs, pre_hook_stubs): ...
def get_module_concrete_type(nn_module, share_types=...): ...
def create_script_class(obj): ...
def create_script_module(nn_module, stubs_fn, share_types=..., is_tracing=...): ...
def create_script_module_impl(nn_module, concrete_type, stubs_fn): ...
def script_model_defines_attr(script_model, attr): ...
def add_python_attr_to_scripted_model(script_model, orig, attr): ...
def get_overload_annotations(mod, jit_ignored_properties): ...
def get_overload_name_mapping(overload_info): ...
def make_stubs_for_overloads(overload_info): ...
def check_module_initialized(mod): ...
def infer_methods_to_compile(nn_module): ...
def get_hook_stubs(nn_module): ...
def get_property_stubs(nn_module): ...
def interface_script(mod_interface, nn_module): ...
def try_compile_fn(fn, loc): ...
def wrap_cpp_class(cpp_class): ...
def wrap_cpp_module(cpp_module): ...
def compile_unbound_method(concrete_type, fn): ...
def lazy_bind(concrete_type, unbound_method): ...
