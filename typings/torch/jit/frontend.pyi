_reserved_prefix = ...
_reserved_names = ...
_identifier_chars = ...

def is_reserved_name(name) -> bool: ...

pretty_node_names = ...
node_start_tokens = ...

class FrontendError(Exception):
    def __init__(self, source_range, msg) -> None: ...

class NotSupportedError(FrontendError): ...

class UnsupportedNodeError(NotSupportedError):
    def __init__(self, ctx, offending_node, reason=...) -> None: ...

class FrontendTypeError(FrontendError): ...

def build_withitems(ctx, items) -> list[Any]: ...
def build_stmts(ctx, stmts) -> list[Any]: ...
def get_class_properties(cls, self_name) -> list[Any]:
    """
    Get a list of Property objects representing the properties of a class.

    Args:
        cls:  The class to get properties of.
        self_name: The name of the class that the properties should belong to.
    Returns:
        A list of Property objects corresponding to the properties of cls. Property
        here refers to the subclass of TreeView.
    """

def get_class_assigns(ctx, cls_ast) -> list[Any]: ...
def get_jit_class_def(cls, self_name) -> ClassDef:
    """
    Get definitions for each method within the current class independently.

    Args:
        cls: The class to get definition of.
        self_name: The name of the class that the properties should belong to.

    Returns:
        torch._C._jit_tree_views.ClassDef: A representation of the class,
            the methods in the class and their definition as a tree.
    """

def get_jit_def(fn, def_name, self_name=..., is_classmethod=...) -> Def:
    """
    Build a JIT AST (TreeView) from the given function.

    Args:
        fn: A function object to compile or a pre-parsed ParsedDef object
        def_name: The name to give to the resulting AST object. This is not
            always the same as `fn.__name__`, for example:
                def _forward(self):
                    ...
                forward = _forward
            In this case, the `__name__` attribute of the function object is "_forward",
            but we want the result AST to have the name "forward".
        self_name: If this function is a method, what the type name of `self` is.
    """

def is_torch_jit_ignore_context_manager(stmt) -> bool: ...

class Builder:
    def __call__(self, ctx, node) -> Any: ...

def build_class_def(ctx, py_def, methods, properties, self_name, assigns) -> ClassDef: ...
def build_def(ctx, py_def, type_line, def_name, self_name=..., pdt_arg_types=...) -> Def: ...

_vararg_kwarg_err = ...

def build_param_list(ctx, py_args, self_name, pdt_arg_types=...) -> list[Param]: ...
def build_param(ctx, py_arg, self_name, kwarg_only, pdt_arg_type=...) -> Param: ...
def build_ignore_context_manager(ctx, stmt) -> stmt: ...
def get_default_args(fn) -> dict[Any, Any] | dict[str, Any]:
    """
    Get a dictionary of default arguments for a function.

    Args:
        fn: Callable - The function to inspect for default arguments.
    Returns:
        (Dict[str, Any]): mapping argument names to their default values if
        :attr:`fn` is not None, else empty dictionary.
    """

def get_default_args_for_class(cls) -> dict[str, dict[Any, Any] | dict[str, Any]]:
    """
    Get default arguments for all methods in a class (except for static methods).

    Args:
        cls: type - The class type to inspect for default arguments.
    Returns:
        A Dict[str, Dict[str, Any]] which maps each method name to a Dict[str, Any]
        that maps each argument name to its default value.
    """

class WithItemBuilder(Builder):
    @staticmethod
    def build_withitem(ctx, item) -> WithItem: ...

class StmtBuilder(Builder):
    augassign_map = ...
    @staticmethod
    def build_Expr(ctx, stmt) -> ExprStmt | None: ...
    @staticmethod
    def build_Assign(ctx, stmt) -> Assign: ...
    @staticmethod
    def build_AnnAssign(ctx, stmt) -> Assign: ...
    @staticmethod
    def build_Delete(ctx, stmt) -> Delete: ...
    @staticmethod
    def build_Return(ctx, stmt) -> Return: ...
    @staticmethod
    def build_Raise(ctx, stmt) -> Raise: ...
    @staticmethod
    def build_Assert(ctx, stmt) -> Assert: ...
    @staticmethod
    def build_AugAssign(ctx, stmt) -> AugAssign: ...
    @staticmethod
    def build_While(ctx, stmt) -> While: ...
    @staticmethod
    def build_For(ctx, stmt) -> For: ...
    @staticmethod
    def build_If(ctx, stmt) -> If: ...
    @staticmethod
    def build_Print(ctx, stmt) -> ExprStmt: ...
    @staticmethod
    def build_Pass(ctx, stmt) -> Pass: ...
    @staticmethod
    def build_Break(ctx, stmt) -> Break: ...
    @staticmethod
    def build_Continue(ctx, stmt) -> Continue: ...
    @staticmethod
    def build_With(ctx, stmt) -> Any | With: ...

class ExprBuilder(Builder):
    binop_map = ...
    unop_map = ...
    boolop_map = ...
    cmpop_map = ...
    @staticmethod
    def build_Attribute(ctx, expr) -> Select: ...
    @staticmethod
    def build_Call(ctx, expr) -> Apply: ...
    @staticmethod
    def build_Ellipsis(ctx, expr) -> Dots: ...
    @staticmethod
    def build_Name(ctx, expr) -> Any | Dots | Var: ...
    @staticmethod
    def build_NameConstant(ctx, expr) -> Any | Dots: ...
    @staticmethod
    def build_BinOp(ctx, expr) -> BinOp: ...
    @staticmethod
    def build_UnaryOp(ctx, expr) -> UnaryOp: ...
    @staticmethod
    def build_BoolOp(ctx, expr) -> Any | BinOp: ...
    @staticmethod
    def build_IfExp(ctx, expr) -> TernaryIf: ...
    @staticmethod
    def build_Compare(ctx, expr) -> UnaryOp | BinOp | None: ...
    @staticmethod
    def build_Subscript(ctx, expr) -> Subscript: ...
    @staticmethod
    def build_List(ctx, expr) -> ListLiteral: ...
    @staticmethod
    def build_Tuple(ctx, expr) -> TupleLiteral: ...
    @staticmethod
    def build_Dict(ctx, expr) -> DictLiteral: ...
    @staticmethod
    def build_Num(ctx, expr) -> Const: ...
    @staticmethod
    def build_Constant(ctx, expr) -> Any | Dots | Const | StringLiteral: ...
    @staticmethod
    def build_Str(ctx, expr) -> StringLiteral: ...
    @staticmethod
    def build_JoinedStr(ctx, expr) -> Apply: ...
    @staticmethod
    def build_ListComp(ctx, stmt) -> ListComp: ...
    @staticmethod
    def build_GeneratorExp(ctx, stmt) -> ListComp: ...
    @staticmethod
    def build_DictComp(ctx, stmt) -> DictComp: ...
    @staticmethod
    def build_Starred(ctx, expr) -> Starred: ...

build_expr = ...
build_stmt = ...
build_withitem = ...

def find_before(ctx, pos, substr, offsets=...): ...
