from collections import OrderedDict
from collections import abc as container_abcs
from collections.abc import Iterable, Iterator, Mapping
from typing import TYPE_CHECKING, Any, Self, TypeVar, overload
from warnings import deprecated

from torch import Tensor

from indextts.util import patch_call

from .module import Module

if TYPE_CHECKING: ...
__all__ = ["Container", "ModuleDict", "ModuleList", "ParameterDict", "ParameterList", "Sequential"]
T = TypeVar("T", bound=Module)

@deprecated(
    "`nn.Container` is deprecated. All of it's functionality is now implemented in `nn.Module`. Subclass that instead.",
    category=FutureWarning,
)
class Container(Module):
    def __init__(self, **kwargs: Any) -> None: ...

class Sequential[**P = [Tensor], R = Tensor](Module[P, R]):
    _modules: dict[str, Module[P, R]]
    @overload
    def __init__(self, *args: Module[P, R]) -> None: ...
    @overload
    def __init__(self, arg: OrderedDict[str, Module[P, R]]) -> None: ...
    def __init__(self, *args) -> None: ...
    def __getitem__(self, idx: slice | int) -> Sequential[P, R] | Module[P, R]: ...
    def __setitem__(self, idx: int, module: Module[P, R]) -> None: ...
    def __delitem__(self, idx: slice | int) -> None: ...
    def __len__(self) -> int: ...
    def __add__(self, other) -> Sequential[P, R]: ...
    def pop(self, key: int | slice) -> Module[P, R]: ...
    def __iadd__(self, other) -> Self: ...
    def __mul__(self, other: int) -> Sequential[P, R]: ...
    def __rmul__(self, other: int) -> Sequential[P, R]: ...
    def __imul__(self, other: int) -> Self: ...
    def __dir__(self) -> list[str]: ...
    def __iter__(self) -> Iterator[Module[P, R]]: ...
    def append(self, module: Module[P, R]) -> Self: ...
    def insert(self, index: int, module: Module[P, R]) -> Self: ...
    def extend(self, sequential: Iterable[Module[P, R]]) -> Self: ...
    def forward(self, *args: P.args, **kwargs: P.kwargs) -> R: ...
    @patch_call(forward)
    def __call__(self) -> None: ...

class ModuleList[T: Module](Module):
    _modules: dict[str, T]
    def __init__(self, modules: Iterable[T] | None = ...) -> None: ...
    @overload
    def __getitem__(self, idx: slice) -> ModuleList[T]: ...
    @overload
    def __getitem__(self, idx: int) -> T: ...
    def __getitem__(self, idx: int | slice) -> T | ModuleList[T]: ...
    def __setitem__(self, idx: int, module: T) -> None: ...
    def __delitem__(self, idx: int | slice) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __iadd__(self, modules: Iterable[T]) -> Self: ...
    def __add__(self, other: Iterable[T]) -> ModuleList[T]: ...
    def __dir__(self) -> list[str]: ...
    def insert(self, index: int, module: T) -> None: ...
    def append(self, module: T) -> Self: ...
    def pop(self, key: int | slice) -> T: ...
    def extend(self, modules: Iterable[T]) -> Self: ...

class ModuleDict[T: Module](Module):
    _modules: dict[str, T]
    def __init__(self, modules: Mapping[str, T] | None = ...) -> None: ...
    def __getitem__(self, key: str) -> T: ...
    def __setitem__(self, key: str, module: T) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def __contains__(self, key: str) -> bool: ...
    def clear(self) -> None: ...
    def pop(self, key: str) -> T: ...
    def keys(self) -> container_abcs.KeysView[str]: ...
    def items(self) -> container_abcs.ItemsView[str, T]: ...
    def values(self) -> container_abcs.ValuesView[T]: ...
    def update(self, modules: Mapping[str, T]) -> None: ...

class ParameterList(Module):
    def __init__(self, values: Iterable[Any] | None = ...) -> None: ...
    @overload
    def __getitem__(self, idx: int) -> Any: ...
    @overload
    def __getitem__(self: T, idx: slice) -> T: ...
    def __getitem__(self, idx) -> Self | Any: ...
    def __setitem__(self, idx: int, param: Any) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[Any]: ...
    def __iadd__(self, parameters: Iterable[Any]) -> Self: ...
    def __dir__(self) -> list[str]: ...
    def append(self, value: Any) -> Self: ...
    def extend(self, values: Iterable[Any]) -> Self: ...
    def extra_repr(self) -> str: ...
    def __call__(self, *args, **kwargs): ...

class ParameterDict(Module):
    def __init__(self, parameters: Any = ...) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def __reversed__(self) -> Iterator[str]: ...
    def copy(self) -> ParameterDict: ...
    def __contains__(self, key: str) -> bool: ...
    def setdefault(self, key: str, default: Any | None = ...) -> Any: ...
    def clear(self) -> None: ...
    def pop(self, key: str) -> Any: ...
    def popitem(self) -> tuple[str, Any]: ...
    def get(self, key: str, default: Any | None = ...) -> Any: ...
    def fromkeys(self, keys: Iterable[str], default: Any | None = ...) -> ParameterDict: ...
    def keys(self) -> container_abcs.KeysView[str]: ...
    def items(self) -> Iterable[tuple[str, Any]]: ...
    def values(self) -> Iterable[Any]: ...
    def update(self, parameters: Mapping[str, Any] | ParameterDict) -> None: ...
    def extra_repr(self) -> str: ...
    def __call__(self, input): ...
    def __or__(self, other: ParameterDict) -> ParameterDict: ...
    def __ror__(self, other: ParameterDict) -> ParameterDict: ...
    def __ior__(self, other: ParameterDict) -> Self: ...
