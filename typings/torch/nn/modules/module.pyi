from collections import namedtuple
from collections.abc import Callable, Iterator, Mapping
from typing import Any, Self, TypeVar, overload

from torch import Tensor, device, dtype
from torch._prims_common import DeviceLikeType
from torch.nn.parameter import Parameter
from torch.utils.hooks import RemovableHandle

from indextts.util import patch_call

__all__ = [
    "Module",
    "register_module_backward_hook",
    "register_module_buffer_registration_hook",
    "register_module_forward_hook",
    "register_module_forward_pre_hook",
    "register_module_full_backward_hook",
    "register_module_full_backward_pre_hook",
    "register_module_module_registration_hook",
    "register_module_parameter_registration_hook",
]
type _grad_t = tuple[Tensor, ...] | Tensor
T = TypeVar("T", bound=Module)

class _IncompatibleKeys(namedtuple("IncompatibleKeys", ["missing_keys", "unexpected_keys"])):
    __slots__ = ...
    __str__ = ...

_global_buffer_registration_hooks: dict[int, Callable] = ...
_global_module_registration_hooks: dict[int, Callable] = ...
_global_parameter_registration_hooks: dict[int, Callable] = ...

class _WrappedHook:
    def __init__(self, hook: Callable, module: Module | None = ...) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __getstate__(self) -> dict: ...
    def __setstate__(self, state: dict) -> None: ...

_global_backward_pre_hooks: dict[int, Callable] = ...
_global_backward_hooks: dict[int, Callable] = ...
_global_is_full_backward_hook: bool | None = ...
_global_forward_pre_hooks: dict[int, Callable] = ...
_global_forward_hooks: dict[int, Callable] = ...
_global_forward_hooks_always_called: dict[int, bool] = ...
_global_forward_hooks_with_kwargs: dict[int, bool] = ...
_EXTRA_STATE_KEY_SUFFIX = ...

def register_module_buffer_registration_hook(hook: Callable[..., None]) -> RemovableHandle: ...
def register_module_module_registration_hook(hook: Callable[..., None]) -> RemovableHandle: ...
def register_module_parameter_registration_hook(hook: Callable[..., None]) -> RemovableHandle: ...
def register_module_forward_pre_hook(hook: Callable[..., None]) -> RemovableHandle: ...
def register_module_forward_hook(
    hook: Callable[..., None], *, with_kwargs: bool = ..., always_call: bool = ...
) -> RemovableHandle: ...
def register_module_backward_hook(hook: Callable[[Module, _grad_t, _grad_t], None | _grad_t]) -> RemovableHandle: ...
def register_module_full_backward_pre_hook(hook: Callable[[Module, _grad_t], None | _grad_t]) -> RemovableHandle: ...
def register_module_full_backward_hook(
    hook: Callable[[Module, _grad_t, _grad_t], None | _grad_t],
) -> RemovableHandle: ...

class Module:
    dump_patches: bool = ...
    _version: int = ...
    training: bool
    _parameters: dict[str, Parameter | None]
    _buffers: dict[str, Tensor | None]
    _non_persistent_buffers_set: set[str]
    _backward_pre_hooks: dict[int, Callable]
    _backward_hooks: dict[int, Callable]
    _is_full_backward_hook: bool | None
    _forward_hooks: dict[int, Callable]
    _forward_hooks_with_kwargs: dict[int, bool]
    _forward_hooks_always_called: dict[int, bool]
    _forward_pre_hooks: dict[int, Callable]
    _forward_pre_hooks_with_kwargs: dict[int, bool]
    _state_dict_hooks: dict[int, Callable]
    _load_state_dict_pre_hooks: dict[int, Callable]
    _state_dict_pre_hooks: dict[int, Callable]
    _load_state_dict_post_hooks: dict[int, Callable]
    _modules: dict[str, Module | None]
    call_super_init: bool = ...
    _compiled_call_impl: Callable | None = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def forward(self, *args: Any, **kwargs: Any) -> Any: ...
    @patch_call(forward)
    def __call__(self) -> None: ...
    def register_buffer(self, name: str, tensor: Tensor | None, persistent: bool = ...) -> None: ...
    def register_parameter(self, name: str, param: Parameter | None) -> None: ...
    def add_module(self, name: str, module: Module | None) -> None: ...
    def register_module(self, name: str, module: Module | None) -> None: ...
    def get_submodule(self, target: str) -> Module: ...
    def set_submodule(self, target: str, module: Module, strict: bool = ...) -> None: ...
    def get_parameter(self, target: str) -> Parameter: ...
    def get_buffer(self, target: str) -> Tensor: ...
    def get_extra_state(self) -> Any: ...
    def set_extra_state(self, state: Any) -> None: ...
    def apply(self, fn: Callable[[Module], None]) -> Self: ...
    def cuda(self, device: int | device | None = ...) -> Self: ...
    def ipu(self, device: int | device | None = ...) -> Self: ...
    def xpu(self, device: int | device | None = ...) -> Self: ...
    def mtia(self, device: int | device | None = ...) -> Self: ...
    def cpu(self) -> Self: ...
    def type(self, dst_type: dtype | str) -> Self: ...
    def float(self) -> Self: ...
    def double(self) -> Self: ...
    def half(self) -> Self: ...
    def bfloat16(self) -> Self: ...
    def to_empty(self, *, device: DeviceLikeType | None, recurse: bool = ...) -> Self: ...
    @overload
    def to(self, device: DeviceLikeType | None = ..., dtype: dtype | None = ..., non_blocking: bool = ...) -> Self: ...
    @overload
    def to(self, dtype: dtype, non_blocking: bool = ...) -> Self: ...
    @overload
    def to(self, tensor: Tensor, non_blocking: bool = ...) -> Self: ...
    def to(self, *args, **kwargs) -> Self: ...
    def register_full_backward_pre_hook(
        self, hook: Callable[[Module, _grad_t], None | _grad_t], prepend: bool = ...
    ) -> RemovableHandle: ...
    def register_backward_hook(self, hook: Callable[[Module, _grad_t, _grad_t], None | _grad_t]) -> RemovableHandle: ...
    def register_full_backward_hook(
        self, hook: Callable[[Module, _grad_t, _grad_t], None | _grad_t], prepend: bool = ...
    ) -> RemovableHandle: ...
    def register_forward_pre_hook(
        self,
        hook: Callable[[T, tuple[Any, ...]], Any | None]
        | Callable[[T, tuple[Any, ...], dict[str, Any]], tuple[Any, dict[str, Any]] | None],
        *,
        prepend: bool = ...,
        with_kwargs: bool = ...,
    ) -> RemovableHandle: ...
    def register_forward_hook(
        self,
        hook: Callable[[T, tuple[Any, ...], Any], Any | None]
        | Callable[[T, tuple[Any, ...], dict[str, Any], Any], Any | None],
        *,
        prepend: bool = ...,
        with_kwargs: bool = ...,
        always_call: bool = ...,
    ) -> RemovableHandle: ...
    def __getstate__(self) -> dict[str, Any]: ...
    def __setstate__(self, state) -> None: ...
    def __getattr__(self, name: str) -> Tensor | Module: ...
    def __setattr__(self, name: str, value: Tensor | Module) -> None: ...
    def __delattr__(self, name) -> None: ...
    def register_state_dict_post_hook(self, hook) -> RemovableHandle: ...
    def register_state_dict_pre_hook(self, hook) -> RemovableHandle: ...

    T_destination = TypeVar("T_destination", bound=dict[str, Any])
    @overload
    def state_dict(self, *, destination: T_destination, prefix: str = ..., keep_vars: bool = ...) -> T_destination: ...
    @overload
    def state_dict(self, *, prefix: str = ..., keep_vars: bool = ...) -> dict[str, Any]: ...
    def state_dict(self, *args, destination=..., prefix=..., keep_vars=...) -> OrderedDict[Any, Any]: ...
    def register_load_state_dict_pre_hook(self, hook) -> RemovableHandle: ...
    def register_load_state_dict_post_hook(self, hook) -> RemovableHandle: ...
    def load_state_dict(
        self, state_dict: Mapping[str, Any], strict: bool = ..., assign: bool = ...
    ) -> _IncompatibleKeys: ...
    def parameters(self, recurse: bool = ...) -> Iterator[Parameter]: ...
    def named_parameters(
        self, prefix: str = ..., recurse: bool = ..., remove_duplicate: bool = ...
    ) -> Iterator[tuple[str, Parameter]]: ...
    def buffers(self, recurse: bool = ...) -> Iterator[Tensor]: ...
    def named_buffers(
        self, prefix: str = ..., recurse: bool = ..., remove_duplicate: bool = ...
    ) -> Iterator[tuple[str, Tensor]]: ...
    def children(self) -> Iterator[Module]: ...
    def named_children(self) -> Iterator[tuple[str, Module]]: ...
    def modules(self) -> Iterator[Module]: ...
    def named_modules(
        self, memo: set[Module] | None = ..., prefix: str = ..., remove_duplicate: bool = ...
    ) -> Generator[tuple[str, Self] | Any, Any, None]: ...
    def train(self, mode: bool = ...) -> Self: ...
    def eval(self) -> Self: ...
    def requires_grad_(self, requires_grad: bool = ...) -> Self: ...
    def zero_grad(self, set_to_none: bool = ...) -> None: ...
    def share_memory(self) -> Self: ...
    def extra_repr(self) -> str: ...
    def __dir__(self) -> list[str]: ...
    def compile(self, *args, **kwargs) -> None: ...
