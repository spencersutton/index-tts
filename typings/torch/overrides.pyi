import contextlib
import functools
from collections.abc import Callable, Iterable
from typing import Any

__all__ = [
    "enable_reentrant_dispatch",
    "get_ignored_functions",
    "get_overridable_functions",
    "get_testing_overrides",
    "handle_torch_function",
    "has_torch_function",
    "is_tensor_like",
    "is_tensor_method_or_property",
    "resolve_name",
    "wrap_torch_function",
]

@functools.cache
@_disable_user_warnings
def get_ignored_functions() -> set[Callable]: ...
@functools.cache
def get_default_nowrap_functions() -> set[Callable]: ...
@functools.cache
@_disable_user_warnings
def get_testing_overrides() -> dict[Callable, Callable]: ...
def wrap_torch_function(dispatcher: Callable) -> Callable[..., _Wrapped[..., Any, ..., Any]]: ...
def handle_torch_function(public_api: Callable, relevant_args: Iterable[Any], *args, **kwargs) -> Any: ...

has_torch_function = ...
has_torch_function_unary = ...
has_torch_function_variadic = ...

@_disable_user_warnings
def get_overridable_functions() -> dict[Any, list[Callable]]: ...
@_disable_user_warnings
def resolve_name(f) -> str | None: ...
@_disable_user_warnings
def is_tensor_method_or_property(func: Callable) -> bool: ...
def is_tensor_like(inp) -> bool: ...

class TorchFunctionMode:
    inner: TorchFunctionMode
    def __init__(self) -> None: ...
    def __torch_function__(self, func, types, args=..., kwargs=...): ...
    def __enter__(self) -> Self: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    @classmethod
    def push(cls, *args, **kwargs) -> Self: ...

class BaseTorchFunctionMode(TorchFunctionMode):
    def __torch_function__(self, func, types, args=..., kwargs=...): ...

@contextlib.contextmanager
def enable_reentrant_dispatch() -> Generator[None, Any, None]: ...
