from collections.abc import Callable, Sequence
from dataclasses import dataclass
from enum import Enum
from typing import Any

from torch.types import FileLike
from torch.utils.hooks import RemovableHandle

from ._digraph import DiGraph
from .glob_group import GlobPattern
from .importer import Importer

__all__ = ["EmptyMatchError", "PackageExporter", "PackagingError", "PackagingErrorReason"]
_gate_torchscript_serialization = ...
type ActionHook = Callable[[PackageExporter, str], None]

class _ModuleProviderAction(Enum):
    INTERN = ...
    EXTERN = ...
    MOCK = ...
    DENY = ...
    REPACKAGED_MOCK_MODULE = ...
    SKIP = ...

class PackagingErrorReason(Enum):
    IS_EXTENSION_MODULE = ...
    NO_DUNDER_FILE = ...
    SOURCE_FILE_NOT_FOUND = ...
    DEPENDENCY_RESOLUTION_FAILED = ...
    NO_ACTION = ...
    DENIED = ...
    MOCKED_BUT_STILL_USED = ...

@dataclass
class _PatternInfo:
    action: _ModuleProviderAction
    allow_empty: bool
    was_matched: bool
    def __init__(self, action, allow_empty) -> None: ...

class EmptyMatchError(Exception): ...

class PackagingError(Exception):
    def __init__(self, dependency_graph: DiGraph, debug=...) -> None: ...

class PackageExporter:
    importer: Importer
    def __init__(self, f: FileLike, importer: Importer | Sequence[Importer] = ..., debug: bool = ...) -> None: ...
    def save_source_file(self, module_name: str, file_or_directory: str, dependencies=...) -> None: ...
    def get_unique_id(self) -> str: ...
    def save_source_string(
        self, module_name: str, src: str, is_package: bool = ..., dependencies: bool = ...
    ) -> None: ...
    def add_dependency(self, module_name: str, dependencies=...) -> None: ...
    def save_module(self, module_name: str, dependencies=...) -> None: ...
    def save_pickle(
        self, package: str, resource: str, obj: Any, dependencies: bool = ..., pickle_protocol: int = ...
    ) -> None: ...
    def save_text(self, package: str, resource: str, text: str) -> None: ...
    def save_binary(self, package, resource, binary: bytes) -> None: ...
    def register_extern_hook(self, hook: ActionHook) -> RemovableHandle: ...
    def register_mock_hook(self, hook: ActionHook) -> RemovableHandle: ...
    def register_intern_hook(self, hook: ActionHook) -> RemovableHandle: ...
    def intern(self, include: GlobPattern, *, exclude: GlobPattern = ..., allow_empty: bool = ...) -> None: ...
    def mock(self, include: GlobPattern, *, exclude: GlobPattern = ..., allow_empty: bool = ...) -> None: ...
    def extern(self, include: GlobPattern, *, exclude: GlobPattern = ..., allow_empty: bool = ...) -> None: ...
    def deny(self, include: GlobPattern, *, exclude: GlobPattern = ...) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...
    def close(self) -> None: ...
    def dependency_graph_string(self) -> str: ...
    def externed_modules(self) -> list[str]: ...
    def interned_modules(self) -> list[str]: ...
    def mocked_modules(self) -> list[str]: ...
    def denied_modules(self) -> list[str]: ...
    def get_rdeps(self, module_name: str) -> list[str]: ...
    def all_paths(self, src: str, dst: str) -> str: ...

_DISALLOWED_MODULES = ...
_MOCK_IMPL = ...
