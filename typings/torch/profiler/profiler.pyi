import json
from abc import ABC, abstractmethod
from collections.abc import Callable, Iterable
from enum import Enum
from typing import Any, Self
from torch._C._profiler import _ExperimentalConfig
from torch.autograd import ProfilerActivity

__all__ = [
    "ExecutionTraceObserver",
    "ProfilerAction",
    "profile",
    "schedule",
    "supported_activities",
    "tensorboard_trace_handler",
]
PROFILER_STEP_NAME = ...

class _NumpyEncoder(json.JSONEncoder):
    def default(self, obj) -> Any | int | float: ...

def supported_activities() -> set[ProfilerActivity]: ...

class _ITraceObserver(ABC):
    @abstractmethod
    def start(self) -> None: ...
    @abstractmethod
    def stop(self) -> None: ...
    @abstractmethod
    def cleanup(self) -> None: ...

class _KinetoProfile:
    def __init__(
        self,
        *,
        activities: Iterable[ProfilerActivity] | None = ...,
        record_shapes: bool = ...,
        profile_memory: bool = ...,
        with_stack: bool = ...,
        with_flops: bool = ...,
        with_modules: bool = ...,
        experimental_config: _ExperimentalConfig | None = ...,
        execution_trace_observer: _ITraceObserver | None = ...,
        acc_events: bool = ...,
        custom_trace_id_callback: Callable[[], str] | None = ...,
    ) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def prepare_trace(self) -> None: ...
    def start_trace(self) -> None: ...
    def stop_trace(self) -> None: ...
    def export_chrome_trace(self, path: str) -> None: ...
    def export_stacks(self, path: str, metric: str = ...) -> None: ...
    def toggle_collection_dynamic(self, enable: bool, activities: Iterable[ProfilerActivity]) -> None: ...
    def key_averages(
        self, group_by_input_shape: bool = ..., group_by_stack_n: int = ..., group_by_overload_name: bool = ...
    ) -> EventList: ...
    def events(self) -> EventList | None: ...
    def add_metadata(self, key: str, value: str) -> None: ...
    def add_metadata_json(self, key: str, value: str) -> None: ...
    def preset_metadata_json(self, key: str, value: str) -> None: ...
    def export_memory_timeline(self, path: str, device: str | None = ...) -> None: ...

class ProfilerAction(Enum):
    NONE = ...
    WARMUP = ...
    RECORD = ...
    RECORD_AND_SAVE = ...

def schedule(
    *, wait: int, warmup: int, active: int, repeat: int = ..., skip_first: int = ..., skip_first_wait: int = ...
) -> Callable: ...
def tensorboard_trace_handler(
    dir_name: str, worker_name: str | None = ..., use_gzip: bool = ...
) -> Callable[..., None]: ...

class profile(_KinetoProfile):
    def __init__(
        self,
        *,
        activities: Iterable[ProfilerActivity] | None = ...,
        schedule: Callable[[int], ProfilerAction] | None = ...,
        on_trace_ready: Callable[..., Any] | None = ...,
        record_shapes: bool = ...,
        profile_memory: bool = ...,
        with_stack: bool = ...,
        with_flops: bool = ...,
        with_modules: bool = ...,
        experimental_config: _ExperimentalConfig | None = ...,
        execution_trace_observer: _ITraceObserver | None = ...,
        acc_events: bool = ...,
        use_cuda: bool | None = ...,
        custom_trace_id_callback: Callable[[], str] | None = ...,
    ) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(self, exc_type, exc_val, exc_tb) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def step(self) -> None: ...
    def set_custom_trace_id_callback(self, callback) -> None: ...
    def get_trace_id(self) -> str | None: ...

class ExecutionTraceObserver(_ITraceObserver):
    def __init__(self) -> None: ...
    def __del__(self) -> None: ...
    @staticmethod
    def build_execution_trace_obs_from_env() -> ExecutionTraceObserver | None: ...
    def set_extra_resource_collection(self, val) -> None: ...
    def register_callback(self, output_file_path: str) -> Self: ...
    def get_resources_dir(self, can_create=...) -> str | None: ...
    @staticmethod
    def get_resources_dir_for_et_path(trace_path, create_dir: bool = ...) -> str | None: ...
    def unregister_callback(self) -> None: ...
    @property
    def is_registered(self) -> bool: ...
    def is_running(self) -> bool: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def cleanup(self) -> None: ...
    def get_output_file_path(self) -> str | None: ...
