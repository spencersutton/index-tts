import os
import threading
import torch
from collections.abc import Callable
from contextlib import contextmanager
from enum import Enum
from typing import Any, IO, TypeVar, TypeAlias
from torch import _weights_only_unpickler
from torch.types import FileLike, Storage

__all__ = [
    "LoadEndianness",
    "SourceChangeWarning",
    "StorageType",
    "add_safe_globals",
    "check_module_version_greater_or_equal",
    "clear_safe_globals",
    "default_restore_location",
    "get_crc32_options",
    "get_default_load_endianness",
    "get_default_mmap_options",
    "get_safe_globals",
    "get_unsafe_globals_in_checkpoint",
    "load",
    "location_tag",
    "mkdtemp",
    "normalize_storage_type",
    "register_package",
    "safe_globals",
    "save",
    "set_crc32_options",
    "set_default_load_endianness",
    "set_default_mmap_options",
    "skip_data",
    "storage_to_tensor_type",
    "validate_cuda_device",
    "validate_hpu_device",
]
DEFAULT_PROTOCOL = ...
LONG_SIZE = ...
INT_SIZE = ...
SHORT_SIZE = ...
MAGIC_NUMBER = ...
PROTOCOL_VERSION = ...
STORAGE_KEY_SEPARATOR = ...
type MAP_LOCATION = Callable[[Storage, str], Storage] | torch.device | str | dict[str, str] | None
type STORAGE = Storage | torch.storage.TypedStorage | torch.UntypedStorage
IS_WINDOWS = ...
UNSAFE_MESSAGE = ...
if not IS_WINDOWS: ...

class _SerializationLocal(threading.local):
    def __init__(self) -> None: ...

_serialization_tls = ...

class SourceChangeWarning(Warning): ...

@contextmanager
def mkdtemp() -> Generator[str, Any, None]: ...

_package_registry: list[
    tuple[
        int,
        Callable[[STORAGE], str | None],
        Callable[[STORAGE, str], STORAGE | None],
    ]
] = ...

class LoadEndianness(Enum):
    NATIVE = ...
    LITTLE = ...
    BIG = ...

def get_default_load_endianness() -> LoadEndianness | None: ...
def set_default_load_endianness(endianness) -> None: ...
def get_crc32_options() -> bool: ...
def set_crc32_options(compute_crc32: bool) -> None: ...
def get_default_mmap_options() -> int | None: ...

class set_default_mmap_options:
    def __init__(self, flags: int) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None: ...

def clear_safe_globals() -> None: ...
def get_safe_globals() -> list[Callable | tuple[Callable, str]]: ...
def add_safe_globals(safe_globals: list[Callable | tuple[Callable, str]]) -> None: ...

class safe_globals(_weights_only_unpickler._safe_globals): ...

def get_unsafe_globals_in_checkpoint(f: FileLike) -> list[str]: ...

class skip_data:
    def __init__(self, materialize_fake_tensors: bool = ...) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type, value, tb) -> None: ...

def register_package(
    priority: int, tagger: Callable[[STORAGE], str | None], deserializer: Callable[[STORAGE, str], STORAGE | None]
) -> None: ...
def check_module_version_greater_or_equal(module, req_version_tuple, error_if_malformed=...) -> Literal[True]: ...
def validate_cuda_device(location) -> int: ...
def validate_hpu_device(location) -> int: ...
def location_tag(storage: Storage | torch.storage.TypedStorage | torch.UntypedStorage) -> str: ...
def default_restore_location(storage, location) -> STORAGE: ...
def normalize_storage_type(storage_type) -> Any: ...
def storage_to_tensor_type(storage) -> Any: ...

T = TypeVar("T")

class _opener[T]:
    def __init__(self, file_like: T) -> None: ...
    def __enter__(self) -> T: ...
    def __exit__(self, *args) -> None: ...

class _open_file(_opener[IO[bytes]]):
    def __init__(self, name: str | os.PathLike[str], mode: str) -> None: ...
    def __exit__(self, *args) -> None: ...

class _open_buffer_reader(_opener[IO[bytes]]):
    def __init__(self, buffer: IO[bytes]) -> None: ...

class _open_buffer_writer(_opener[IO[bytes]]):
    def __exit__(self, *args) -> None: ...

class _open_zipfile_reader(_opener[torch._C.PyTorchFileReader]):
    def __init__(self, name_or_buffer: str | IO[bytes]) -> None: ...

class _open_zipfile_writer_file(_opener[torch._C.PyTorchFileWriter]):
    def __init__(self, name: str) -> None: ...
    def __exit__(self, *args) -> None: ...

class _open_zipfile_writer_buffer(_opener[torch._C.PyTorchFileWriter]):
    def __init__(self, buffer: IO[bytes]) -> None: ...
    def __exit__(self, *args) -> None: ...

def save(
    obj: object,
    f: FileLike,
    pickle_module: Any = ...,
    pickle_protocol: int = ...,
    _use_new_zipfile_serialization: bool = ...,
    _disable_byteorder_record: bool = ...,
) -> None: ...
def load(
    f: FileLike,
    map_location: MAP_LOCATION = ...,
    pickle_module: Any = ...,
    *,
    weights_only: bool | None = ...,
    mmap: bool | None = ...,
    **pickle_load_args: Any,
) -> Any: ...

class StorageType:
    def __init__(self, name) -> None: ...
    @property
    def dtype(self) -> dtype: ...
