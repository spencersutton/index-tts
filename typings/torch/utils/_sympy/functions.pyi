import sympy
from sympy.core.expr import Expr
from sympy.core.function import Application
from sympy.core.operations import LatticeOp

__all__ = [
    "CeilDiv",
    "CeilToInt",
    "CleanDiv",
    "FloatPow",
    "FloatTrueDiv",
    "FloorDiv",
    "FloorToInt",
    "Identity",
    "IntTrueDiv",
    "IsNonOverlappingAndDenseIndicator",
    "LShift",
    "Mod",
    "ModularIndexing",
    "PowByNatural",
    "PythonMod",
    "RShift",
    "RoundDecimal",
    "RoundToInt",
    "ToFloat",
    "TruncToFloat",
    "TruncToInt",
    "Where",
]

def fuzzy_eq(x: bool | None, y: bool | None) -> bool | None: ...
def simple_floordiv_gcd(p: sympy.Basic, q: sympy.Basic) -> sympy.Basic:
    """
    Fast path for sympy.gcd, using a simple factoring strategy.

    We try to rewrite p and q in the form n*e*p1 + n*e*p2 and n*e*q0,
    where n is the greatest common integer factor and e is the largest
    syntactic common factor (i.e., common sub-expression) in p and q.
    Then the gcd returned is n*e, cancelling which we would be left with
    p1 + p2 and q0.

    Note that further factoring of p1 + p2 and q0 might be possible with
    sympy.factor (which uses domain-specific theories). E.g., we are unable
    to find that x*y + x + y + 1 is divisible by x + 1. More generally,
    when q is of the form q1 + q2 (instead of being already factored) it
    might be necessary to fall back on sympy.gcd.
    """

class FloorDiv(sympy.Function):
    """
    We maintain this so that:
    1. We can use divisibility guards to simplify FloorDiv(a, b) to a / b.
    2. Printing out the expression is nicer (compared to say, representing a//b as (a - a % b) / b)

    NB: This is Python-style floor division, round to -Inf
    """

    nargs: tuple[int, ...] = ...
    precedence: int = ...
    is_integer: bool = ...
    @property
    def base(self) -> sympy.Basic: ...
    @property
    def divisor(self) -> sympy.Basic: ...
    @classmethod
    def eval(cls, base: sympy.Integer, divisor: sympy.Integer) -> sympy.Basic | None: ...

class ModularIndexing(sympy.Function):
    """ModularIndexing(a, b, c) => (a // b) % c where % is the C modulus"""

    nargs: tuple[int, ...] = ...
    is_integer: bool = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base: sympy.Integer, divisor: sympy.Integer, modulus: sympy.Integer) -> sympy.Basic | None: ...

class Where(sympy.Function):
    """Good ol' ternary operator"""

    nargs: tuple[int, ...] = ...
    precedence: int = ...
    @classmethod
    def eval(cls, c: sympy.Basic, p: sympy.Basic, q: sympy.Basic) -> sympy.Basic | None: ...

class PythonMod(sympy.Function):
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    is_integer: bool = ...
    @classmethod
    def eval(cls, p: sympy.Expr, q: sympy.Expr) -> sympy.Expr | None: ...

class Mod(sympy.Function):
    nargs = ...
    precedence: int = ...
    is_integer = ...
    is_nonnegative = ...
    @classmethod
    def eval(cls, p, q): ...

class CleanDiv(FloorDiv):
    """
    Div where we can assume no rounding.
    This is to enable future optimizations.
    """

class CeilToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): ...

class FloorToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): ...

class CeilDiv(sympy.Function):
    """Div used in indexing that rounds up."""

    is_integer = ...
    def __new__(cls, base, divisor): ...

class LShift(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, base, shift): ...

class RShift(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, base, shift): ...

class MinMaxBase(Expr, LatticeOp):
    def __new__(cls, *original_args, **assumptions): ...

    _eval_is_algebraic = ...
    _eval_is_antihermitian = ...
    _eval_is_commutative = ...
    _eval_is_complex = ...
    _eval_is_composite = ...
    _eval_is_even = ...
    _eval_is_finite = ...
    _eval_is_hermitian = ...
    _eval_is_imaginary = ...
    _eval_is_infinite = ...
    _eval_is_integer = ...
    _eval_is_irrational = ...
    _eval_is_negative = ...
    _eval_is_noninteger = ...
    _eval_is_nonnegative = ...
    _eval_is_nonpositive = ...
    _eval_is_nonzero = ...
    _eval_is_odd = ...
    _eval_is_polar = ...
    _eval_is_positive = ...
    _eval_is_prime = ...
    _eval_is_rational = ...
    _eval_is_real = ...
    _eval_is_extended_real = ...
    _eval_is_transcendental = ...
    _eval_is_zero = ...

class Max(MinMaxBase, Application):
    """Return, if possible, the maximum value of the list."""

    zero = ...
    identity = ...

class Min(MinMaxBase, Application):
    """Return, if possible, the minimum value of the list."""

    zero = ...
    identity = ...

def safe_pow(base, exp): ...

class PowByNatural(sympy.Function):
    is_integer = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, exp): ...

class FloatPow(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, exp): ...

class FloatTrueDiv(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, divisor): ...

class IntTrueDiv(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, divisor): ...

class IsNonOverlappingAndDenseIndicator(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, *args): ...

class TruncToFloat(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number): ...

class TruncToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): ...

class RoundToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): ...

class RoundDecimal(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number, ndigits): ...

class ToFloat(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number): ...

class Identity(sympy.Function):
    """Prevents expansion and other optimizations"""

    precedence = ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

def make_opaque_unary_fn(name) -> None: ...

OpaqueUnaryFn_sqrt = ...
OpaqueUnaryFn_cos = ...
OpaqueUnaryFn_cosh = ...
OpaqueUnaryFn_sin = ...
OpaqueUnaryFn_sinh = ...
OpaqueUnaryFn_tan = ...
OpaqueUnaryFn_tanh = ...
OpaqueUnaryFn_asin = ...
OpaqueUnaryFn_acos = ...
OpaqueUnaryFn_atan = ...
OpaqueUnaryFn_exp = ...
OpaqueUnaryFn_log = ...
OpaqueUnaryFn_asinh = ...
OpaqueUnaryFn_log2 = ...

def make_opaque_bitwise_fn(name, real_op_name) -> None: ...

BitwiseFn_bitwise_and = ...
BitwiseFn_bitwise_or = ...
