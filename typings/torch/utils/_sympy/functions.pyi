import sympy
from typing import Optional, SupportsFloat, TYPE_CHECKING, TypeVar, Union
from typing_extensions import TypeVarTuple
from sympy.core.expr import Expr
from sympy.core.function import Application
from sympy.core.operations import LatticeOp

if TYPE_CHECKING: ...
__all__ = [
    "FloorDiv",
    "ModularIndexing",
    "Where",
    "PythonMod",
    "Mod",
    "CleanDiv",
    "CeilToInt",
    "FloorToInt",
    "CeilDiv",
    "IntTrueDiv",
    "FloatTrueDiv",
    "LShift",
    "RShift",
    "IsNonOverlappingAndDenseIndicator",
    "TruncToFloat",
    "TruncToInt",
    "RoundToInt",
    "RoundDecimal",
    "ToFloat",
    "FloatPow",
    "PowByNatural",
    "Identity",
]

def fuzzy_eq(x: Optional[bool], y: Optional[bool]) -> Optional[bool]: ...
def simple_floordiv_gcd(p: sympy.Basic, q: sympy.Basic) -> sympy.Basic: ...

class FloorDiv(sympy.Function):
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    is_integer: bool = ...
    @property
    def base(self) -> sympy.Basic: ...
    @property
    def divisor(self) -> sympy.Basic: ...
    @classmethod
    def eval(cls, base: sympy.Integer, divisor: sympy.Integer) -> Union[sympy.Basic, None]: ...

class ModularIndexing(sympy.Function):
    nargs: tuple[int, ...] = ...
    is_integer: bool = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base: sympy.Integer, divisor: sympy.Integer, modulus: sympy.Integer) -> Optional[sympy.Basic]: ...

class Where(sympy.Function):
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    @classmethod
    def eval(cls, c: sympy.Basic, p: sympy.Basic, q: sympy.Basic) -> Optional[sympy.Basic]: ...

class PythonMod(sympy.Function):
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    is_integer: bool = ...
    @classmethod
    def eval(cls, p: sympy.Expr, q: sympy.Expr) -> Optional[sympy.Expr]: ...

class Mod(sympy.Function):
    nargs = ...
    precedence: int = ...
    is_integer = ...
    is_nonnegative = ...
    @classmethod
    def eval(cls, p, q):  # -> None:
        ...

class CleanDiv(FloorDiv): ...

class CeilToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number):  # -> None:
        ...

class FloorToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number):  # -> None:
        ...

class CeilDiv(sympy.Function):
    is_integer = ...
    def __new__(cls, base, divisor):  # -> CleanDiv | FloorDiv:
        ...

class LShift(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, base, shift): ...

class RShift(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, base, shift):  # -> FloorDiv:
        ...

class MinMaxBase(Expr, LatticeOp):
    def __new__(cls, *original_args, **assumptions):  # -> int:
        ...

    _eval_is_algebraic = ...
    _eval_is_antihermitian = ...
    _eval_is_commutative = ...
    _eval_is_complex = ...
    _eval_is_composite = ...
    _eval_is_even = ...
    _eval_is_finite = ...
    _eval_is_hermitian = ...
    _eval_is_imaginary = ...
    _eval_is_infinite = ...
    _eval_is_integer = ...
    _eval_is_irrational = ...
    _eval_is_negative = ...
    _eval_is_noninteger = ...
    _eval_is_nonnegative = ...
    _eval_is_nonpositive = ...
    _eval_is_nonzero = ...
    _eval_is_odd = ...
    _eval_is_polar = ...
    _eval_is_positive = ...
    _eval_is_prime = ...
    _eval_is_rational = ...
    _eval_is_real = ...
    _eval_is_extended_real = ...
    _eval_is_transcendental = ...
    _eval_is_zero = ...

class Max(MinMaxBase, Application):
    zero = ...
    identity = ...

class Min(MinMaxBase, Application):
    zero = ...
    identity = ...

def safe_pow(base, exp):  # -> int:
    ...

class PowByNatural(sympy.Function):
    is_integer = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, exp):  # -> None:
        ...

class FloatPow(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, exp):  # -> None:
        ...

class FloatTrueDiv(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, divisor):  # -> None:
        ...

class IntTrueDiv(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, divisor):  # -> None:
        ...

class IsNonOverlappingAndDenseIndicator(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, *args):  # -> int | None:
        ...

class TruncToFloat(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number):  # -> None:
        ...

class TruncToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number):  # -> None:
        ...

class RoundToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number):  # -> None:
        ...

class RoundDecimal(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number, ndigits):  # -> None:
        ...

class ToFloat(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number):  # -> None:
        ...

class Identity(sympy.Function):
    precedence = ...
    def __repr__(self):  # -> str:
        ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

def make_opaque_unary_fn(name):  # -> type[OpaqueUnaryFn]:
    ...

OpaqueUnaryFn_sqrt = ...
OpaqueUnaryFn_cos = ...
OpaqueUnaryFn_cosh = ...
OpaqueUnaryFn_sin = ...
OpaqueUnaryFn_sinh = ...
OpaqueUnaryFn_tan = ...
OpaqueUnaryFn_tanh = ...
OpaqueUnaryFn_asin = ...
OpaqueUnaryFn_acos = ...
OpaqueUnaryFn_atan = ...
OpaqueUnaryFn_exp = ...
OpaqueUnaryFn_log = ...
OpaqueUnaryFn_asinh = ...
OpaqueUnaryFn_log2 = ...

def make_opaque_bitwise_fn(name, real_op_name):  # -> type[BitwiseFn]:
    ...

BitwiseFn_bitwise_and = ...
BitwiseFn_bitwise_or = ...
