import sympy
from sympy.core.expr import Expr
from sympy.core.function import Application
from sympy.core.operations import LatticeOp

__all__ = [
    "CeilDiv",
    "CeilToInt",
    "CleanDiv",
    "FloatPow",
    "FloatTrueDiv",
    "FloorDiv",
    "FloorToInt",
    "Identity",
    "IntTrueDiv",
    "IsNonOverlappingAndDenseIndicator",
    "LShift",
    "Mod",
    "ModularIndexing",
    "PowByNatural",
    "PythonMod",
    "RShift",
    "RoundDecimal",
    "RoundToInt",
    "ToFloat",
    "TruncToFloat",
    "TruncToInt",
    "Where",
]

def fuzzy_eq(x: bool | None, y: bool | None) -> bool | None: ...
def simple_floordiv_gcd(p: sympy.Basic, q: sympy.Basic) -> sympy.Basic: ...

class FloorDiv(sympy.Function):
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    is_integer: bool = ...
    @property
    def base(self) -> sympy.Basic: ...
    @property
    def divisor(self) -> sympy.Basic: ...
    @classmethod
    def eval(cls, base: sympy.Integer, divisor: sympy.Integer) -> sympy.Basic | None: ...

class ModularIndexing(sympy.Function):
    nargs: tuple[int, ...] = ...
    is_integer: bool = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base: sympy.Integer, divisor: sympy.Integer, modulus: sympy.Integer) -> sympy.Basic | None: ...

class Where(sympy.Function):
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    @classmethod
    def eval(cls, c: sympy.Basic, p: sympy.Basic, q: sympy.Basic) -> sympy.Basic | None: ...

class PythonMod(sympy.Function):
    nargs: tuple[int, ...] = ...
    precedence: int = ...
    is_integer: bool = ...
    @classmethod
    def eval(cls, p: sympy.Expr, q: sympy.Expr) -> sympy.Expr | None: ...

class Mod(sympy.Function):
    nargs = ...
    precedence: int = ...
    is_integer = ...
    is_nonnegative = ...
    @classmethod
    def eval(cls, p, q): ...

class CleanDiv(FloorDiv): ...

class CeilToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): ...

class FloorToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): ...

class CeilDiv(sympy.Function):
    is_integer = ...
    def __new__(cls, base, divisor): ...

class LShift(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, base, shift): ...

class RShift(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, base, shift): ...

class MinMaxBase(Expr, LatticeOp):
    def __new__(cls, *original_args, **assumptions): ...

    _eval_is_algebraic = ...
    _eval_is_antihermitian = ...
    _eval_is_commutative = ...
    _eval_is_complex = ...
    _eval_is_composite = ...
    _eval_is_even = ...
    _eval_is_finite = ...
    _eval_is_hermitian = ...
    _eval_is_imaginary = ...
    _eval_is_infinite = ...
    _eval_is_integer = ...
    _eval_is_irrational = ...
    _eval_is_negative = ...
    _eval_is_noninteger = ...
    _eval_is_nonnegative = ...
    _eval_is_nonpositive = ...
    _eval_is_nonzero = ...
    _eval_is_odd = ...
    _eval_is_polar = ...
    _eval_is_positive = ...
    _eval_is_prime = ...
    _eval_is_rational = ...
    _eval_is_real = ...
    _eval_is_extended_real = ...
    _eval_is_transcendental = ...
    _eval_is_zero = ...

class Max(MinMaxBase, Application):
    zero = ...
    identity = ...

class Min(MinMaxBase, Application):
    zero = ...
    identity = ...

def safe_pow(base, exp): ...

class PowByNatural(sympy.Function):
    is_integer = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, exp): ...

class FloatPow(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, exp): ...

class FloatTrueDiv(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, divisor): ...

class IntTrueDiv(sympy.Function):
    is_real = ...
    precedence: int = ...
    @classmethod
    def eval(cls, base, divisor): ...

class IsNonOverlappingAndDenseIndicator(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, *args): ...

class TruncToFloat(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number): ...

class TruncToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): ...

class RoundToInt(sympy.Function):
    is_integer = ...
    @classmethod
    def eval(cls, number): ...

class RoundDecimal(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number, ndigits): ...

class ToFloat(sympy.Function):
    is_real = ...
    @classmethod
    def eval(cls, number): ...

class Identity(sympy.Function):
    precedence = ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...

def make_opaque_unary_fn(name) -> None: ...

OpaqueUnaryFn_sqrt = ...
OpaqueUnaryFn_cos = ...
OpaqueUnaryFn_cosh = ...
OpaqueUnaryFn_sin = ...
OpaqueUnaryFn_sinh = ...
OpaqueUnaryFn_tan = ...
OpaqueUnaryFn_tanh = ...
OpaqueUnaryFn_asin = ...
OpaqueUnaryFn_acos = ...
OpaqueUnaryFn_atan = ...
OpaqueUnaryFn_exp = ...
OpaqueUnaryFn_log = ...
OpaqueUnaryFn_asinh = ...
OpaqueUnaryFn_log2 = ...

def make_opaque_bitwise_fn(name, real_op_name) -> None: ...

BitwiseFn_bitwise_and = ...
BitwiseFn_bitwise_or = ...
