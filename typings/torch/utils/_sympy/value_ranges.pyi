import dataclasses
import functools
import sympy
from typing import Generic, Optional, TYPE_CHECKING, TypeVar, Union, overload, TypeAlias
from collections.abc import Callable
from typing import TypeGuard
from sympy.logic.boolalg import Boolean as SympyBoolean

log = ...
__all__ = ["ValueRanges", "bound_sympy"]
_T = TypeVar("_T", sympy.Expr, SympyBoolean)

class ValueRangeError(RuntimeError): ...

def simple_sympify(e): ...
def sympy_generic_le(lower, upper):  # -> bool:
    ...
def vr_is_bool(vr: ValueRanges[_T]) -> TypeGuard[ValueRanges[SympyBoolean]]: ...
def vr_is_expr(vr: ValueRanges[_T]) -> TypeGuard[ValueRanges[sympy.Expr]]: ...

type ExprIn = int | float | sympy.Expr
type BoolIn = bool | SympyBoolean
type AllIn = ExprIn | BoolIn
type ExprFn = Callable[[sympy.Expr], sympy.Expr]
type ExprFn2 = Callable[[sympy.Expr, sympy.Expr], sympy.Expr]
type BoolFn = Callable[[SympyBoolean], SympyBoolean]
type BoolFn2 = Callable[[SympyBoolean, SympyBoolean], SympyBoolean]
type AllFn = ExprFn | BoolFn
type AllFn2 = ExprFn2 | BoolFn2

@dataclasses.dataclass(frozen=True)
class ValueRanges(Generic[_T]):
    if TYPE_CHECKING:
        ExprVR = ...
        BoolVR = ...
        type AllVR = ExprVR | BoolVR
    lower: _T
    upper: _T
    is_bool: bool
    is_int: bool
    is_float: bool

    @overload
    def __init__(self: ValueRanges[sympy.Expr], lower: ExprIn, upper: ExprIn) -> None: ...
    @overload
    def __init__(self: ValueRanges[SympyBoolean], lower: BoolIn, upper: BoolIn) -> None: ...
    def __init__(self, lower: AllIn, upper: AllIn) -> None: ...
    def boolify(self) -> ValueRanges[SympyBoolean]: ...
    def __contains__(self, x: AllIn) -> bool: ...
    def issubset(self, other):  # -> bool:
        ...
    def tighten(self, other) -> ValueRanges: ...
    @overload
    def __and__(self: ValueRanges[sympy.Expr], other: ValueRanges[sympy.Expr]) -> ValueRanges[sympy.Expr]: ...
    @overload
    def __and__(self: ValueRanges[SympyBoolean], other: ValueRanges[SympyBoolean]) -> ValueRanges[SympyBoolean]: ...
    def __and__(self: AllVR, other: AllVR) -> AllVR: ...
    @overload
    def __or__(self: ValueRanges[sympy.Expr], other: ValueRanges[sympy.Expr]) -> ValueRanges[sympy.Expr]: ...
    @overload
    def __or__(self: ValueRanges[SympyBoolean], other: ValueRanges[SympyBoolean]) -> ValueRanges[SympyBoolean]: ...
    def __or__(self: AllVR, other: AllVR) -> AllVR: ...
    def is_singleton(self) -> bool: ...
    @staticmethod
    @functools.cache
    def unknown() -> ValueRanges[sympy.Expr]: ...
    @staticmethod
    @functools.cache
    def unknown_int() -> ValueRanges[sympy.Expr]: ...
    @staticmethod
    @functools.cache
    def unknown_bool() -> ValueRanges[SympyBoolean]: ...
    @overload
    @staticmethod
    def wrap(arg: ExprIn | ExprVR) -> ExprVR: ...
    @overload
    @staticmethod
    def wrap(arg: BoolIn | BoolVR) -> BoolVR: ...
    @staticmethod
    def wrap(arg: AllIn | AllVR) -> AllVR: ...
    @staticmethod
    def increasing_map(x: ExprIn | ExprVR, fn: ExprFn) -> ExprVR: ...
    @overload
    @staticmethod
    def decreasing_map(x: ExprIn | ExprVR, fn: ExprFn) -> ExprVR: ...
    @overload
    @staticmethod
    def decreasing_map(x: BoolIn | BoolVR, fn: BoolFn) -> BoolVR: ...
    @staticmethod
    def decreasing_map(x: AllIn | AllVR, fn: AllFn) -> AllVR: ...
    @staticmethod
    def monotone_map(x: ExprIn | ExprVR, fn: ExprFn) -> ExprVR: ...
    @staticmethod
    def convex_min_zero_map(x: ExprIn | ExprVR, fn: ExprFn) -> ExprVR: ...
    @overload
    @staticmethod
    def coordinatewise_increasing_map(x: ExprIn | ExprVR, y: ExprIn | ExprVR, fn: ExprFn2) -> ExprVR: ...
    @overload
    @staticmethod
    def coordinatewise_increasing_map(x: BoolIn | BoolVR, y: BoolIn | BoolVR, fn: BoolFn2) -> BoolVR: ...
    @staticmethod
    def coordinatewise_increasing_map(x: AllIn | AllVR, y: AllIn | AllVR, fn: AllFn2) -> AllVR: ...
    @classmethod
    def coordinatewise_monotone_map(cls, x, y, fn):  # -> ValueRanges[Any]:

        ...

class SymPyValueRangeAnalysis:
    @staticmethod
    def constant(value, dtype):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def to_dtype(a, dtype, src_dtype=...):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def trunc_to_int(a, dtype): ...
    @staticmethod
    def not_(a): ...
    @staticmethod
    def or_(a, b): ...
    @staticmethod
    def and_(a, b): ...
    @classmethod
    def bitwise_and(cls, a, b):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def bitwise_or(cls, a, b):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def eq(a, b):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def ne(cls, a, b): ...
    @classmethod
    def identity(cls, a): ...
    @classmethod
    def lt(cls, a, b):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def gt(cls, a, b):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def le(cls, a, b): ...
    @classmethod
    def ge(cls, a, b): ...
    @staticmethod
    def add(a, b): ...
    @classmethod
    def mul(cls, a, b):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def int_truediv(a, b):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def truediv(a, b):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def floordiv(a, b):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def mod(cls, x, y):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def modular_indexing(cls, a, b, c):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def is_non_overlapping_and_dense_indicator(cls, *args):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def pow_by_natural(cls, a, b):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def pow(cls, a, b):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def reciprocal(x):  # -> ValueRanges[Any]:

        ...
    @staticmethod
    def abs(x): ...
    @staticmethod
    def exp(x): ...
    @staticmethod
    def log(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def log2(x):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def minimum(cls, a, b): ...
    @classmethod
    def maximum(cls, a, b): ...
    @staticmethod
    def min_or_max(a, b, fn): ...
    @classmethod
    def floor_to_int(cls, x, dtype): ...
    @classmethod
    def ceil_to_int(cls, x, dtype): ...
    @classmethod
    def floor(cls, x): ...
    @classmethod
    def ceil(cls, x): ...
    @classmethod
    def round_decimal(cls, number, ndigits):  # -> ValueRanges[Any]:
        ...
    @classmethod
    def round_to_int(cls, number, dtype): ...
    @staticmethod
    def sqrt(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def where(a, b, c):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def expr_cond_pair(a, b):  # -> tuple[Any, Any]:
        ...
    @staticmethod
    def piecewise(*ranges):  # -> None:
        ...
    @staticmethod
    def cos(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def cosh(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def sin(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def sinh(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def tan(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def tanh(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def asin(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def acos(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def atan(x):  # -> ValueRanges[Any]:
        ...
    @staticmethod
    def trunc(x): ...

def bound_sympy(expr: sympy.Expr, ranges: dict[sympy.Symbol, ValueRanges] | None = ...) -> ValueRanges: ...
