import sys
from pathlib import Path
from typing import Any

from setuptools.command.build_ext import build_ext
from torch.torch_version import TorchVersion

logger = ...
IS_WINDOWS = ...
IS_MACOS = ...
IS_LINUX = ...
LIB_EXT = ...
EXEC_EXT = ...
CLIB_PREFIX = ...
CLIB_EXT = ...
SHARED_FLAG = ...
_HERE = ...
_TORCH_PATH = ...
TORCH_LIB_PATH = ...
SUBPROCESS_DECODE_ARGS = ...
MINIMUM_GCC_VERSION = ...
MINIMUM_MSVC_VERSION = ...
type VersionRange = tuple[tuple[int, ...], tuple[int, ...]]
type VersionMap = dict[str, VersionRange]
CUDA_GCC_VERSIONS: VersionMap = ...
MINIMUM_CLANG_VERSION = ...
CUDA_CLANG_VERSIONS: VersionMap = ...
__all__ = [
    "BuildExtension",
    "CUDAExtension",
    "CppExtension",
    "SyclExtension",
    "check_compiler_is_gcc",
    "check_compiler_ok_for_platform",
    "get_compiler_abi_compatibility_and_version",
    "get_cxx_compiler",
    "get_default_build_root",
    "include_paths",
    "is_ninja_available",
    "library_paths",
    "load",
    "load_inline",
    "remove_extension_h_precompiler_headers",
    "verify_ninja_availability",
]
ABI_INCOMPATIBILITY_WARNING: str = ...
WRONG_COMPILER_WARNING: str = ...
CUDA_MISMATCH_MESSAGE: str = ...
CUDA_MISMATCH_WARN: str = ...
CUDA_NOT_FOUND_MESSAGE: str = ...
ROCM_HOME: str | None = ...
HIP_HOME: str | None = ...
IS_HIP_EXTENSION: bool = ...
ROCM_VERSION: str = ...
if sys.platform == "linux":
    ROCM_VERSION: str = ...
CUDA_HOME: str | None = ...
CUDNN_HOME: str | None = ...
SYCL_HOME: str | None = ...
BUILT_FROM_SOURCE_VERSION_PATTERN: str = ...
COMMON_MSVC_FLAGS: list[str] = ...
MSVC_IGNORE_CUDAFE_WARNINGS: list[str] = ...
COMMON_NVCC_FLAGS: list[str] = ...
COMMON_HIP_FLAGS: list[str] = ...
if sys.platform != "win32":
    COMMON_HIPCC_FLAGS: list[str] = ...
if sys.platform == "win32":
    _COMMON_SYCL_FLAGS: list[str] = ...
_SYCL_DLINK_FLAGS: list[str] = ...
JIT_EXTENSION_VERSIONER: str = ...
PLAT_TO_VCVARS: dict[str, str] = ...
min_supported_cpython: tuple[int, int] = ...

def get_cxx_compiler() -> str: ...
def get_default_build_root() -> str: ...
def check_compiler_ok_for_platform(compiler: str) -> bool: ...
def get_compiler_abi_compatibility_and_version(
    compiler,
) -> tuple[bool, TorchVersion]: ...

class BuildExtension(build_ext):
    @classmethod
    def with_options(cls, **options) -> None:  # -> type[cls_with_options]:

        ...
    def __init__(self, *args, **kwargs) -> None: ...
    def finalize_options(self) -> None: ...
    def build_extensions(self) -> None: ...
    def get_ext_filename(self, ext_name) -> str: ...

def CppExtension(name, sources, *args, **kwargs) -> Extension: ...
def CUDAExtension(name, sources, *args, **kwargs) -> Extension: ...
def SyclExtension(name, sources, *args, **kwargs) -> Extension: ...
def include_paths(device_type: str = ...) -> list[str]: ...
def library_paths(device_type: str = ...) -> list[str]: ...
def load(
    name: str,
    sources: str | list[str],
    extra_cflags: list[str] | None = ...,
    extra_cuda_cflags: list[str] | None = ...,
    extra_sycl_cflags: list[str] | None = ...,
    extra_ldflags: list[str] | None = ...,
    extra_include_paths: list[str] | None = ...,
    build_directory: str | Path | None = ...,
    verbose: bool = ...,
    with_cuda: bool | None = ...,
    with_sycl: bool | None = ...,
    is_python_module: bool = ...,
    is_standalone: bool = ...,
    keep_intermediates: bool = ...,
) -> Any: ...
def check_compiler_is_gcc(compiler) -> bool: ...
def remove_extension_h_precompiler_headers() -> None: ...
def load_inline(
    name,
    cpp_sources,
    cuda_sources=...,
    sycl_sources=...,
    functions=...,
    extra_cflags=...,
    extra_cuda_cflags=...,
    extra_sycl_cflags=...,
    extra_ldflags=...,
    extra_include_paths=...,
    build_directory=...,
    verbose=...,
    with_cuda=...,
    with_sycl=...,
    is_python_module=...,
    with_pytorch_error_handling=...,
    keep_intermediates=...,
    use_pch=...,
    no_implicit_headers=...,
) -> None: ...
def is_ninja_available() -> bool: ...
def verify_ninja_availability() -> None: ...
