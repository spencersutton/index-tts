import torch
from setuptools.command.build_ext import build_ext
from torch.torch_version import TorchVersion

logger = ...
IS_WINDOWS = ...
IS_MACOS = ...
IS_LINUX = ...
LIB_EXT = ...
EXEC_EXT = ...
CLIB_PREFIX = ...
CLIB_EXT = ...
SHARED_FLAG = ...
_HERE = ...
_TORCH_PATH = ...
TORCH_LIB_PATH = ...
SUBPROCESS_DECODE_ARGS = ...
MINIMUM_GCC_VERSION = ...
MINIMUM_MSVC_VERSION = ...
type VersionRange = tuple[tuple[int, ...], tuple[int, ...]]
type VersionMap = dict[str, VersionRange]
CUDA_GCC_VERSIONS: VersionMap = ...
MINIMUM_CLANG_VERSION = ...
CUDA_CLANG_VERSIONS: VersionMap = ...
__all__ = [
    "BuildExtension",
    "CUDAExtension",
    "CppExtension",
    "SyclExtension",
    "check_compiler_is_gcc",
    "check_compiler_ok_for_platform",
    "get_compiler_abi_compatibility_and_version",
    "get_cxx_compiler",
    "get_default_build_root",
    "include_paths",
    "is_ninja_available",
    "library_paths",
    "load",
    "load_inline",
    "remove_extension_h_precompiler_headers",
    "verify_ninja_availability",
]
ABI_INCOMPATIBILITY_WARNING = ...
WRONG_COMPILER_WARNING = ...
CUDA_MISMATCH_MESSAGE = ...
CUDA_MISMATCH_WARN = ...
CUDA_NOT_FOUND_MESSAGE = ...
ROCM_HOME = ...
HIP_HOME = ...
IS_HIP_EXTENSION = ...
ROCM_VERSION = ...
if torch.version.hip is not None:
    ROCM_VERSION = ...
CUDA_HOME = ...
CUDNN_HOME = ...
SYCL_HOME = ...
BUILT_FROM_SOURCE_VERSION_PATTERN = ...
COMMON_MSVC_FLAGS = ...
MSVC_IGNORE_CUDAFE_WARNINGS = ...
COMMON_NVCC_FLAGS = ...
COMMON_HIP_FLAGS = ...
if not IS_WINDOWS: ...
COMMON_HIPCC_FLAGS = ...
if IS_WINDOWS: ...
_COMMON_SYCL_FLAGS = ...
_SYCL_DLINK_FLAGS = ...
JIT_EXTENSION_VERSIONER = ...
PLAT_TO_VCVARS = ...
min_supported_cpython = ...

def get_cxx_compiler() -> str: ...
def get_default_build_root() -> str: ...
def check_compiler_ok_for_platform(compiler: str) -> bool: ...
def get_compiler_abi_compatibility_and_version(
    compiler,
) -> tuple[bool, TorchVersion]: ...

class BuildExtension(build_ext):
    @classmethod
    def with_options(cls, **options) -> None:  # -> type[cls_with_options]:

        ...
    def __init__(self, *args, **kwargs) -> None: ...
    def finalize_options(self) -> None: ...
    def build_extensions(self) -> None: ...
    def get_ext_filename(self, ext_name) -> str: ...

def CppExtension(name, sources, *args, **kwargs) -> Extension: ...
def CUDAExtension(name, sources, *args, **kwargs) -> Extension: ...
def SyclExtension(name, sources, *args, **kwargs) -> Extension: ...
def include_paths(device_type: str = ...) -> list[str]: ...
def library_paths(device_type: str = ...) -> list[str]: ...
def load(
    name,
    sources: str | list[str],
    extra_cflags=...,
    extra_cuda_cflags=...,
    extra_sycl_cflags=...,
    extra_ldflags=...,
    extra_include_paths=...,
    build_directory=...,
    verbose=...,
    with_cuda: bool | None = ...,
    with_sycl: bool | None = ...,
    is_python_module=...,
    is_standalone=...,
    keep_intermediates=...,
) -> None: ...
def check_compiler_is_gcc(compiler) -> bool: ...
def remove_extension_h_precompiler_headers() -> None: ...
def load_inline(
    name,
    cpp_sources,
    cuda_sources=...,
    sycl_sources=...,
    functions=...,
    extra_cflags=...,
    extra_cuda_cflags=...,
    extra_sycl_cflags=...,
    extra_ldflags=...,
    extra_include_paths=...,
    build_directory=...,
    verbose=...,
    with_cuda=...,
    with_sycl=...,
    is_python_module=...,
    with_pytorch_error_handling=...,
    keep_intermediates=...,
    use_pch=...,
    no_implicit_headers=...,
) -> None: ...
def is_ninja_available() -> bool: ...
def verify_ninja_availability() -> None: ...
