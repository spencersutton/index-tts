import torch
import torch.nn as nn

def transform_wb_pesq_range(x: float) -> float: ...

PESQRange: tuple[float, float] = ...

class RangeSigmoid(nn.Module):
    def __init__(self, val_range: tuple[float, float] = ...) -> None: ...
    def forward(self, x: torch.Tensor) -> torch.Tensor: ...

class Encoder(nn.Module):
    def __init__(self, feat_dim: int = ..., win_len: int = ...) -> None: ...
    def forward(self, x: torch.Tensor) -> torch.Tensor: ...

class SingleRNN(nn.Module):
    def __init__(
        self,
        rnn_type: str,
        input_size: int,
        hidden_size: int,
        dropout: float = ...,
    ) -> None: ...
    def forward(self, x: torch.Tensor) -> torch.Tensor: ...

class DPRNN(nn.Module):
    def __init__(
        self,
        feat_dim: int = ...,
        hidden_dim: int = ...,
        num_blocks: int = ...,
        rnn_type: str = ...,
        d_model: int = ...,
        chunk_size: int = ...,
        chunk_stride: int = ...,
    ) -> None: ...
    def pad_chunk(self, x: torch.Tensor) -> tuple[torch.Tensor, int]: ...
    def chunking(self, x: torch.Tensor) -> tuple[torch.Tensor, int]: ...
    def merging(self, x: torch.Tensor, rest: int) -> torch.Tensor: ...
    def forward(self, x: torch.Tensor) -> torch.Tensor: ...

class AutoPool(nn.Module):
    def __init__(self, pool_dim: int = ...) -> None: ...
    def forward(self, x: torch.Tensor) -> torch.Tensor: ...

class SquimObjective(nn.Module):
    def __init__(self, encoder: nn.Module, dprnn: nn.Module, branches: nn.ModuleList) -> None: ...
    def forward(self, x: torch.Tensor) -> list[torch.Tensor]: ...

def squim_objective_model(
    feat_dim: int,
    win_len: int,
    d_model: int,
    nhead: int,
    hidden_dim: int,
    num_blocks: int,
    rnn_type: str,
    chunk_size: int,
    chunk_stride: int | None = ...,
) -> SquimObjective: ...
def squim_objective_base() -> SquimObjective: ...
