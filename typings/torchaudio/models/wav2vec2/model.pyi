"""
This type stub file was generated by pyright.
"""

from typing import List, Optional, Tuple

import torch
from torch import Tensor
from torch.nn import Module

class Wav2Vec2Model(Module):
    """Acoustic model used in *wav2vec 2.0* :cite:`baevski2020wav2vec`.

    Note:
        To build the model, please use one of the factory functions.

    See Also:
        * :class:`torchaudio.pipelines.Wav2Vec2Bundle`: Pretrained models (without fine-tuning)
        * :class:`torchaudio.pipelines.Wav2Vec2ASRBundle`: ASR pipelines with pretrained models.

    Args:
        feature_extractor (torch.nn.Module):
            Feature extractor that extracts feature vectors from raw audio Tensor.

        encoder (torch.nn.Module):
            Encoder that converts the audio features into the sequence of probability
            distribution (in negative log-likelihood) over labels.

        aux (torch.nn.Module or None, optional):
            Auxiliary module. If provided, the output from encoder is passed to this module.
    """
    def __init__(self, feature_extractor: Module, encoder: Module, aux: Module | None = ...) -> None: ...
    @torch.jit.export
    def extract_features(
        self, waveforms: Tensor, lengths: Tensor | None = ..., num_layers: int | None = ...
    ) -> tuple[list[Tensor], Tensor | None]:
        """Extract feature vectors from raw waveforms

        This returns the list of outputs from the intermediate layers of
        transformer block in encoder.

        Args:
            waveforms (Tensor): Audio tensor of shape `(batch, frames)`.
            lengths (Tensor or None, optional):
                Indicates the valid length of each audio in the batch.
                Shape: `(batch, )`.
                When the ``waveforms`` contains audios with different durations,
                by providing ``lengths`` argument, the model will compute
                the corresponding valid output lengths and apply proper mask in
                transformer attention layer.
                If ``None``, it is assumed that the entire audio waveform
                length is valid.
            num_layers (int or None, optional):
                If given, limit the number of intermediate layers to go through.
                Providing `1` will stop the computation after going through one
                intermediate layers. If not given, the outputs from all the
                intermediate layers are returned.

        Returns:
            (List[Tensor], Optional[Tensor]):
            List of Tensors
                Features from requested layers.
                Each Tensor is of shape: `(batch, time frame, feature dimension)`
            Tensor or None
                If ``lengths`` argument was provided, a Tensor of shape `(batch, )`
                is returned.
                It indicates the valid length in time axis of each feature Tensor.
        """

    def forward(self, waveforms: Tensor, lengths: Tensor | None = ...) -> tuple[Tensor, Tensor | None]:
        """Compute the sequence of probability distribution over labels.

        Args:
            waveforms (Tensor): Audio tensor of shape `(batch, frames)`.
            lengths (Tensor or None, optional):
                Indicates the valid length of each audio in the batch.
                Shape: `(batch, )`.
                When the ``waveforms`` contains audios with different durations,
                by providing ``lengths`` argument, the model will compute
                the corresponding valid output lengths and apply proper mask in
                transformer attention layer.
                If ``None``, it is assumed that all the audio in ``waveforms``
                have valid length. Default: ``None``.

        Returns:
            (Tensor, Optional[Tensor]):
            Tensor
                The sequences of probability distribution (in logit) over labels.
                Shape: `(batch, frames, num labels)`.
            Tensor or None
                If ``lengths`` argument was provided, a Tensor of shape `(batch, )`
                is returned.
                It indicates the valid length in time axis of the output Tensor.
        """

class HuBERTPretrainModel(Module):
    """HuBERTPretrainModel()

    HuBERT model used for pretraining in *HuBERT* :cite:`hsu2021hubert`.

    Note:
        To build the model, please use one of the factory functions.

    See Also:
        `HuBERT Pre-training and Fine-tuning Recipes
        <https://github.com/pytorch/audio/tree/main/examples/hubert>`__

    Args:
        wav2vec2 (Wav2Vec2Model):
            Wav2Vec2 encoder that generates the transformer outputs.

        mask_generator (torch.nn.Module):
            Mask generator that generates the mask for masked prediction during the training.

        logit_generator (torch.nn.Module):
            Logit generator that predicts the logits of the masked and unmasked inputs.

        feature_grad_mult (float or None):
            The factor to scale the convolutional feature extraction layer gradients by.
            If ``None``, the gradients of feature extraction layers are not affected.
            The scale factor will not affect the forward pass.
    """
    def __init__(
        self,
        wav2vec2: Wav2Vec2Model,
        mask_generator: Module,
        logit_generator: Module,
        feature_grad_mult: float | None,
    ) -> None: ...
    def forward(
        self, waveforms: Tensor, labels: Tensor, audio_lengths: Tensor | None = ...
    ) -> tuple[Tensor, Tensor | None]:
        """Compute the sequence of probability distribution over labels.

        Args:
            waveforms (Tensor): Audio tensor of dimension `[batch, frames]`.
            labels (Tensor): Label for pre-training. A Tensor of dimension `[batch, frames]`.
            audio_lengths (Tensor or None, optional):
                Indicates the valid length of each audio in the batch.
                Shape: `[batch, ]`.
                When the ``waveforms`` contains audios with different durations,
                by providing ``lengths`` argument, the model will compute
                the corresponding valid output lengths and apply proper mask in
                transformer attention layer.
                If ``None``, it is assumed that all the audio in ``waveforms``
                have valid length. Default: ``None``.

        Returns:
            (Tensor, Tensor, Tensor):
            Tensor
                The masked sequences of probability distribution (in logit).
                Shape: `(masked_frames, num labels)`.
            Tensor
                The unmasked sequence of probability distribution (in logit).
                Shape: `(unmasked_frames, num labels)`.
            Tensor
                The feature mean value for additional penalty loss.
                Shape: `(1,)`.
        """

def wav2vec2_model(
    extractor_mode: str,
    extractor_conv_layer_config: list[tuple[int, int, int]] | None,
    extractor_conv_bias: bool,
    encoder_embed_dim: int,
    encoder_projection_dropout: float,
    encoder_pos_conv_kernel: int,
    encoder_pos_conv_groups: int,
    encoder_num_layers: int,
    encoder_num_heads: int,
    encoder_attention_dropout: float,
    encoder_ff_interm_features: int,
    encoder_ff_interm_dropout: float,
    encoder_dropout: float,
    encoder_layer_norm_first: bool,
    encoder_layer_drop: float,
    aux_num_out: int | None,
) -> Wav2Vec2Model:
    """Builds custom :class:`~torchaudio.models.Wav2Vec2Model`.

    Note:
        The "feature extractor" below corresponds to
        `ConvFeatureExtractionModel <https://github.com/pytorch/fairseq/blob/dd3bd3c0497ae9a7ae7364404a6b0a4c501780b3/fairseq/models/wav2vec/wav2vec2.py#L736>`__
        in the original ``fairseq`` implementation.
        This is referred as "(convolutional) feature encoder" in the *wav2vec 2.0*
        :cite:`baevski2020wav2vec` paper.

        The "encoder" below corresponds to `TransformerEncoder <https://github.com/pytorch/fairseq/blob/dd3bd3c0497ae9a7ae7364404a6b0a4c501780b3/fairseq/models/wav2vec/wav2vec2.py#L817>`__,
        and this is referred as "Transformer" in the paper.

    Args:
        extractor_mode (str): Operation mode of feature extractor.
            Valid values are ``"group_norm"`` or ``"layer_norm"``.
            If ``"group_norm"``, then a single normalization is applied
            in the first convolution block. Otherwise, all the convolution
            blocks will have layer normalization.

            This option corresponds to ``extractor_mode`` from ``fairseq``.
        extractor_conv_layer_config (list of integer tuples or None):
            Configuration of convolution layers in feature extractor.
            List of convolution configuration,
            i.e. ``[(output_channel, kernel_size, stride), ...]``

            If ``None`` is provided, then the following default value is used.

            .. code-block:: python

               [
                 (512, 10, 5),
                 (512, 3, 2),
                 (512, 3, 2),
                 (512, 3, 2),
                 (512, 3, 2),
                 (512, 2, 2),
                 (512, 2, 2),
               ]

            This option corresponds to ``conv_feature_layers`` from ``fairseq``.

        extractor_conv_bias (bool):
            Whether to include bias term to each convolution operation.

            This option corresponds to ``conv_bias`` from ``fairseq``.

        encoder_embed_dim (int):
            The dimension of embedding in encoder.

            This option corresponds to ``encoder_embed_dim`` from ``fairseq``.

        encoder_projection_dropout (float):
            The dropout probability applied after the input feature is projected
            to ``encoder_embed_dim``.

            This option corresponds to ``dropout_input`` from ``fairseq``.

        encoder_pos_conv_kernel (int):
            The kernel size of convolutional positional embeddings.

            This option corresponds to ``conv_pos`` from ``fairseq``.

        encoder_pos_conv_groups (int):
            The number of groups of convolutional positional embeddings.

            This option corresponds to ``conv_pos_groups`` from ``fairseq``.

        encoder_num_layers (int):
            The number of self attention layers in transformer block.

            This option corresponds to ``encoder_layers`` from ``fairseq``.

        encoder_num_heads (int):
            The number of heads in self attention layers.

            This option corresponds to ``encoder_attention_heads`` from ``fairseq``.

        encoder_attention_dropout (float):
            The dropout probability applied after softmax in self-attention layer.

            This option corresponds to ``attention_dropout`` from ``fairseq``.

        encoder_ff_interm_features (int):
            The dimension of hidden features in feed forward layer.

            This option corresponds to ``encoder_ffn_embed_dim`` from ``fairseq``.

        encoder_ff_interm_dropout (float):
            The dropout probability applied in feedforward layer.

            This option correspinds to ``activation_dropout`` from ``fairseq``.

        encoder_dropout (float):
            The dropout probability applied at the end of feed forward layer.

            This option corresponds to ``dropout`` from ``fairseq``.

        encoder_layer_norm_first (bool):
            Control the order of layer norm in transformer layer and each encoder layer.
            If True, in transformer layer, layer norm is applied before features are fed
            to encoder layers. In encoder layer, two layer norms are applied before and after
            self attention.
            If False, in transformer layer, layer norm is applied after features are fed
            to encoder layers. In encoder layer, two layer norms are applied after self
            attention, before and after feed forward.

            This option corresponds to ``layer_norm_first`` from ``fairseq``.

        encoder_layer_drop (float):
            Probability to drop each encoder layer during training.

            This option corresponds to ``layerdrop`` from ``fairseq``.

        aux_num_out (int or None):
            When provided, attach an extra linear layer on top of encoder, which can be
            used for fine-tuning.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def wav2vec2_base(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds "base" :class:`~torchaudio.models.Wav2Vec2Model` from *wav2vec 2.0* :cite:`baevski2020wav2vec`

    Args:
        encoder_projection_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`wav2vec2_model`.
        aux_num_out (int or None, optional):
            See :py:func:`wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def wav2vec2_large(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds "large" :class:`~torchaudio.models.Wav2Vec2Model` from *wav2vec 2.0* :cite:`baevski2020wav2vec`

    Args:
        encoder_projection_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`wav2vec2_model`.
        aux_num_out (int or None, optional):
            See :py:func:`wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def wav2vec2_large_lv60k(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds "large lv-60k" :class:`~torchaudio.models.Wav2Vec2Model` from *wav2vec 2.0* :cite:`baevski2020wav2vec`

    Args:
        encoder_projection_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`wav2vec2_model`.
        aux_num_out (int or None, optional):
            See :py:func:`wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def hubert_base(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds "base" :class:`HuBERT <torchaudio.models.Wav2Vec2Model>` from *HuBERT* :cite:`hsu2021hubert`

    Args:
        encoder_projection_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`wav2vec2_model`.
        aux_num_out (int or None, optional):
            See :py:func:`wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def hubert_large(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds "large" :class:`HuBERT <torchaudio.models.Wav2Vec2Model>` from *HuBERT* :cite:`hsu2021hubert`

    Args:
        encoder_projection_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`wav2vec2_model`.
        aux_num_out (int or None, optional):
            See :py:func:`wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def hubert_xlarge(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds "extra large" :class:`HuBERT <torchaudio.models.Wav2Vec2Model>` from *HuBERT* :cite:`hsu2021hubert`

    Args:
        encoder_projection_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`wav2vec2_model`.
        aux_num_out (int or None, optional):
            See :py:func:`wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def hubert_pretrain_model(
    extractor_mode: str,
    extractor_conv_layer_config: list[tuple[int, int, int]] | None,
    extractor_conv_bias: bool,
    encoder_embed_dim: int,
    encoder_projection_dropout: float,
    encoder_pos_conv_kernel: int,
    encoder_pos_conv_groups: int,
    encoder_num_layers: int,
    encoder_num_heads: int,
    encoder_attention_dropout: float,
    encoder_ff_interm_features: int,
    encoder_ff_interm_dropout: float,
    encoder_dropout: float,
    encoder_layer_norm_first: bool,
    encoder_layer_drop: float,
    mask_prob: float,
    mask_selection: str,
    mask_other: float,
    mask_length: int,
    no_mask_overlap: bool,
    mask_min_space: int,
    mask_channel_prob: float,
    mask_channel_selection: str,
    mask_channel_other: float,
    mask_channel_length: int,
    no_mask_channel_overlap: bool,
    mask_channel_min_space: int,
    skip_masked: bool,
    skip_nomask: bool,
    num_classes: int,
    final_dim: int,
    feature_grad_mult: float | None,
) -> HuBERTPretrainModel:
    """Builds custom :class:`HuBERTPretrainModel` for training from scratch

    Note:
        The "feature extractor" below corresponds to
        `ConvFeatureExtractionModel <https://github.com/pytorch/fairseq/blob/dd3bd3c0497ae9a7ae7364404a6b0a4c501780b3/fairseq/models/wav2vec/wav2vec2.py#L736>`__
        in the original ``fairseq`` implementation.
        This is referred as "(convolutional) feature encoder" in the *wav2vec 2.0*
        :cite:`baevski2020wav2vec` paper.

        The "encoder" below corresponds to `TransformerEncoder <https://github.com/pytorch/fairseq/blob/dd3bd3c0497ae9a7ae7364404a6b0a4c501780b3/fairseq/models/wav2vec/wav2vec2.py#L817>`__,
        and this is referred as "Transformer" in the paper.

    Args:
        extractor_mode (str): Operation mode of feature extractor.
            Valid values are ``"group_norm"`` or ``"layer_norm"``.
            If ``"group_norm"``, then a single normalization is applied
            in the first convolution block. Otherwise, all the convolution
            blocks will have layer normalization.

            This option corresponds to ``extractor_mode`` from ``fairseq``.

        extractor_conv_layer_config (list of integer tuples or None):
            Configuration of convolution layers in feature extractor.
            List of convolution configuration,
            i.e. ``[(output_channel, kernel_size, stride), ...]``

            If ``None`` is provided, then the following default value is used.

            .. code-block:: python

               [
                 (512, 10, 5),
                 (512, 3, 2),
                 (512, 3, 2),
                 (512, 3, 2),
                 (512, 3, 2),
                 (512, 2, 2),
                 (512, 2, 2),
               ]

            This option corresponds to ``conv_feature_layers`` from ``fairseq``.

        extractor_conv_bias (bool):
            Whether to include bias term to each convolution operation.

            This option corresponds to ``conv_bias`` from ``fairseq``.

        encoder_embed_dim (int):
            The dimension of embedding in encoder.

            This option corresponds to ``encoder_embed_dim`` from ``fairseq``.

        encoder_projection_dropout (float):
            The dropout probability applied after the input feature is projected
            to ``encoder_embed_dim``.

            This option corresponds to ``dropout_input`` from ``fairseq``.

        encoder_pos_conv_kernel (int):
            The kernel size of convolutional positional embeddings.

            This option corresponds to ``conv_pos`` from ``fairseq``.

        encoder_pos_conv_groups (int):
            The number of groups of convolutional positional embeddings.

            This option corresponds to ``conv_pos_groups`` from ``fairseq``.

        encoder_num_layers (int):
            The number of self attention layers in transformer block.

            This option corresponds to ``encoder_layers`` from ``fairseq``.

        encoder_num_heads (int):
            The number of heads in self attention layers.

            This option corresponds to ``encoder_attention_heads`` from ``fairseq``.

        encoder_attention_dropout (float):
            The dropout probability applied after softmax in self-attention layer.

            This option corresponds to ``attention_dropout`` from ``fairseq``.

        encoder_ff_interm_features (int):
            The dimension of hidden features in feed forward layer.

            This option corresponds to ``encoder_ffn_embed_dim`` from ``fairseq``.

        encoder_ff_interm_dropout (float):
            The dropout probability applied in feedforward layer.

            This option correspinds to ``activation_dropout`` from ``fairseq``.

        encoder_dropout (float):
            The dropout probability applied at the end of feed forward layer.

            This option corresponds to ``dropout`` from ``fairseq``.

        encoder_layer_norm_first (bool):
            Control the order of layer norm in transformer layer and each encoder layer.
            If True, in transformer layer, layer norm is applied before features are fed
            to encoder layers. In encoder layer, two layer norms are applied before and after
            self attention.
            If False, in transformer layer, layer norm is applied after features are fed
            to encoder layers. In encoder layer, two layer norms are applied after self
            attention, before and after feed forward.

            This option corresponds to ``layer_norm_first`` from ``fairseq``.

        encoder_layer_drop (float):
            Probability to drop each encoder layer during training.

            This option corresponds to ``layerdrop`` from ``fairseq``.

        mask_prob (float):
            Probability for each token to be chosen as start of the span to be masked. this will be multiplied by
            number of timesteps divided by length of mask span to mask approximately this percentage of all elements.
            However due to overlaps, the actual number will be smaller (unless no_overlap is True).

            This option corresponds to ``mask_prob`` from ``fairseq``.

        mask_selection (str):
            How to choose the mask length. Options: [``static``, ``uniform``, ``normal``, ``poisson``].

            This option corresponds to ``mask_selection`` from ``fairseq``.

        mask_other (float):
            Secondary mask argument (used for more complex distributions).

            This option corresponds to ``mask_other`` from ``fairseq``.

        mask_length (int):
            The lengths of the mask.

            This option corresponds to ``mask_length`` from ``fairseq``.

        no_mask_overlap (bool):
            Whether to allow masks to overlap.

            This option corresponds to ``no_mask_overlap`` from ``fairseq``.

        mask_min_space (int):
            Minimum space between spans (if no overlap is enabled).

            This option corresponds to ``mask_min_space`` from ``fairseq``.

        mask_channel_prob: (float):
            The probability of replacing a feature with 0.

            This option corresponds to ``mask_channel_prob`` from ``fairseq``.

        mask_channel_selection (str):
            How to choose the mask length for channel masking. Options: [``static``, ``uniform``, ``normal``, ``poisson``].

            This option corresponds to ``mask_channel_selection`` from ``fairseq``.

        mask_channel_other (float):
            Secondary mask argument for channel masking(used for more complex distributions).

            This option corresponds to ``mask_channel_other`` from ``fairseq``.

        mask_channel_length (int):
            Minimum space between spans (if no overlap is enabled) for channel masking.

            This option corresponds to ``mask_channel_length`` from ``fairseq``.

        no_mask_channel_overlap (bool):
            Whether to allow channel masks to overlap.

            This option corresponds to ``no_mask_channel_overlap`` from ``fairseq``.

        mask_channel_min_space (int):
            Minimum space between spans for channel masking(if no overlap is enabled).

            This option corresponds to ``mask_channel_min_space`` from ``fairseq``.

        skip_masked (bool):
            If True, skip computing losses over masked frames.

            This option corresponds to ``skip_masked`` from ``fairseq``.

        skip_nomask (bool):
            If True, skip computing losses over unmasked frames.

            This option corresponds to ``skip_nomask`` from ``fairseq``.

        num_classes (int):
            The number of classes in the labels.

        final_dim (int):
            Project final representations and targets to `final_dim`.

            This option corresponds to ``final_dim`` from ``fairseq``.

        feature_grad_mult (float or None):
            The factor to scale the convolutional feature extraction layer gradients by.
            The scale factor will not affect the forward pass.

            This option corresponds to ``feature_grad_mult`` from ``fairseq``.

    Returns:
        HuBERTPretrainModel:
            The resulting model.
    """

def hubert_pretrain_base(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    mask_prob: float = ...,
    mask_channel_prob: float = ...,
    mask_channel_length: int = ...,
    feature_grad_mult: float | None = ...,
    num_classes: int = ...,
) -> HuBERTPretrainModel:
    """Builds "base" :class:`HuBERTPretrainModel` from *HuBERT* :cite:`hsu2021hubert` for pretraining.

    Args:
        encoder_projection_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_attention_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_layer_drop (float):
            See :py:func:`hubert_pretrain_model`.
        mask_prob (float):
            See :py:func:`hubert_pretrain_model`.
        mask_channel_prob (float):
            See :py:func:`hubert_pretrain_model`.
        mask_channel_length (int):
            See :py:func:`hubert_pretrain_model`.
        feature_grad_mult (float or None):
            See :py:func:`hubert_pretrain_model`.
        num_classes (int, optional):
            See :py:func:`hubert_pretrain_model`.

    Returns:
        HuBERTPretrainModel:
            The resulting model.
    """

def hubert_pretrain_large(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    mask_prob: float = ...,
    mask_channel_prob: float = ...,
    mask_channel_length: int = ...,
    feature_grad_mult: float | None = ...,
) -> HuBERTPretrainModel:
    """Builds "large" :class:`HuBERTPretrainModel` from *HuBERT* :cite:`hsu2021hubert` for pretraining.

    Args:
        encoder_projection_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_attention_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_layer_drop (float):
            See :py:func:`hubert_pretrain_model`.
        mask_prob (float):
            See :py:func:`hubert_pretrain_model`.
        mask_channel_prob (float):
            See :py:func:`hubert_pretrain_model`.
        mask_channel_length (int):
            See :py:func:`hubert_pretrain_model`.
        feature_grad_mult (float or None):
            See :py:func:`hubert_pretrain_model`.

    Returns:
        HuBERTPretrainModel:
            The resulting model.
    """

def hubert_pretrain_xlarge(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    mask_prob: float = ...,
    mask_channel_prob: float = ...,
    mask_channel_length: int = ...,
    feature_grad_mult: float | None = ...,
) -> HuBERTPretrainModel:
    """Builds "extra large" :class:`HuBERTPretrainModel` from *HuBERT* :cite:`hsu2021hubert` for pretraining.

    Args:
        encoder_projection_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_attention_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_dropout (float):
            See :py:func:`hubert_pretrain_model`.
        encoder_layer_drop (float):
            See :py:func:`hubert_pretrain_model`.
        mask_prob (float):
            See :py:func:`hubert_pretrain_model`.
        mask_channel_prob (float):
            See :py:func:`hubert_pretrain_model`.
        mask_channel_length (int):
            See :py:func:`hubert_pretrain_model`.
        feature_grad_mult (float or None):
            See :py:func:`hubert_pretrain_model`.

    Returns:
        HuBERTPretrainModel:
            The resulting model.
    """

def wavlm_model(
    extractor_mode: str,
    extractor_conv_layer_config: list[tuple[int, int, int]] | None,
    extractor_conv_bias: bool,
    encoder_embed_dim: int,
    encoder_projection_dropout: float,
    encoder_pos_conv_kernel: int,
    encoder_pos_conv_groups: int,
    encoder_num_layers: int,
    encoder_num_heads: int,
    encoder_num_buckets: int,
    encoder_max_distance: int,
    encoder_attention_dropout: float,
    encoder_ff_interm_features: int,
    encoder_ff_interm_dropout: float,
    encoder_dropout: float,
    encoder_layer_norm_first: bool,
    encoder_layer_drop: float,
    aux_num_out: int | None,
) -> Wav2Vec2Model:
    """Builds custom WaveLM model :cite:`chen2022wavlm`. The architecture is compatible
    with Wav2Vec2 model :cite:`baevski2020wav2vec`, and so the output object is
    :class:`~torchaudio.models.Wav2Vec2Model`. Most of the arguments have the same meaning
    as in :py:func:`~torchaudio.models.wav2vec2_model` so please refer there for documentation.

    Args:
        extractor_mode (str): Operation mode of feature extractor.
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        extractor_conv_layer_config (list of integer tuples or None):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        extractor_conv_bias (bool):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_embed_dim (int):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_projection_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_pos_conv_kernel (int):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_pos_conv_groups (int):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_num_layers (int):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_num_heads (int):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_num_buckets (int):
            Number of buckets for relative position embedding.
        encoder_max_distance (int):
            Maximum distance for relative position embedding.

        encoder_attention_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_ff_interm_features (int):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_ff_interm_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_layer_norm_first (bool):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        encoder_layer_drop (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

        aux_num_out (int or None):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def wavlm_base(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds "base" WaveLM model :cite:`chen2022wavlm`. The architecture is compatible
    with Wav2Vec2 model :cite:`baevski2020wav2vec`, and so the output class is
    :class:`~torchaudio.models.Wav2Vec2Model`.

    Args:
        encoder_projection_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        aux_num_out (int, optional):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def wavlm_large(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds "large" WaveLM model :cite:`chen2022wavlm`. The architecture is compatible
    with Wav2Vec2 model :cite:`baevski2020wav2vec`, and so the output class is
    :class:`~torchaudio.models.Wav2Vec2Model`.

    Args:
        encoder_projection_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        aux_num_out (int, optional):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def wav2vec2_xlsr_300m(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds XLS-R model :cite:`babu2021xls` with 300 millions of parameters. The architecture is compatible
    with Wav2Vec2 model :cite:`baevski2020wav2vec`, and so the output class is
    :class:`~torchaudio.models.Wav2Vec2Model`.

    Args:
        encoder_projection_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        aux_num_out (int, optional):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def wav2vec2_xlsr_1b(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds XLS-R model :cite:`babu2021xls` with 1 billion of parameters. The architecture is compatible
    with Wav2Vec2 model :cite:`baevski2020wav2vec`, and so the output class is
    :class:`~torchaudio.models.Wav2Vec2Model`.

    Args:
        encoder_projection_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        aux_num_out (int, optional):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """

def wav2vec2_xlsr_2b(
    encoder_projection_dropout: float = ...,
    encoder_attention_dropout: float = ...,
    encoder_ff_interm_dropout: float = ...,
    encoder_dropout: float = ...,
    encoder_layer_drop: float = ...,
    aux_num_out: int | None = ...,
) -> Wav2Vec2Model:
    """Builds XLS-R model :cite:`babu2021xls` with 2 billions of parameters. The architecture is compatible
    with Wav2Vec2 model :cite:`baevski2020wav2vec`, and so the output class is
    :class:`~torchaudio.models.Wav2Vec2Model`.

    Args:
        encoder_projection_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_attention_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_ff_interm_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_dropout (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        encoder_layer_drop (float):
            See :py:func:`~torchaudio.models.wav2vec2_model`.
        aux_num_out (int, optional):
            See :py:func:`~torchaudio.models.wav2vec2_model`.

    Returns:
        Wav2Vec2Model:
            The resulting model.
    """
