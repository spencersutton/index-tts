"""
This type stub file was generated by pyright.
"""

import os
import torch
from typing import Any, Optional, Self, TYPE_CHECKING, TypeVar, Union
from .utils import PushToHubMixin

if TYPE_CHECKING: ...
logger = ...
SpecificPretrainedConfigType = TypeVar("SpecificPretrainedConfigType", bound=PretrainedConfig)

class PretrainedConfig(PushToHubMixin):
    model_type: str = ...
    base_config_key: str = ...
    sub_configs: dict[str, type[PretrainedConfig]] = ...
    has_no_defaults_at_init: bool = ...
    attribute_map: dict[str, str] = ...
    base_model_tp_plan: Optional[dict[str, Any]] = ...
    base_model_pp_plan: Optional[dict[str, tuple[list[str]]]] = ...
    _auto_class: Optional[str] = ...
    def __setattr__(self, key, value): ...
    def __getattribute__(self, key): ...
    def __init__(
        self,
        *,
        output_hidden_states: bool = ...,
        output_attentions: bool = ...,
        return_dict: bool = ...,
        torchscript: bool = ...,
        torch_dtype: Optional[Union[str, torch.dtype]] = ...,
        pruned_heads: Optional[dict[int, list[int]]] = ...,
        tie_word_embeddings: bool = ...,
        chunk_size_feed_forward: int = ...,
        is_encoder_decoder: bool = ...,
        is_decoder: bool = ...,
        cross_attention_hidden_size: Optional[int] = ...,
        add_cross_attention: bool = ...,
        tie_encoder_decoder: bool = ...,
        architectures: Optional[list[str]] = ...,
        finetuning_task: Optional[str] = ...,
        id2label: Optional[dict[int, str]] = ...,
        label2id: Optional[dict[str, int]] = ...,
        num_labels: Optional[int] = ...,
        task_specific_params: Optional[dict[str, Any]] = ...,
        problem_type: Optional[str] = ...,
        tokenizer_class: Optional[str] = ...,
        prefix: Optional[str] = ...,
        bos_token_id: Optional[int] = ...,
        pad_token_id: Optional[int] = ...,
        eos_token_id: Optional[int] = ...,
        sep_token_id: Optional[int] = ...,
        decoder_start_token_id: Optional[int] = ...,
        **kwargs,
    ) -> None: ...
    @property
    def name_or_path(self) -> Optional[str]: ...
    @name_or_path.setter
    def name_or_path(self, value): ...
    @property
    def output_attentions(self): ...
    @output_attentions.setter
    def output_attentions(self, value: bool): ...
    @property
    def use_return_dict(self) -> bool: ...
    @property
    def num_labels(self) -> int: ...
    @num_labels.setter
    def num_labels(self, num_labels: int): ...
    def save_pretrained(self, save_directory: Union[str, os.PathLike], push_to_hub: bool = ..., **kwargs): ...
    @classmethod
    def from_pretrained(
        cls,
        pretrained_model_name_or_path: Union[str, os.PathLike],
        cache_dir: Optional[Union[str, os.PathLike]] = ...,
        force_download: bool = ...,
        local_files_only: bool = ...,
        token: Optional[Union[str, bool]] = ...,
        revision: str = ...,
        **kwargs,
    ) -> Self: ...
    @classmethod
    def get_config_dict(
        cls, pretrained_model_name_or_path: Union[str, os.PathLike], **kwargs
    ) -> tuple[dict[str, Any], dict[str, Any]]: ...
    @classmethod
    def from_dict(cls, config_dict: dict[str, Any], **kwargs) -> Self: ...
    @classmethod
    def from_json_file(cls, json_file: Union[str, os.PathLike]) -> Self: ...
    def __eq__(self, other) -> bool: ...
    def __repr__(self): ...
    def __iter__(self): ...
    def to_diff_dict(self) -> dict[str, Any]: ...
    def to_dict(self) -> dict[str, Any]: ...
    def to_json_string(self, use_diff: bool = ...) -> str: ...
    def to_json_file(self, json_file_path: Union[str, os.PathLike], use_diff: bool = ...): ...
    def update(self, config_dict: dict[str, Any]): ...
    def update_from_string(self, update_str: str): ...
    def dict_torch_dtype_to_str(self, d: dict[str, Any]) -> None: ...
    @classmethod
    def register_for_auto_class(cls, auto_class=...): ...
    def get_text_config(self, decoder=...) -> PretrainedConfig: ...
    @classmethod
    def from_text_vision_configs(cls, text_config, vision_config, **kwargs): ...
    @classmethod
    def from_text_audio_configs(cls, text_config, audio_config, **kwargs): ...

def get_configuration_file(configuration_files: list[str]) -> str: ...
def recursive_diff_dict(dict_a, dict_b, config_obj=...): ...

if PretrainedConfig.push_to_hub.__doc__ is not None: ...
ALLOWED_LAYER_TYPES = ...

def layer_type_validation(layer_types: list[str]): ...
