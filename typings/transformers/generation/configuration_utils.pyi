"""
This type stub file was generated by pyright.
"""

import os
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Callable, Optional, TYPE_CHECKING, Union
from ..configuration_utils import PretrainedConfig
from ..utils import ExplicitEnum, PushToHubMixin, is_torch_available
from ..modeling_utils import PreTrainedModel
from .logits_process import WatermarkLogitsProcessor

if TYPE_CHECKING: ...
logger = ...
METADATA_FIELDS = ...
NEED_SETUP_CACHE_CLASSES_MAPPING = ...
QUANT_BACKEND_CLASSES_MAPPING = ...
ALL_CACHE_IMPLEMENTATIONS = ...
if is_torch_available():
    NEED_SETUP_CACHE_CLASSES_MAPPING = ...
    QUANT_BACKEND_CLASSES_MAPPING = ...
    ALL_CACHE_IMPLEMENTATIONS = ...

class GenerationMode(ExplicitEnum):
    CONTRASTIVE_SEARCH = ...
    GREEDY_SEARCH = ...
    SAMPLE = ...
    ASSISTED_GENERATION = ...
    DOLA_GENERATION = ...
    BEAM_SEARCH = ...
    BEAM_SAMPLE = ...
    CONSTRAINED_BEAM_SEARCH = ...
    GROUP_BEAM_SEARCH = ...

class GenerationConfig(PushToHubMixin):
    extra_output_flags = ...
    def __init__(self, **kwargs) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def __repr__(self): ...
    def get_generation_mode(self, assistant_model: Optional[PreTrainedModel] = ...) -> GenerationMode: ...
    def validate(self, strict=...): ...
    def save_pretrained(
        self,
        save_directory: Union[str, os.PathLike],
        config_file_name: Optional[Union[str, os.PathLike]] = ...,
        push_to_hub: bool = ...,
        **kwargs,
    ): ...
    @classmethod
    def from_pretrained(
        cls,
        pretrained_model_name: Union[str, os.PathLike],
        config_file_name: Optional[Union[str, os.PathLike]] = ...,
        cache_dir: Optional[Union[str, os.PathLike]] = ...,
        force_download: bool = ...,
        local_files_only: bool = ...,
        token: Optional[Union[str, bool]] = ...,
        revision: str = ...,
        **kwargs,
    ) -> GenerationConfig: ...
    @classmethod
    def from_dict(cls, config_dict: dict[str, Any], **kwargs) -> GenerationConfig: ...
    def dict_torch_dtype_to_str(self, d: dict[str, Any]) -> None: ...
    def to_diff_dict(self) -> dict[str, Any]: ...
    def to_dict(self) -> dict[str, Any]: ...
    def to_json_string(self, use_diff: bool = ..., ignore_metadata: bool = ...) -> str: ...
    def to_json_file(self, json_file_path: Union[str, os.PathLike], use_diff: bool = ...): ...
    @classmethod
    def from_model_config(cls, model_config: PretrainedConfig) -> GenerationConfig: ...
    def update(self, **kwargs): ...

@dataclass
class BaseWatermarkingConfig(ABC):
    @classmethod
    def from_dict(cls, config_dict, **kwargs): ...
    def to_json_file(self, json_file_path: Union[str, os.PathLike]): ...
    def to_dict(self) -> dict[str, Any]: ...
    def __iter__(self): ...
    def __repr__(self): ...
    def to_json_string(self): ...
    def update(self, **kwargs): ...
    @abstractmethod
    def validate(self): ...
    @abstractmethod
    def construct_processor(self, vocab_size): ...

@dataclass
class WatermarkingConfig(BaseWatermarkingConfig):
    def __init__(
        self,
        greenlist_ratio: Optional[float] = ...,
        bias: Optional[float] = ...,
        hashing_key: Optional[int] = ...,
        seeding_scheme: Optional[str] = ...,
        context_width: Optional[int] = ...,
    ) -> None: ...
    def validate(self): ...
    def construct_processor(self, vocab_size: int, device) -> WatermarkLogitsProcessor: ...

@dataclass
class SynthIDTextWatermarkingConfig(BaseWatermarkingConfig):
    def __init__(
        self,
        ngram_len: int,
        keys: list[int],
        context_history_size: int = ...,
        sampling_table_seed: int = ...,
        sampling_table_size: int = ...,
        skip_first_ngram_calls: bool = ...,
        debug_mode: bool = ...,
    ) -> None: ...
    def validate(self): ...
    def construct_processor(self, vocab_size: int, device) -> WatermarkLogitsProcessor: ...

@dataclass
class CompileConfig:
    fullgraph: bool = ...
    dynamic: Optional[bool] = ...
    backend: Union[str, Callable] = ...
    mode: str = ...
    options: Optional[dict] = ...
    _compile_all_devices = ...
    def to_dict(self) -> dict[str, Any]: ...
