import tensorflow as tf
from dataclasses import dataclass
from typing import Optional, Union, TypeAlias
from ..utils import ModelOutput
from .configuration_utils import GenerationConfig
from .tf_logits_process import TFLogitsProcessorList

logger = ...

@dataclass
class TFGreedySearchDecoderOnlyOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFGreedySearchEncoderDecoderOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    encoder_attentions: Optional[tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFSampleDecoderOnlyOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFSampleEncoderDecoderOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    encoder_attentions: Optional[tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFBeamSearchDecoderOnlyOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    sequences_scores: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    beam_indices: Optional[tf.Tensor] = ...
    attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFBeamSearchEncoderDecoderOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    sequences_scores: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    beam_indices: Optional[tf.Tensor] = ...
    encoder_attentions: Optional[tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFBeamSampleDecoderOnlyOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    sequences_scores: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    beam_indices: Optional[tf.Tensor] = ...
    attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFBeamSampleEncoderDecoderOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    sequences_scores: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    beam_indices: Optional[tf.Tensor] = ...
    encoder_attentions: Optional[tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFContrastiveSearchDecoderOnlyOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

@dataclass
class TFContrastiveSearchEncoderDecoderOutput(ModelOutput):
    sequences: Optional[tf.Tensor] = ...
    scores: Optional[tuple[tf.Tensor]] = ...
    encoder_attentions: Optional[tuple[tf.Tensor]] = ...
    encoder_hidden_states: Optional[tuple[tf.Tensor]] = ...
    decoder_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    cross_attentions: Optional[tuple[tuple[tf.Tensor]]] = ...
    decoder_hidden_states: Optional[tuple[tuple[tf.Tensor]]] = ...

TFGreedySearchOutput: TypeAlias = Union[TFGreedySearchEncoderDecoderOutput, TFGreedySearchDecoderOnlyOutput]
TFSampleOutput: TypeAlias = Union[TFSampleEncoderDecoderOutput, TFSampleDecoderOnlyOutput]
TFBeamSearchOutput: TypeAlias = Union[TFBeamSearchEncoderDecoderOutput, TFBeamSearchDecoderOnlyOutput]
TFBeamSampleOutput: TypeAlias = Union[TFBeamSampleEncoderDecoderOutput, TFBeamSampleDecoderOnlyOutput]
TFContrastiveSearchOutput: TypeAlias = Union[
    TFContrastiveSearchEncoderDecoderOutput, TFContrastiveSearchDecoderOnlyOutput
]
TFGenerateOutput: TypeAlias = Union[
    TFGreedySearchOutput, TFSampleOutput, TFBeamSearchOutput, TFBeamSampleOutput, TFContrastiveSearchOutput
]

class TFGenerationMixin:
    _seed_generator = ...
    @property
    def seed_generator(self): ...

    supports_xla_generation = ...
    def prepare_inputs_for_generation(self, *args, **kwargs): ...
    def compute_transition_scores(
        self,
        sequences: tf.Tensor,
        scores: tuple[tf.Tensor],
        beam_indices: Optional[tf.Tensor] = ...,
        normalize_logits: bool = ...,
    ) -> tf.Tensor: ...
    def generate(
        self,
        inputs: Optional[tf.Tensor] = ...,
        generation_config: Optional[GenerationConfig] = ...,
        logits_processor: Optional[TFLogitsProcessorList] = ...,
        seed=...,
        **kwargs,
    ) -> Union[TFGenerateOutput, tf.Tensor]: ...
    def greedy_search(
        self,
        input_ids: tf.Tensor,
        max_length: Optional[int] = ...,
        pad_token_id: Optional[int] = ...,
        eos_token_id: Optional[int] = ...,
        logits_processor: Optional[TFLogitsProcessorList] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        output_scores: Optional[bool] = ...,
        return_dict_in_generate: Optional[bool] = ...,
        **model_kwargs,
    ) -> Union[TFGreedySearchOutput, tf.Tensor]: ...
    def sample(
        self,
        input_ids: tf.Tensor,
        logits_processor: Optional[TFLogitsProcessorList] = ...,
        logits_warper: Optional[TFLogitsProcessorList] = ...,
        max_length: Optional[int] = ...,
        pad_token_id: Optional[int] = ...,
        eos_token_id: Optional[int] = ...,
        seed: Optional[tuple[int, int]] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        output_scores: Optional[bool] = ...,
        return_dict_in_generate: Optional[bool] = ...,
        **model_kwargs,
    ) -> Union[TFSampleOutput, tf.Tensor]: ...
    def beam_search(
        self,
        input_ids: tf.Tensor,
        do_sample: bool = ...,
        max_length: Optional[int] = ...,
        pad_token_id: Optional[int] = ...,
        eos_token_id: Optional[int] = ...,
        length_penalty: Optional[float] = ...,
        early_stopping: Optional[Union[bool, str]] = ...,
        logits_processor: Optional[TFLogitsProcessorList] = ...,
        logits_warper: Optional[TFLogitsProcessorList] = ...,
        num_return_sequences: Optional[int] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        output_scores: Optional[bool] = ...,
        return_dict_in_generate: Optional[bool] = ...,
        **model_kwargs,
    ) -> Union[TFBeamSearchOutput, TFBeamSampleOutput, tf.Tensor]: ...
    def contrastive_search(
        self,
        input_ids: tf.Tensor,
        top_k: Optional[int] = ...,
        penalty_alpha: Optional[float] = ...,
        logits_processor: Optional[TFLogitsProcessorList] = ...,
        logits_warper: Optional[TFLogitsProcessorList] = ...,
        max_length: Optional[int] = ...,
        pad_token_id: Optional[int] = ...,
        eos_token_id: Optional[int] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        output_scores: Optional[bool] = ...,
        return_dict_in_generate: Optional[bool] = ...,
        **model_kwargs,
    ) -> Union[TFContrastiveSearchOutput, tf.Tensor]: ...

def scatter_values_on_batch_indices(values, batch_indices): ...
def sample_without_replacement(logits, num_samples): ...
