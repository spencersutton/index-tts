from dataclasses import dataclass

import tensorflow as tf

from ..utils import ModelOutput
from .configuration_utils import GenerationConfig
from .tf_logits_process import TFLogitsProcessorList

logger = ...

@dataclass
class TFGreedySearchDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    attentions: tuple[tuple[tf.Tensor]] | None = ...
    hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFGreedySearchEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    encoder_attentions: tuple[tf.Tensor] | None = ...
    encoder_hidden_states: tuple[tf.Tensor] | None = ...
    decoder_attentions: tuple[tuple[tf.Tensor]] | None = ...
    cross_attentions: tuple[tuple[tf.Tensor]] | None = ...
    decoder_hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFSampleDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    attentions: tuple[tuple[tf.Tensor]] | None = ...
    hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFSampleEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    encoder_attentions: tuple[tf.Tensor] | None = ...
    encoder_hidden_states: tuple[tf.Tensor] | None = ...
    decoder_attentions: tuple[tuple[tf.Tensor]] | None = ...
    cross_attentions: tuple[tuple[tf.Tensor]] | None = ...
    decoder_hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFBeamSearchDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    sequences_scores: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    beam_indices: tf.Tensor | None = ...
    attentions: tuple[tuple[tf.Tensor]] | None = ...
    hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFBeamSearchEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    sequences_scores: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    beam_indices: tf.Tensor | None = ...
    encoder_attentions: tuple[tf.Tensor] | None = ...
    encoder_hidden_states: tuple[tf.Tensor] | None = ...
    decoder_attentions: tuple[tuple[tf.Tensor]] | None = ...
    cross_attentions: tuple[tuple[tf.Tensor]] | None = ...
    decoder_hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFBeamSampleDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    sequences_scores: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    beam_indices: tf.Tensor | None = ...
    attentions: tuple[tuple[tf.Tensor]] | None = ...
    hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFBeamSampleEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    sequences_scores: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    beam_indices: tf.Tensor | None = ...
    encoder_attentions: tuple[tf.Tensor] | None = ...
    encoder_hidden_states: tuple[tf.Tensor] | None = ...
    decoder_attentions: tuple[tuple[tf.Tensor]] | None = ...
    cross_attentions: tuple[tuple[tf.Tensor]] | None = ...
    decoder_hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFContrastiveSearchDecoderOnlyOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    attentions: tuple[tuple[tf.Tensor]] | None = ...
    hidden_states: tuple[tuple[tf.Tensor]] | None = ...

@dataclass
class TFContrastiveSearchEncoderDecoderOutput(ModelOutput):
    sequences: tf.Tensor | None = ...
    scores: tuple[tf.Tensor] | None = ...
    encoder_attentions: tuple[tf.Tensor] | None = ...
    encoder_hidden_states: tuple[tf.Tensor] | None = ...
    decoder_attentions: tuple[tuple[tf.Tensor]] | None = ...
    cross_attentions: tuple[tuple[tf.Tensor]] | None = ...
    decoder_hidden_states: tuple[tuple[tf.Tensor]] | None = ...

type TFGreedySearchOutput = TFGreedySearchEncoderDecoderOutput | TFGreedySearchDecoderOnlyOutput
type TFSampleOutput = TFSampleEncoderDecoderOutput | TFSampleDecoderOnlyOutput
type TFBeamSearchOutput = TFBeamSearchEncoderDecoderOutput | TFBeamSearchDecoderOnlyOutput
type TFBeamSampleOutput = TFBeamSampleEncoderDecoderOutput | TFBeamSampleDecoderOnlyOutput
type TFContrastiveSearchOutput = TFContrastiveSearchEncoderDecoderOutput | TFContrastiveSearchDecoderOnlyOutput
type TFGenerateOutput = (
    TFGreedySearchOutput | TFSampleOutput | TFBeamSearchOutput | TFBeamSampleOutput | TFContrastiveSearchOutput
)

class TFGenerationMixin:
    _seed_generator = ...
    @property
    def seed_generator(self): ...

    supports_xla_generation = ...
    def prepare_inputs_for_generation(self, *args, **kwargs): ...
    def compute_transition_scores(
        self,
        sequences: tf.Tensor,
        scores: tuple[tf.Tensor],
        beam_indices: tf.Tensor | None = ...,
        normalize_logits: bool = ...,
    ) -> tf.Tensor: ...
    def generate(
        self,
        inputs: tf.Tensor | None = ...,
        generation_config: GenerationConfig | None = ...,
        logits_processor: TFLogitsProcessorList | None = ...,
        seed=...,
        **kwargs,
    ) -> TFGenerateOutput | tf.Tensor: ...
    def greedy_search(
        self,
        input_ids: tf.Tensor,
        max_length: int | None = ...,
        pad_token_id: int | None = ...,
        eos_token_id: int | None = ...,
        logits_processor: TFLogitsProcessorList | None = ...,
        output_attentions: bool | None = ...,
        output_hidden_states: bool | None = ...,
        output_scores: bool | None = ...,
        return_dict_in_generate: bool | None = ...,
        **model_kwargs,
    ) -> TFGreedySearchOutput | tf.Tensor: ...
    def sample(
        self,
        input_ids: tf.Tensor,
        logits_processor: TFLogitsProcessorList | None = ...,
        logits_warper: TFLogitsProcessorList | None = ...,
        max_length: int | None = ...,
        pad_token_id: int | None = ...,
        eos_token_id: int | None = ...,
        seed: tuple[int, int] | None = ...,
        output_attentions: bool | None = ...,
        output_hidden_states: bool | None = ...,
        output_scores: bool | None = ...,
        return_dict_in_generate: bool | None = ...,
        **model_kwargs,
    ) -> TFSampleOutput | tf.Tensor: ...
    def beam_search(
        self,
        input_ids: tf.Tensor,
        do_sample: bool = ...,
        max_length: int | None = ...,
        pad_token_id: int | None = ...,
        eos_token_id: int | None = ...,
        length_penalty: float | None = ...,
        early_stopping: bool | str | None = ...,
        logits_processor: TFLogitsProcessorList | None = ...,
        logits_warper: TFLogitsProcessorList | None = ...,
        num_return_sequences: int | None = ...,
        output_attentions: bool | None = ...,
        output_hidden_states: bool | None = ...,
        output_scores: bool | None = ...,
        return_dict_in_generate: bool | None = ...,
        **model_kwargs,
    ) -> TFBeamSearchOutput | TFBeamSampleOutput | tf.Tensor: ...
    def contrastive_search(
        self,
        input_ids: tf.Tensor,
        top_k: int | None = ...,
        penalty_alpha: float | None = ...,
        logits_processor: TFLogitsProcessorList | None = ...,
        logits_warper: TFLogitsProcessorList | None = ...,
        max_length: int | None = ...,
        pad_token_id: int | None = ...,
        eos_token_id: int | None = ...,
        output_attentions: bool | None = ...,
        output_hidden_states: bool | None = ...,
        output_scores: bool | None = ...,
        return_dict_in_generate: bool | None = ...,
        **model_kwargs,
    ) -> TFContrastiveSearchOutput | tf.Tensor: ...

def scatter_values_on_batch_indices(values, batch_indices): ...
def sample_without_replacement(logits, num_samples): ...
