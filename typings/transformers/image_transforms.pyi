"""
This type stub file was generated by pyright.
"""

import numpy as np
import PIL
import torch
import tensorflow as tf
import jax.numpy as jnp
from collections.abc import Collection, Iterable
from typing import Optional, Union
from .image_utils import ChannelDimension, ImageInput, PILImageResampling
from .utils import ExplicitEnum, TensorType
from .utils.import_utils import is_flax_available, is_tf_available, is_torch_available, is_vision_available

if is_vision_available(): ...
if is_torch_available(): ...
if is_tf_available(): ...
if is_flax_available(): ...

def to_channel_dimension_format(
    image: np.ndarray,
    channel_dim: Union[ChannelDimension, str],
    input_channel_dim: Optional[Union[ChannelDimension, str]] = ...,
) -> np.ndarray: ...
def rescale(
    image: np.ndarray,
    scale: float,
    data_format: Optional[ChannelDimension] = ...,
    dtype: np.dtype = ...,
    input_data_format: Optional[Union[str, ChannelDimension]] = ...,
) -> np.ndarray: ...
def to_pil_image(
    image: Union[np.ndarray, PIL.Image.Image, torch.Tensor, tf.Tensor, jnp.ndarray],
    do_rescale: Optional[bool] = ...,
    image_mode: Optional[str] = ...,
    input_data_format: Optional[Union[str, ChannelDimension]] = ...,
) -> PIL.Image.Image: ...
def get_size_with_aspect_ratio(image_size, size, max_size=...) -> tuple[int, int]: ...
def get_resize_output_image_size(
    input_image: np.ndarray,
    size: Union[int, tuple[int, int], list[int], tuple[int]],
    default_to_square: bool = ...,
    max_size: Optional[int] = ...,
    input_data_format: Optional[Union[str, ChannelDimension]] = ...,
) -> tuple: ...
def resize(
    image: np.ndarray,
    size: tuple[int, int],
    resample: PILImageResampling = ...,
    reducing_gap: Optional[int] = ...,
    data_format: Optional[ChannelDimension] = ...,
    return_numpy: bool = ...,
    input_data_format: Optional[Union[str, ChannelDimension]] = ...,
) -> np.ndarray: ...
def normalize(
    image: np.ndarray,
    mean: Union[float, Collection[float]],
    std: Union[float, Collection[float]],
    data_format: Optional[ChannelDimension] = ...,
    input_data_format: Optional[Union[str, ChannelDimension]] = ...,
) -> np.ndarray: ...
def center_crop(
    image: np.ndarray,
    size: tuple[int, int],
    data_format: Optional[Union[str, ChannelDimension]] = ...,
    input_data_format: Optional[Union[str, ChannelDimension]] = ...,
) -> np.ndarray: ...
def center_to_corners_format(bboxes_center: TensorType) -> TensorType: ...
def corners_to_center_format(bboxes_corners: TensorType) -> TensorType: ...
def rgb_to_id(color): ...
def id_to_rgb(id_map): ...

class PaddingMode(ExplicitEnum):
    CONSTANT = ...
    REFLECT = ...
    REPLICATE = ...
    SYMMETRIC = ...

def pad(
    image: np.ndarray,
    padding: Union[int, tuple[int, int], Iterable[tuple[int, int]]],
    mode: PaddingMode = ...,
    constant_values: Union[float, Iterable[float]] = ...,
    data_format: Optional[Union[str, ChannelDimension]] = ...,
    input_data_format: Optional[Union[str, ChannelDimension]] = ...,
) -> np.ndarray: ...
def convert_to_rgb(image: ImageInput) -> ImageInput: ...
def flip_channel_order(
    image: np.ndarray,
    data_format: Optional[ChannelDimension] = ...,
    input_data_format: Optional[Union[str, ChannelDimension]] = ...,
) -> np.ndarray: ...
def group_images_by_shape(
    images: Union[list[torch.Tensor], torch.Tensor], disable_grouping: bool, is_nested: bool = ...
) -> tuple[
    dict[tuple[int, int], list[torch.Tensor]], dict[Union[int, tuple[int, int]], tuple[tuple[int, int], int]]
]: ...
def reorder_images(
    processed_images: dict[tuple[int, int], torch.Tensor],
    grouped_images_index: dict[Union[int, tuple[int, int]], tuple[tuple[int, int], int]],
    is_nested: bool = ...,
) -> Union[list[torch.Tensor], torch.Tensor]: ...

class NumpyToTensor:
    def __call__(self, image: np.ndarray): ...
