"""
This type stub file was generated by pyright.
"""

import os
import comet_ml
from enum import Enum
from typing import Any, Literal, Optional, TYPE_CHECKING, Union
from .. import TrainingArguments
from ..utils import is_torch_available
from ..trainer_callback import TrainerCallback
from ..trainer_utils import BestRun

if os.getenv("WANDB_MODE") == "offline": ...
logger = ...
if is_torch_available(): ...
_MIN_COMET_VERSION = ...
_comet_version = ...
_is_comet_installed = ...
_is_comet_recent_enough = ...
if comet_ml.config.get_config("comet.api_key") is not None:
    _is_comet_configured = ...
else:
    _is_comet_configured = ...
_has_neptune = ...
if TYPE_CHECKING and _has_neptune:
    _neptune_version = ...

def is_wandb_available(): ...
def is_trackio_available(): ...
def is_clearml_available(): ...
def is_comet_available(): ...
def is_tensorboard_available(): ...
def is_optuna_available(): ...
def is_ray_available(): ...
def is_ray_tune_available(): ...
def is_sigopt_available(): ...
def is_azureml_available(): ...
def is_mlflow_available(): ...
def is_dagshub_available(): ...
def is_neptune_available(): ...
def is_codecarbon_available(): ...
def is_flytekit_available(): ...
def is_flyte_deck_standard_available(): ...
def is_dvclive_available(): ...
def is_swanlab_available(): ...
def hp_params(trial): ...
def run_hp_search_optuna(trainer, n_trials: int, direction: str, **kwargs) -> BestRun: ...
def run_hp_search_ray(trainer, n_trials: int, direction: str, **kwargs) -> BestRun: ...
def run_hp_search_sigopt(trainer, n_trials: int, direction: str, **kwargs) -> BestRun: ...
def run_hp_search_wandb(trainer, n_trials: int, direction: str, **kwargs) -> BestRun: ...
def get_available_reporting_integrations(): ...
def rewrite_logs(d): ...

class TensorBoardCallback(TrainerCallback):
    def __init__(self, tb_writer=...) -> None: ...
    def on_train_begin(self, args, state, control, **kwargs): ...
    def on_log(self, args, state, control, logs=..., **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...

def save_model_architecture_to_file(model: Any, output_dir: str): ...

class WandbLogModel(str, Enum):
    CHECKPOINT = ...
    END = ...
    FALSE = ...
    @property
    def is_enabled(self) -> bool: ...

class WandbCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model, **kwargs): ...
    def on_train_begin(self, args, state, control, model=..., **kwargs): ...
    def on_train_end(self, args: TrainingArguments, state, control, model=..., processing_class=..., **kwargs): ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs): ...
    def on_save(self, args, state, control, **kwargs): ...
    def on_predict(self, args, state, control, metrics, **kwargs): ...

class TrackioCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model, **kwargs): ...
    def on_train_begin(self, args, state, control, model=..., **kwargs): ...
    def on_train_end(self, args: TrainingArguments, state, control, model=..., processing_class=..., **kwargs): ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs): ...
    def on_save(self, args, state, control, **kwargs): ...
    def on_predict(self, args, state, control, metrics, **kwargs): ...

class CometCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model): ...
    def on_train_begin(self, args, state, control, model=..., **kwargs): ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...
    def on_predict(self, args, state, control, metrics, **kwargs): ...

class AzureMLCallback(TrainerCallback):
    def __init__(self, azureml_run=...) -> None: ...
    def on_init_end(self, args, state, control, **kwargs): ...
    def on_log(self, args, state, control, logs=..., **kwargs): ...

class MLflowCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model): ...
    def on_train_begin(self, args, state, control, model=..., **kwargs): ...
    def on_log(self, args, state, control, logs, model=..., **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...
    def on_save(self, args, state, control, **kwargs): ...
    def __del__(self): ...

class DagsHubCallback(MLflowCallback):
    def __init__(self) -> None: ...
    def setup(self, *args, **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...

class NeptuneMissingConfiguration(Exception):
    def __init__(self) -> None: ...

class NeptuneCallback(TrainerCallback):
    integration_version_key = ...
    model_parameters_key = ...
    trial_name_key = ...
    trial_params_key = ...
    trainer_parameters_key = ...
    flat_metrics = ...
    def __init__(
        self,
        *,
        api_token: Optional[str] = ...,
        project: Optional[str] = ...,
        name: Optional[str] = ...,
        base_namespace: str = ...,
        run=...,
        log_parameters: bool = ...,
        log_checkpoints: Optional[str] = ...,
        **neptune_run_kwargs,
    ) -> None: ...
    @property
    def run(self): ...
    def on_init_end(self, args, state, control, **kwargs): ...
    def on_train_begin(self, args, state, control, model=..., **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...
    def __del__(self): ...
    def on_save(self, args, state, control, **kwargs): ...
    def on_evaluate(self, args, state, control, metrics=..., **kwargs): ...
    @classmethod
    def get_run(cls, trainer): ...
    def on_log(self, args, state, control, logs: Optional[dict[str, float]] = ..., **kwargs): ...

class CodeCarbonCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def on_init_end(self, args, state, control, **kwargs): ...
    def on_train_begin(self, args, state, control, model=..., **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...

class ClearMLCallback(TrainerCallback):
    log_suffix = ...
    _hparams_section = ...
    _model_config_section = ...
    _ignore_hparams_overrides = ...
    _ignoge_model_config_overrides = ...
    _model_config_description = ...
    _model_config_description_note = ...
    _train_run_counter = ...
    _model_connect_counter = ...
    _task_created_in_callback = ...
    _should_close_on_train_end = ...
    def __init__(self) -> None: ...
    def setup(self, args, state, model, processing_class, **kwargs): ...
    def on_train_begin(self, args, state, control, model=..., processing_class=..., **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...
    def on_log(self, args, state, control, model=..., processing_class=..., logs=..., **kwargs): ...
    def on_save(self, args, state, control, **kwargs): ...

class FlyteCallback(TrainerCallback):
    def __init__(self, save_log_history: bool = ..., sync_checkpoints: bool = ...) -> None: ...
    def on_save(self, args, state, control, **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...

class DVCLiveCallback(TrainerCallback):
    def __init__(
        self, live: Optional[Any] = ..., log_model: Optional[Union[Literal["all"], bool]] = ..., **kwargs
    ) -> None: ...
    def setup(self, args, state, model): ...
    def on_train_begin(self, args, state, control, model=..., **kwargs): ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs): ...
    def on_save(self, args, state, control, **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...

class SwanLabCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model, **kwargs): ...
    def on_train_begin(self, args, state, control, model=..., **kwargs): ...
    def on_train_end(self, args, state, control, model=..., processing_class=..., **kwargs): ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs): ...
    def on_save(self, args, state, control, **kwargs): ...
    def on_predict(self, args, state, control, metrics, **kwargs): ...

INTEGRATION_TO_CALLBACK = ...

def get_reporting_integration_callbacks(report_to): ...
