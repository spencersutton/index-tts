import os
from enum import StrEnum
from typing import TYPE_CHECKING, Any, Literal

import comet_ml

from .. import TrainingArguments
from ..trainer_callback import TrainerCallback
from ..trainer_utils import BestRun
from ..utils import is_torch_available

"""
Integrations with other Python libraries.
"""
if os.getenv("WANDB_MODE") == "offline": ...
logger = ...
if is_torch_available(): ...
_MIN_COMET_VERSION = ...
_comet_version = ...
_is_comet_installed = ...
_is_comet_recent_enough = ...
if comet_ml.config.get_config("comet.api_key") is not None:
    _is_comet_configured = ...
else:
    _is_comet_configured = ...
_has_neptune = ...
if TYPE_CHECKING and _has_neptune:
    _neptune_version = ...

def is_wandb_available():  # -> bool:
    ...
def is_trackio_available():  # -> bool:
    ...
def is_clearml_available():  # -> bool:
    ...
def is_comet_available():  # -> bool:
    ...
def is_tensorboard_available():  # -> bool:
    ...
def is_optuna_available():  # -> bool:
    ...
def is_ray_available():  # -> bool:
    ...
def is_ray_tune_available():  # -> bool:
    ...
def is_sigopt_available():  # -> bool:
    ...
def is_azureml_available():  # -> bool:
    ...
def is_mlflow_available():  # -> bool:
    ...
def is_dagshub_available():  # -> bool:
    ...
def is_neptune_available():  # -> bool:
    ...
def is_codecarbon_available():  # -> bool:
    ...
def is_flytekit_available():  # -> bool:
    ...
def is_flyte_deck_standard_available():  # -> bool:
    ...
def is_dvclive_available():  # -> bool:
    ...
def is_swanlab_available():  # -> bool:
    ...
def hp_params(trial):  # -> dict[Any, Any]:
    ...
def run_hp_search_optuna(trainer, n_trials: int, direction: str, **kwargs) -> BestRun: ...
def run_hp_search_ray(trainer, n_trials: int, direction: str, **kwargs) -> BestRun: ...
def run_hp_search_sigopt(trainer, n_trials: int, direction: str, **kwargs) -> BestRun: ...
def run_hp_search_wandb(trainer, n_trials: int, direction: str, **kwargs) -> BestRun: ...
def get_available_reporting_integrations():  # -> list[Any]:
    ...
def rewrite_logs(d):  # -> dict[Any, Any]:
    ...

class TensorBoardCallback(TrainerCallback):
    def __init__(self, tb_writer=...) -> None: ...
    def on_train_begin(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_log(self, args, state, control, logs=..., **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...

def save_model_architecture_to_file(model: Any, output_dir: str):  # -> None:
    ...

class WandbLogModel(StrEnum):
    CHECKPOINT = ...
    END = ...
    FALSE = ...
    @property
    def is_enabled(self) -> bool: ...

class WandbCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model, **kwargs):  # -> None:

        ...
    def on_train_begin(self, args, state, control, model=..., **kwargs):  # -> None:
        ...
    def on_train_end(
        self, args: TrainingArguments, state, control, model=..., processing_class=..., **kwargs
    ):  # -> None:
        ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs):  # -> None:
        ...
    def on_save(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_predict(self, args, state, control, metrics, **kwargs):  # -> None:
        ...

class TrackioCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model, **kwargs):  # -> None:

        ...
    def on_train_begin(self, args, state, control, model=..., **kwargs):  # -> None:
        ...
    def on_train_end(
        self, args: TrainingArguments, state, control, model=..., processing_class=..., **kwargs
    ):  # -> None:
        ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs):  # -> None:
        ...
    def on_save(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_predict(self, args, state, control, metrics, **kwargs):  # -> None:
        ...

class CometCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model):  # -> None:

        ...
    def on_train_begin(self, args, state, control, model=..., **kwargs):  # -> None:
        ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_predict(self, args, state, control, metrics, **kwargs):  # -> None:
        ...

class AzureMLCallback(TrainerCallback):
    def __init__(self, azureml_run=...) -> None: ...
    def on_init_end(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_log(self, args, state, control, logs=..., **kwargs):  # -> None:
        ...

class MLflowCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model):  # -> None:

        ...
    def on_train_begin(self, args, state, control, model=..., **kwargs):  # -> None:
        ...
    def on_log(self, args, state, control, logs, model=..., **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_save(self, args, state, control, **kwargs):  # -> None:
        ...
    def __del__(self) -> None:  # -> None:
        ...

class DagsHubCallback(MLflowCallback):
    def __init__(self) -> None: ...
    def setup(self, *args, **kwargs):  # -> None:

        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...

class NeptuneMissingConfiguration(Exception):
    def __init__(self) -> None: ...

class NeptuneCallback(TrainerCallback):
    integration_version_key = ...
    model_parameters_key = ...
    trial_name_key = ...
    trial_params_key = ...
    trainer_parameters_key = ...
    flat_metrics = ...
    def __init__(
        self,
        *,
        api_token: str | None = ...,
        project: str | None = ...,
        name: str | None = ...,
        base_namespace: str = ...,
        run=...,
        log_parameters: bool = ...,
        log_checkpoints: str | None = ...,
        **neptune_run_kwargs,
    ) -> None: ...
    @property
    def run(self):  # -> None:
        ...
    def on_init_end(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_train_begin(self, args, state, control, model=..., **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...
    def __del__(self) -> None:  # -> None:
        ...
    def on_save(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_evaluate(self, args, state, control, metrics=..., **kwargs):  # -> None:
        ...
    @classmethod
    def get_run(cls, trainer):  # -> None:
        ...
    def on_log(self, args, state, control, logs: dict[str, float] | None = ..., **kwargs):  # -> None:
        ...

class CodeCarbonCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def on_init_end(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_train_begin(self, args, state, control, model=..., **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...

class ClearMLCallback(TrainerCallback):
    log_suffix = ...
    _hparams_section = ...
    _model_config_section = ...
    _ignore_hparams_overrides = ...
    _ignoge_model_config_overrides = ...
    _model_config_description = ...
    _model_config_description_note = ...
    _train_run_counter = ...
    _model_connect_counter = ...
    _task_created_in_callback = ...
    _should_close_on_train_end = ...
    def __init__(self) -> None: ...
    def setup(self, args, state, model, processing_class, **kwargs):  # -> None:
        ...
    def on_train_begin(self, args, state, control, model=..., processing_class=..., **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_log(self, args, state, control, model=..., processing_class=..., logs=..., **kwargs):  # -> None:
        ...
    def on_save(self, args, state, control, **kwargs):  # -> None:
        ...

class FlyteCallback(TrainerCallback):
    def __init__(self, save_log_history: bool = ..., sync_checkpoints: bool = ...) -> None: ...
    def on_save(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...

class DVCLiveCallback(TrainerCallback):
    def __init__(self, live: Any | None = ..., log_model: Literal["all"] | bool | None = ..., **kwargs) -> None: ...
    def setup(self, args, state, model):  # -> None:

        ...
    def on_train_begin(self, args, state, control, model=..., **kwargs):  # -> None:
        ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs):  # -> None:
        ...
    def on_save(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, **kwargs):  # -> None:
        ...

class SwanLabCallback(TrainerCallback):
    def __init__(self) -> None: ...
    def setup(self, args, state, model, **kwargs):  # -> None:

        ...
    def on_train_begin(self, args, state, control, model=..., **kwargs):  # -> None:
        ...
    def on_train_end(self, args, state, control, model=..., processing_class=..., **kwargs):  # -> None:
        ...
    def on_log(self, args, state, control, model=..., logs=..., **kwargs):  # -> None:
        ...
    def on_save(self, args, state, control, **kwargs):  # -> None:
        ...
    def on_predict(self, args, state, control, metrics, **kwargs):  # -> None:
        ...

INTEGRATION_TO_CALLBACK = ...

def get_reporting_integration_callbacks(
    report_to,
):  # -> list[Any] | list[type[AzureMLCallback] | type[CometCallback] | type[MLflowCallback] | type[NeptuneCallback] | type[TensorBoardCallback] | type[TrackioCallback] | type[WandbCallback] | type[CodeCarbonCallback] | type[ClearMLCallback] | type[DagsHubCallback] | type[FlyteCallback] | type[DVCLiveCallback] | type[SwanLabCallback]]:
    ...
