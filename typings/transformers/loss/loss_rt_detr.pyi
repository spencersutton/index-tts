"""
This type stub file was generated by pyright.
"""

import torch
import torch.nn as nn

from ..utils import is_scipy_available, is_vision_available

if is_scipy_available(): ...
if is_vision_available(): ...

class RTDetrHungarianMatcher(nn.Module):
    """This class computes an assignment between the targets and the predictions of the network

    For efficiency reasons, the targets don't include the no_object. Because of this, in general, there are more
    predictions than targets. In this case, we do a 1-to-1 matching of the best predictions, while the others are
    un-matched (and thus treated as non-objects).

    Args:
        config: RTDetrConfig
    """
    def __init__(self, config) -> None: ...
    @torch.no_grad()
    def forward(self, outputs, targets):  # -> list[tuple[Tensor, Tensor]]:
        """Performs the matching

        Params:
            outputs: This is a dict that contains at least these entries:
                 "logits": Tensor of dim [batch_size, num_queries, num_classes] with the classification logits
                 "pred_boxes": Tensor of dim [batch_size, num_queries, 4] with the predicted box coordinates

            targets: This is a list of targets (len(targets) = batch_size), where each target is a dict containing:
                 "class_labels": Tensor of dim [num_target_boxes] (where num_target_boxes is the number of ground-truth
                           objects in the target) containing the class labels
                 "boxes": Tensor of dim [num_target_boxes, 4] containing the target box coordinates

        Returns:
            A list of size batch_size, containing tuples of (index_i, index_j) where:
                - index_i is the indices of the selected predictions (in order)
                - index_j is the indices of the corresponding selected targets (in order)
            For each batch element, it holds:
                len(index_i) = len(index_j) = min(num_queries, num_target_boxes)
        """
        ...

class RTDetrLoss(nn.Module):
    """
    This class computes the losses for RTDetr. The process happens in two steps: 1) we compute hungarian assignment
    between ground truth boxes and the outputs of the model 2) we supervise each pair of matched ground-truth /
    prediction (supervise class and box).

    Args:
        matcher (`DetrHungarianMatcher`):
            Module able to compute a matching between targets and proposals.
        weight_dict (`Dict`):
            Dictionary relating each loss with its weights. These losses are configured in RTDetrConf as
            `weight_loss_vfl`, `weight_loss_bbox`, `weight_loss_giou`
        losses (`list[str]`):
            List of all the losses to be applied. See `get_loss` for a list of all available losses.
        alpha (`float`):
            Parameter alpha used to compute the focal loss.
        gamma (`float`):
            Parameter gamma used to compute the focal loss.
        eos_coef (`float`):
            Relative classification weight applied to the no-object category.
        num_classes (`int`):
            Number of object categories, omitting the special no-object category.
    """
    def __init__(self, config) -> None: ...
    def loss_labels_vfl(self, outputs, targets, indices, num_boxes, log=...):  # -> dict[str, Any]:
        ...
    def loss_labels(self, outputs, targets, indices, num_boxes, log=...):  # -> dict[str, Tensor]:
        """Classification loss (NLL)
        targets dicts must contain the key "class_labels" containing a tensor of dim [nb_target_boxes]
        """
        ...

    @torch.no_grad()
    def loss_cardinality(self, outputs, targets, indices, num_boxes):  # -> dict[str, Tensor]:
        """
        Compute the cardinality error, i.e. the absolute error in the number of predicted non-empty boxes. This is not
        really a loss, it is intended for logging purposes only. It doesn't propagate gradients.
        """
        ...

    def loss_boxes(self, outputs, targets, indices, num_boxes):  # -> dict[Any, Any]:
        """
        Compute the losses related to the bounding boxes, the L1 regression loss and the GIoU loss. Targets dicts must
        contain the key "boxes" containing a tensor of dim [nb_target_boxes, 4]. The target boxes are expected in
        format (center_x, center_y, w, h), normalized by the image size.
        """
        ...

    def loss_masks(self, outputs, targets, indices, num_boxes):  # -> dict[str, Any]:
        """
        Compute the losses related to the masks: the focal loss and the dice loss. Targets dicts must contain the key
        "masks" containing a tensor of dim [nb_target_boxes, h, w].
        """
        ...

    def loss_labels_bce(self, outputs, targets, indices, num_boxes, log=...):  # -> dict[str, Any]:
        ...
    def loss_labels_focal(self, outputs, targets, indices, num_boxes, log=...):  # -> dict[str, Any]:
        ...
    def get_loss(
        self, loss, outputs, targets, indices, num_boxes
    ):  # -> dict[str, Tensor] | dict[str, Any] | dict[Any, Any]:
        ...
    @staticmethod
    def get_cdn_matched_indices(dn_meta, targets):  # -> list[Any]:
        ...
    def forward(self, outputs, targets):  # -> dict[Any, Any]:
        """
        This performs the loss computation.

        Args:
             outputs (`dict`, *optional*):
                Dictionary of tensors, see the output specification of the model for the format.
             targets (`list[dict]`, *optional*):
                List of dicts, such that `len(targets) == batch_size`. The expected keys in each dict depends on the
                losses applied, see each loss' doc.
        """
        ...

def RTDetrForObjectDetectionLoss(
    logits,
    labels,
    device,
    pred_boxes,
    config,
    outputs_class=...,
    outputs_coord=...,
    enc_topk_logits=...,
    enc_topk_bboxes=...,
    denoising_meta_values=...,
    **kwargs,
):  # -> tuple[int, Any, list[dict[str, Any]] | Any]:
    ...
