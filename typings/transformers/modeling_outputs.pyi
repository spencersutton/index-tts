"""
This type stub file was generated by pyright.
"""

import torch
from dataclasses import dataclass
from typing import Optional
from .cache_utils import Cache, EncoderDecoderCache
from .utils import ModelOutput

@dataclass
class BaseModelOutput(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BaseModelOutputWithNoAttention(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BaseModelOutputWithPooling(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    pooler_output: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BaseModelOutputWithPoolingAndNoAttention(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    pooler_output: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BaseModelOutputWithPast(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BaseModelOutputWithCrossAttentions(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BaseModelOutputWithPoolingAndCrossAttentions(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    pooler_output: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    past_key_values: Optional[Cache] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BaseModelOutputWithPastAndCrossAttentions(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class MoECausalLMOutputWithPast(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    z_loss: Optional[torch.FloatTensor] = ...
    aux_loss: Optional[torch.FloatTensor] = ...
    router_logits: Optional[tuple[torch.FloatTensor]] = ...

@dataclass
class MoEModelOutput(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    router_probs: Optional[tuple[torch.FloatTensor]] = ...

@dataclass
class MoeModelOutputWithPast(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    router_logits: Optional[tuple[torch.FloatTensor]] = ...

@dataclass
class MoeCausalLMOutputWithPast(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    aux_loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    router_logits: Optional[tuple[torch.FloatTensor]] = ...

@dataclass
class MoEModelOutputWithPastAndCrossAttentions(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    router_probs: Optional[tuple[torch.FloatTensor]] = ...

@dataclass
class Seq2SeqModelOutput(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class Seq2SeqMoEModelOutput(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_router_logits: Optional[tuple[torch.FloatTensor]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_router_logits: Optional[tuple[torch.FloatTensor]] = ...

@dataclass
class CausalLMOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class CausalLMOutputWithPast(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class CausalLMOutputWithCrossAttentions(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class SequenceClassifierOutputWithPast(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[Cache] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class MaskedLMOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class Seq2SeqLMOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class Seq2SeqMoEOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    encoder_z_loss: Optional[torch.FloatTensor] = ...
    decoder_z_loss: Optional[torch.FloatTensor] = ...
    encoder_aux_loss: Optional[torch.FloatTensor] = ...
    decoder_aux_loss: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_router_logits: Optional[tuple[torch.FloatTensor]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_router_logits: Optional[tuple[torch.FloatTensor]] = ...

@dataclass
class NextSentencePredictorOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class SequenceClassifierOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class Seq2SeqSequenceClassifierOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class MultipleChoiceModelOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class TokenClassifierOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class QuestionAnsweringModelOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    start_logits: Optional[torch.FloatTensor] = ...
    end_logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class Seq2SeqQuestionAnsweringModelOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    start_logits: Optional[torch.FloatTensor] = ...
    end_logits: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class SemanticSegmenterOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class ImageClassifierOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class ImageClassifierOutputWithNoAttention(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class DepthEstimatorOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    predicted_depth: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class ImageSuperResolutionOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    reconstruction: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class Wav2Vec2BaseModelOutput(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    extract_features: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class XVectorOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    embeddings: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BackboneOutput(ModelOutput):
    feature_maps: Optional[tuple[torch.FloatTensor]] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class BaseModelOutputWithPoolingAndProjection(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    pooler_output: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    projection_state: Optional[tuple[torch.FloatTensor]] = ...

@dataclass
class Seq2SeqSpectrogramOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    spectrogram: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
class Seq2SeqTSModelOutput(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    loc: Optional[torch.FloatTensor] = ...
    scale: Optional[torch.FloatTensor] = ...
    static_features: Optional[torch.FloatTensor] = ...

@dataclass
class Seq2SeqTSPredictionOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    params: Optional[tuple[torch.FloatTensor]] = ...
    past_key_values: Optional[EncoderDecoderCache] = ...
    decoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    decoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    cross_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_last_hidden_state: Optional[torch.FloatTensor] = ...
    encoder_hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    encoder_attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    loc: Optional[torch.FloatTensor] = ...
    scale: Optional[torch.FloatTensor] = ...
    static_features: Optional[torch.FloatTensor] = ...

@dataclass
class SampleTSPredictionOutput(ModelOutput):
    sequences: Optional[torch.FloatTensor] = ...

@dataclass
class MaskedImageModelingOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    reconstruction: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...
    @property
    def logits(self): ...
