import os
from abc import abstractmethod
from collections.abc import Callable
from contextlib import contextmanager
from enum import Enum
from functools import wraps
from typing import Any, Self, TypeVar, overload

import torch
from torch import Tensor, nn
from torch._C import dtype
from torch._prims_common import DeviceLikeType
from transformers.utils import is_torchao_available

from .configuration_utils import PretrainedConfig
from .generation import CompileConfig
from .integrations import PeftAdapterMixin
from .quantizers import HfQuantizer
from .utils import (
    PushToHubMixin,
    is_accelerate_available,
    is_kernels_available,
    is_peft_available,
    is_safetensors_available,
    is_torch_greater_or_equal,
)
from .utils.generic import GeneralInterface, OutputRecorder
from .utils.import_utils import is_sagemaker_mp_enabled

if is_torchao_available(): ...
XLA_USE_BF16 = ...
XLA_DOWNCAST_BF16 = ...
if is_accelerate_available():
    accelerate_version = ...
if is_safetensors_available(): ...
if is_kernels_available(): ...
logger = ...
_init_weights = ...
_is_quantized = ...
_is_ds_init_called = ...
_torch_distributed_available = ...
_is_dtensor_available = ...
if _is_dtensor_available: ...

def is_fsdp_enabled():  # -> bool:
    ...
def is_local_dist_rank_0():  # -> bool:
    ...

if is_sagemaker_mp_enabled():
    IS_SAGEMAKER_MP_POST_1_10 = ...
else:
    IS_SAGEMAKER_MP_POST_1_10 = ...
if is_peft_available(): ...
SpecificPreTrainedModelType = TypeVar("SpecificPreTrainedModelType", bound=PreTrainedModel)
TORCH_INIT_FUNCTIONS = ...
VLMS = ...

@contextmanager
def no_init_weights():  # -> Generator[None, Any, None]:

    ...
@contextmanager
def set_quantized_state():  # -> Generator[None, Any, None]:
    ...
@contextmanager
def set_zero3_state():  # -> Generator[None, Any, None]:
    ...
def restore_default_torch_dtype(func):  # -> _Wrapped[..., Any, ..., Any]:

    ...
def get_torch_context_manager_or_global_device():  # -> device | None:

    ...
def get_parameter_device(parameter: nn.Module | ModuleUtilsMixin):  # -> device | Any:
    ...
def get_parameter_dtype(parameter: nn.Module | ModuleUtilsMixin):  # -> dtype | Any | None:

    ...
def get_state_dict_dtype(state_dict): ...
def load_sharded_checkpoint(model, folder, strict=..., prefer_safe=...):  # -> _IncompatibleKeys:

    ...

str_to_torch_dtype = ...
if is_torch_greater_or_equal("2.3.0"): ...

def load_state_dict(
    checkpoint_file: str | os.PathLike,
    is_quantized: bool = ...,
    map_location: str | torch.device | None = ...,
    weights_only: bool = ...,
):  # -> dict[Any, Any] | Any:

    ...
def set_initialized_submodules(model, state_dict_keys):  # -> dict[Any, Any]:

    ...
def load_shard_file(
    args,
):  # -> tuple[list[Any], Any, Any] | tuple[list[Any], Any | dict[Any, Any] | None, Any | dict[Any, Any] | None]:
    ...
def load_shard_files_with_threadpool(
    args_list,
):  # -> tuple[list[Any], Any | dict[Any, Any] | None, Any | dict[Any, Any] | None]:
    ...

class PipelineParallel(Enum):
    inputs: 0
    outputs: 1

class ModuleUtilsMixin:
    def add_memory_hooks(self):  # -> None:

        ...
    def reset_memory_hooks_state(self):  # -> None:

        ...
    @property
    def device(self) -> torch.device: ...
    @property
    def dtype(self) -> torch.dtype: ...
    def invert_attention_mask(self, encoder_attention_mask: Tensor) -> Tensor: ...
    @staticmethod
    def create_extended_attention_mask_for_decoder(input_shape, attention_mask, device=...): ...
    def get_extended_attention_mask(
        self, attention_mask: Tensor, input_shape: tuple[int], device: torch.device = ..., dtype: torch.float = ...
    ) -> Tensor: ...
    def get_head_mask(
        self, head_mask: Tensor | None, num_hidden_layers: int, is_attention_chunked: bool = ...
    ) -> Tensor: ...
    def num_parameters(self, only_trainable: bool = ..., exclude_embeddings: bool = ...) -> int: ...
    def estimate_tokens(self, input_dict: dict[str, torch.Tensor | Any]) -> int: ...
    def floating_point_ops(self, input_dict: dict[str, torch.Tensor | Any], exclude_embeddings: bool = ...) -> int: ...

class EmbeddingAccessMixin:
    _input_embed_layer = ...
    def get_input_embeddings(self) -> nn.Module: ...
    def set_input_embeddings(self, value: nn.Module):  # -> None:

        ...
    def get_output_embeddings(self):  # -> None:
        ...
    def set_output_embeddings(self, new_embeddings):  # -> None:

        ...

class PreTrainedModel(nn.Module, EmbeddingAccessMixin, ModuleUtilsMixin, PushToHubMixin, PeftAdapterMixin):
    config_class = ...
    base_model_prefix = ...
    main_input_name = ...
    model_tags = ...
    _checkpoint_conversion_mapping = ...
    _auto_class = ...
    _no_split_modules = ...
    _skip_keys_device_placement = ...
    _keep_in_fp32_modules = ...
    _keep_in_fp32_modules_strict = ...
    _keys_to_ignore_on_load_missing = ...
    _keys_to_ignore_on_load_unexpected = ...
    _keys_to_ignore_on_save = ...
    _tied_weights_keys = ...
    is_parallelizable = ...
    supports_gradient_checkpointing = ...
    _is_stateful = ...
    _supports_flash_attn = ...
    _supports_sdpa = ...
    _supports_flex_attn = ...
    _can_compile_fullgraph = ...
    _tp_plan = ...
    _tp_size = ...
    _pp_plan = ...
    _supports_attention_backend = ...
    _can_record_outputs = ...
    @property
    @torch._dynamo.allow_in_graph
    def can_record_outputs(self) -> dict[str, OutputRecorder]: ...
    @property
    def dummy_inputs(self) -> dict[str, torch.Tensor]: ...
    @property
    def framework(self) -> str: ...
    def __init_subclass__(cls, **kwargs):  # -> None:
        ...
    def __init__(self, config: PretrainedConfig, *inputs, **kwargs) -> None: ...
    def post_init(self):  # -> None:

        ...
    def dequantize(self):  # -> Any:

        ...
    def add_model_tags(self, tags: list[str] | str) -> None: ...
    @property
    def base_model(self) -> nn.Module: ...
    @classmethod
    def can_generate(cls) -> bool: ...
    def get_correct_attn_implementation(self, _requested_attention: str, is_init_check: bool = ...) -> str: ...
    def set_attn_implementation(self, attn_implementation: str | dict):  # -> None:

        ...
    def enable_input_require_grads(self):  # -> None:

        ...
    def disable_input_require_grads(self):  # -> None:

        ...
    @torch.no_grad()
    def initialize_weights(self):  # -> None:

        ...
    def tie_weights(self):  # -> None:

        ...
    def resize_token_embeddings(
        self, new_num_tokens: int | None = ..., pad_to_multiple_of: int | None = ..., mean_resizing: bool = ...
    ) -> nn.Embedding: ...
    def resize_position_embeddings(self, new_num_position_embeddings: int): ...
    def get_position_embeddings(self) -> nn.Embedding | tuple[nn.Embedding]: ...
    def init_weights(self):  # -> None:

        ...
    def prune_heads(self, heads_to_prune: dict[int, list[int]]):  # -> None:

        ...
    def gradient_checkpointing_enable(self, gradient_checkpointing_kwargs=...):  # -> None:

        ...
    def gradient_checkpointing_disable(self):  # -> None:

        ...
    @property
    def is_gradient_checkpointing(self) -> bool: ...
    def save_pretrained(
        self,
        save_directory: str | os.PathLike,
        is_main_process: bool = ...,
        state_dict: dict | None = ...,
        save_function: Callable = ...,
        push_to_hub: bool = ...,
        max_shard_size: int | str = ...,
        safe_serialization: bool = ...,
        variant: str | None = ...,
        token: str | bool | None = ...,
        save_peft_format: bool = ...,
        **kwargs,
    ):  # -> None:

        ...
    @wraps(PushToHubMixin.push_to_hub)
    def push_to_hub(self, *args, **kwargs):  # -> str:
        ...
    def get_memory_footprint(self, return_buffers=...):  # -> int:

        ...
    def cuda(self, device: int | torch.device | None = ...) -> Self: ...
    @overload
    def to(
        self,
        device: DeviceLikeType | None = ...,
        dtype: dtype | None = ...,
        non_blocking: bool = ...,
    ) -> Self: ...
    @overload
    def to(self, dtype: dtype, non_blocking: bool = ...) -> Self: ...
    @overload
    def to(self, tensor: Tensor, non_blocking: bool = ...) -> Self: ...
    def half(self, *args: Any) -> Self: ...
    def float(self, *args: Any) -> Self: ...
    @classmethod
    def get_init_context(
        cls, is_quantized: bool, _is_ds_init_called: bool
    ):  # -> list[_GeneratorContextManager[None, None, None]]:
        ...
    @classmethod
    def from_pretrained(
        cls,
        pretrained_model_name_or_path: str | os.PathLike[str] | None,
        *model_args: Any,
        config: PretrainedConfig | str | os.PathLike[str] | None = ...,
        cache_dir: str | os.PathLike[str] | None = ...,
        ignore_mismatched_sizes: bool = ...,
        force_download: bool = ...,
        local_files_only: bool = ...,
        token: str | bool | None = ...,
        revision: str = ...,
        use_safetensors: bool | None = ...,
        weights_only: bool = ...,
        **kwargs: Any,
    ) -> Self: ...
    def retrieve_modules_from_names(self, names, add_prefix=..., remove_prefix=...):  # -> list[Any]:
        ...
    @classmethod
    def register_for_auto_class(cls, auto_class=...):  # -> None:

        ...
    def to_bettertransformer(self) -> PreTrainedModel: ...
    def reverse_bettertransformer(self): ...
    def warn_if_padding_and_no_attention_mask(self, input_ids, attention_mask):  # -> None:

        ...
    @property
    def supports_tp_plan(self):  # -> bool:

        ...
    @property
    def tp_size(self):  # -> None:

        ...
    @property
    def supports_pp_plan(self):  # -> bool:
        ...
    @property
    def loss_function(
        self,
    ):  # -> Callable[..., Tensor] | Callable[..., Tensor | None] | Callable[..., tuple[int, Any, list[dict[str, Any]] | None]] | Callable[..., tuple[int, Any, list[dict[str, Any]] | Any]] | Callable[..., tuple[int, Any, list[dict[str, Any | None]] | None]]:
        ...
    @loss_function.setter
    def loss_function(self, value):  # -> None:
        ...
    def get_compiled_call(self, compile_config: CompileConfig | None) -> Callable: ...
    @classmethod
    def is_backend_compatible(cls):  # -> bool:
        ...
    def get_parameter_or_buffer(self, target: str):  # -> Parameter | Tensor | Any:

        ...

if PreTrainedModel.push_to_hub.__doc__ is not None: ...

def unwrap_model(model: nn.Module, recursive: bool = ...) -> nn.Module: ...
def expand_device_map(device_map, param_names):  # -> dict[Any, Any]:

    ...
def is_accelerator_device(device: str | int | torch.device) -> bool: ...
def caching_allocator_warmup(
    model: PreTrainedModel, expanded_device_map: dict, hf_quantizer: HfQuantizer | None
):  # -> None:

    ...
def get_disk_only_shard_files(device_map, weight_map):  # -> list[Any]:

    ...

class AttentionInterface(GeneralInterface):
    _global_mapping = ...

ALL_ATTENTION_FUNCTIONS: AttentionInterface = ...

class PreTrainedAudioTokenizerBase(PreTrainedModel):
    @abstractmethod
    def encode(self, input_values: torch.Tensor, *args, **kwargs):  # -> None:

        ...
    @abstractmethod
    def decode(self, audio_codes: torch.Tensor, *args, **kwargs):  # -> None:

        ...
