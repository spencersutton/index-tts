"""
This type stub file was generated by pyright.
"""

import torch
from dataclasses import dataclass
from typing import Optional, Union
from torch import nn
from ...modeling_layers import GradientCheckpointingLayer
from ...modeling_outputs import (
    BaseModelOutput,
    ModelOutput,
    MultipleChoiceModelOutput,
    QuestionAnsweringModelOutput,
    SequenceClassifierOutput,
    TokenClassifierOutput,
)
from ...modeling_utils import PreTrainedModel
from ...utils import auto_docstring
from .configuration_canine import CanineConfig

logger = ...
_PRIMES = ...

@dataclass
@auto_docstring(custom_intro=...)
class CanineModelOutputWithPooling(ModelOutput):
    last_hidden_state: Optional[torch.FloatTensor] = ...
    pooler_output: Optional[torch.FloatTensor] = ...
    hidden_states: Optional[tuple[torch.FloatTensor]] = ...
    attentions: Optional[tuple[torch.FloatTensor]] = ...

def load_tf_weights_in_canine(model, config, tf_checkpoint_path): ...

class CanineEmbeddings(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(
        self,
        input_ids: Optional[torch.LongTensor] = ...,
        token_type_ids: Optional[torch.LongTensor] = ...,
        position_ids: Optional[torch.LongTensor] = ...,
        inputs_embeds: Optional[torch.FloatTensor] = ...,
    ) -> torch.FloatTensor: ...

class CharactersToMolecules(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, char_encoding: torch.Tensor) -> torch.Tensor: ...

class ConvProjection(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, inputs: torch.Tensor, final_seq_char_positions: Optional[torch.Tensor] = ...) -> torch.Tensor: ...

class CanineSelfAttention(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(
        self,
        from_tensor: torch.Tensor,
        to_tensor: torch.Tensor,
        attention_mask: Optional[torch.FloatTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        output_attentions: Optional[bool] = ...,
    ) -> tuple[torch.Tensor, Optional[torch.Tensor]]: ...

class CanineSelfOutput(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(
        self, hidden_states: tuple[torch.FloatTensor], input_tensor: torch.FloatTensor
    ) -> tuple[torch.FloatTensor, torch.FloatTensor]: ...

class CanineAttention(nn.Module):
    def __init__(
        self,
        config,
        local=...,
        always_attend_to_first_position: bool = ...,
        first_position_attends_to_all: bool = ...,
        attend_from_chunk_width: int = ...,
        attend_from_chunk_stride: int = ...,
        attend_to_chunk_width: int = ...,
        attend_to_chunk_stride: int = ...,
    ) -> None: ...
    def prune_heads(self, heads): ...
    def forward(
        self,
        hidden_states: tuple[torch.FloatTensor],
        attention_mask: Optional[torch.FloatTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        output_attentions: Optional[bool] = ...,
    ) -> tuple[torch.FloatTensor, Optional[torch.FloatTensor]]: ...

class CanineIntermediate(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_states: torch.FloatTensor) -> torch.FloatTensor: ...

class CanineOutput(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(
        self, hidden_states: tuple[torch.FloatTensor], input_tensor: torch.FloatTensor
    ) -> torch.FloatTensor: ...

class CanineLayer(GradientCheckpointingLayer):
    def __init__(
        self,
        config,
        local,
        always_attend_to_first_position,
        first_position_attends_to_all,
        attend_from_chunk_width,
        attend_from_chunk_stride,
        attend_to_chunk_width,
        attend_to_chunk_stride,
    ) -> None: ...
    def forward(
        self,
        hidden_states: tuple[torch.FloatTensor],
        attention_mask: Optional[torch.FloatTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        output_attentions: Optional[bool] = ...,
    ) -> tuple[torch.FloatTensor, Optional[torch.FloatTensor]]: ...
    def feed_forward_chunk(self, attention_output): ...

class CanineEncoder(nn.Module):
    def __init__(
        self,
        config,
        local=...,
        always_attend_to_first_position=...,
        first_position_attends_to_all=...,
        attend_from_chunk_width=...,
        attend_from_chunk_stride=...,
        attend_to_chunk_width=...,
        attend_to_chunk_stride=...,
    ) -> None: ...
    def forward(
        self,
        hidden_states: tuple[torch.FloatTensor],
        attention_mask: Optional[torch.FloatTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
    ) -> Union[tuple, BaseModelOutput]: ...

class CaninePooler(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_states: tuple[torch.FloatTensor]) -> torch.FloatTensor: ...

class CaninePredictionHeadTransform(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_states: tuple[torch.FloatTensor]) -> torch.FloatTensor: ...

class CanineLMPredictionHead(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_states: tuple[torch.FloatTensor]) -> torch.FloatTensor: ...

class CanineOnlyMLMHead(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, sequence_output: tuple[torch.Tensor]) -> tuple[torch.Tensor]: ...

@auto_docstring
class CaninePreTrainedModel(PreTrainedModel):
    config: CanineConfig
    load_tf_weights = ...
    base_model_prefix = ...
    supports_gradient_checkpointing = ...

@auto_docstring
class CanineModel(CaninePreTrainedModel):
    def __init__(self, config, add_pooling_layer=...) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.LongTensor] = ...,
        attention_mask: Optional[torch.FloatTensor] = ...,
        token_type_ids: Optional[torch.LongTensor] = ...,
        position_ids: Optional[torch.LongTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        inputs_embeds: Optional[torch.FloatTensor] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
    ) -> Union[tuple, CanineModelOutputWithPooling]: ...

@auto_docstring(custom_intro=...)
class CanineForSequenceClassification(CaninePreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.LongTensor] = ...,
        attention_mask: Optional[torch.FloatTensor] = ...,
        token_type_ids: Optional[torch.LongTensor] = ...,
        position_ids: Optional[torch.LongTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        inputs_embeds: Optional[torch.FloatTensor] = ...,
        labels: Optional[torch.LongTensor] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
    ) -> Union[tuple, SequenceClassifierOutput]: ...

@auto_docstring
class CanineForMultipleChoice(CaninePreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.LongTensor] = ...,
        attention_mask: Optional[torch.FloatTensor] = ...,
        token_type_ids: Optional[torch.LongTensor] = ...,
        position_ids: Optional[torch.LongTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        inputs_embeds: Optional[torch.FloatTensor] = ...,
        labels: Optional[torch.LongTensor] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
    ) -> Union[tuple, MultipleChoiceModelOutput]: ...

@auto_docstring
class CanineForTokenClassification(CaninePreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.LongTensor] = ...,
        attention_mask: Optional[torch.FloatTensor] = ...,
        token_type_ids: Optional[torch.LongTensor] = ...,
        position_ids: Optional[torch.LongTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        inputs_embeds: Optional[torch.FloatTensor] = ...,
        labels: Optional[torch.LongTensor] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
    ) -> Union[tuple, TokenClassifierOutput]: ...

@auto_docstring
class CanineForQuestionAnswering(CaninePreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.LongTensor] = ...,
        attention_mask: Optional[torch.FloatTensor] = ...,
        token_type_ids: Optional[torch.LongTensor] = ...,
        position_ids: Optional[torch.LongTensor] = ...,
        head_mask: Optional[torch.FloatTensor] = ...,
        inputs_embeds: Optional[torch.FloatTensor] = ...,
        start_positions: Optional[torch.LongTensor] = ...,
        end_positions: Optional[torch.LongTensor] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
    ) -> Union[tuple, QuestionAnsweringModelOutput]: ...

__all__ = [
    "CanineForMultipleChoice",
    "CanineForQuestionAnswering",
    "CanineForSequenceClassification",
    "CanineForTokenClassification",
    "CanineLayer",
    "CanineModel",
    "CaninePreTrainedModel",
    "load_tf_weights_in_canine",
]
