from collections.abc import Callable, Sequence
from functools import cache
from typing import Any

import numpy as np
import torch

def rot_matmul(a: torch.Tensor, b: torch.Tensor) -> torch.Tensor: ...
def rot_vec_mul(r: torch.Tensor, t: torch.Tensor) -> torch.Tensor: ...
@cache
def identity_rot_mats(
    batch_dims: tuple[int, ...],
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
) -> torch.Tensor: ...
@cache
def identity_trans(
    batch_dims: tuple[int, ...],
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
) -> torch.Tensor: ...
@cache
def identity_quats(
    batch_dims: tuple[int, ...],
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
) -> torch.Tensor: ...

_quat_elements: list[str] = ...
_qtr_keys: list[str] = ...
_qtr_ind_dict: dict[str, int] = ...
_QTR_MAT = np.zeros((4, 4, 3, 3))

def quat_to_rot(quat: torch.Tensor) -> torch.Tensor: ...
def rot_to_quat(rot: torch.Tensor) -> torch.Tensor: ...

_QUAT_MULTIPLY = np.zeros((4, 4, 4))
_QUAT_MULTIPLY_BY_VEC = ...
_CACHED_QUATS: dict[str, np.ndarray] = ...

def quat_multiply(quat1: torch.Tensor, quat2: torch.Tensor) -> torch.Tensor: ...
def quat_multiply_by_vec(quat: torch.Tensor, vec: torch.Tensor) -> torch.Tensor: ...
def invert_rot_mat(rot_mat: torch.Tensor) -> torch.Tensor: ...
def invert_quat(quat: torch.Tensor) -> torch.Tensor: ...

class Rotation:
    def __init__(
        self, rot_mats: torch.Tensor | None = ..., quats: torch.Tensor | None = ..., normalize_quats: bool = ...
    ) -> None: ...
    @staticmethod
    def identity(
        shape,
        dtype: torch.dtype | None = ...,
        device: torch.device | None = ...,
        requires_grad: bool = ...,
        fmt: str = ...,
    ) -> Rotation: ...
    def __getitem__(self, index: Any) -> Rotation: ...
    def __mul__(self, right: torch.Tensor) -> Rotation: ...
    def __rmul__(self, left: torch.Tensor) -> Rotation: ...
    @property
    def shape(self) -> torch.Size: ...
    @property
    def dtype(self) -> torch.dtype: ...
    @property
    def device(self) -> torch.device: ...
    @property
    def requires_grad(self) -> bool: ...
    def get_rot_mats(self) -> torch.Tensor: ...
    def get_quats(self) -> torch.Tensor: ...
    def get_cur_rot(self) -> torch.Tensor: ...
    def compose_q_update_vec(self, q_update_vec: torch.Tensor, normalize_quats: bool = ...) -> Rotation: ...
    def compose_r(self, r: Rotation) -> Rotation: ...
    def compose_q(self, r: Rotation, normalize_quats: bool = ...) -> Rotation: ...
    def apply(self, pts: torch.Tensor) -> torch.Tensor: ...
    def invert_apply(self, pts: torch.Tensor) -> torch.Tensor: ...
    def invert(self) -> Rotation: ...
    def unsqueeze(self, dim: int) -> Rotation: ...
    @staticmethod
    def cat(rs: Sequence[Rotation], dim: int) -> Rotation: ...
    def map_tensor_fn(self, fn: Callable[[torch.Tensor], torch.Tensor]) -> Rotation: ...
    def cuda(self) -> Rotation: ...
    def to(self, device: torch.device | None, dtype: torch.dtype | None) -> Rotation: ...
    def detach(self) -> Rotation: ...

class Rigid:
    def __init__(self, rots: Rotation | None, trans: torch.Tensor | None) -> None: ...
    @staticmethod
    def identity(
        shape: tuple[int, ...],
        dtype: torch.dtype | None = ...,
        device: torch.device | None = ...,
        requires_grad: bool = ...,
        fmt: str = ...,
    ) -> Rigid: ...
    def __getitem__(self, index: Any) -> Rigid: ...
    def __mul__(self, right: torch.Tensor) -> Rigid: ...
    def __rmul__(self, left: torch.Tensor) -> Rigid: ...
    @property
    def shape(self) -> torch.Size: ...
    @property
    def device(self) -> torch.device: ...
    def get_rots(self) -> Rotation: ...
    def get_trans(self) -> torch.Tensor: ...
    def compose_q_update_vec(self, q_update_vec: torch.Tensor) -> Rigid: ...
    def compose(self, r: Rigid) -> Rigid: ...
    def apply(self, pts: torch.Tensor) -> torch.Tensor: ...
    def invert_apply(self, pts: torch.Tensor) -> torch.Tensor: ...
    def invert(self) -> Rigid: ...
    def map_tensor_fn(self, fn: Callable[[torch.Tensor], torch.Tensor]) -> Rigid: ...
    def to_tensor_4x4(self) -> torch.Tensor: ...
    @staticmethod
    def from_tensor_4x4(t: torch.Tensor) -> Rigid: ...
    def to_tensor_7(self) -> torch.Tensor: ...
    @staticmethod
    def from_tensor_7(t: torch.Tensor, normalize_quats: bool = ...) -> Rigid: ...
    @staticmethod
    def from_3_points(
        p_neg_x_axis: torch.Tensor, origin: torch.Tensor, p_xy_plane: torch.Tensor, eps: float = ...
    ) -> Rigid: ...
    def unsqueeze(self, dim: int) -> Rigid: ...
    @staticmethod
    def cat(ts: Sequence[Rigid], dim: int) -> Rigid: ...
    def apply_rot_fn(self, fn: Callable[[Rotation], Rotation]) -> Rigid: ...
    def apply_trans_fn(self, fn: Callable[[torch.Tensor], torch.Tensor]) -> Rigid: ...
    def scale_translation(self, trans_scale_factor: float) -> Rigid: ...
    def stop_rot_gradient(self) -> Rigid: ...
    @staticmethod
    def make_transform_from_reference(
        n_xyz: torch.Tensor, ca_xyz: torch.Tensor, c_xyz: torch.Tensor, eps: float = ...
    ) -> Rigid: ...
    def cuda(self) -> Rigid: ...
