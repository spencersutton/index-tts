"""
This type stub file was generated by pyright.
"""

import numpy as np
import tensorflow as tf
from dataclasses import dataclass
from ...file_utils import (
    ModelOutput,
    add_start_docstrings,
    add_start_docstrings_to_model_forward,
    replace_return_docstrings,
)
from ...modeling_tf_outputs import TFBaseModelOutput
from ...modeling_tf_utils import TFModelInputType, TFPreTrainedModel, keras, keras_serializable, unpack_inputs
from .configuration_vit_mae import ViTMAEConfig

logger = ...
_CONFIG_FOR_DOC = ...
_CHECKPOINT_FOR_DOC = ...

@dataclass
class TFViTMAEModelOutput(ModelOutput):
    last_hidden_state: tf.Tensor | None = ...
    mask: tf.Tensor | None = ...
    ids_restore: tf.Tensor | None = ...
    hidden_states: tuple[tf.Tensor] | None = ...
    attentions: tuple[tf.Tensor] | None = ...

@dataclass
class TFViTMAEDecoderOutput(ModelOutput):
    logits: tf.Tensor | None = ...
    hidden_states: tuple[tf.Tensor] | None = ...
    attentions: tuple[tf.Tensor] | None = ...

@dataclass
class TFViTMAEForPreTrainingOutput(ModelOutput):
    loss: tf.Tensor | None = ...
    logits: tf.Tensor | None = ...
    mask: tf.Tensor | None = ...
    ids_restore: tf.Tensor | None = ...
    hidden_states: tuple[tf.Tensor] | None = ...
    attentions: tuple[tf.Tensor] | None = ...

def get_2d_sincos_pos_embed(embed_dim, grid_size, add_cls_token=...): ...
def get_2d_sincos_pos_embed_from_grid(embed_dim, grid): ...
def get_1d_sincos_pos_embed_from_grid(embed_dim, pos): ...

class TFViTMAEEmbeddings(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def build(self, input_shape=...): ...
    def interpolate_pos_encoding(self, embeddings, height, width) -> tf.Tensor: ...
    def random_masking(self, sequence: tf.Tensor, noise: tf.Tensor | None = ...): ...
    def call(
        self, pixel_values: tf.Tensor, noise: tf.Tensor | None = ..., interpolate_pos_encoding: bool = ...
    ) -> tf.Tensor: ...

class TFViTMAEPatchEmbeddings(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def call(
        self, pixel_values: tf.Tensor, training: bool = ..., interpolate_pos_encoding: bool = ...
    ) -> tf.Tensor: ...
    def build(self, input_shape=...): ...

class TFViTMAESelfAttention(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def transpose_for_scores(self, tensor: tf.Tensor, batch_size: int) -> tf.Tensor: ...
    def call(
        self, hidden_states: tf.Tensor, head_mask: tf.Tensor, output_attentions: bool, training: bool = ...
    ) -> tuple[tf.Tensor]: ...
    def build(self, input_shape=...): ...

class TFViTMAESelfOutput(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def call(self, hidden_states: tf.Tensor, input_tensor: tf.Tensor, training: bool = ...) -> tf.Tensor: ...
    def build(self, input_shape=...): ...

class TFViTMAEAttention(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def prune_heads(self, heads): ...
    def call(
        self, input_tensor: tf.Tensor, head_mask: tf.Tensor, output_attentions: bool, training: bool = ...
    ) -> tuple[tf.Tensor]: ...
    def build(self, input_shape=...): ...

class TFViTMAEIntermediate(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def call(self, hidden_states: tf.Tensor) -> tf.Tensor: ...
    def build(self, input_shape=...): ...

class TFViTMAEOutput(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def call(self, hidden_states: tf.Tensor, input_tensor: tf.Tensor, training: bool = ...) -> tf.Tensor: ...
    def build(self, input_shape=...): ...

class TFViTMAELayer(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def call(
        self, hidden_states: tf.Tensor, head_mask: tf.Tensor, output_attentions: bool, training: bool = ...
    ) -> tuple[tf.Tensor]: ...
    def build(self, input_shape=...): ...

class TFViTMAEEncoder(keras.layers.Layer):
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def call(
        self,
        hidden_states: tf.Tensor,
        head_mask: tf.Tensor,
        output_attentions: bool,
        output_hidden_states: bool,
        return_dict: bool,
        training: bool = ...,
    ) -> TFBaseModelOutput | tuple[tf.Tensor]: ...
    def build(self, input_shape=...): ...

@keras_serializable
class TFViTMAEMainLayer(keras.layers.Layer):
    config_class = ViTMAEConfig
    def __init__(self, config: ViTMAEConfig, **kwargs) -> None: ...
    def get_input_embeddings(self) -> keras.layers.Layer: ...
    @unpack_inputs
    def call(
        self,
        pixel_values: TFModelInputType | None = ...,
        noise: tf.Tensor | None = ...,
        head_mask: np.ndarray | tf.Tensor | None = ...,
        output_attentions: bool | None = ...,
        output_hidden_states: bool | None = ...,
        return_dict: bool | None = ...,
        training: bool = ...,
        interpolate_pos_encoding: bool = ...,
    ) -> TFViTMAEModelOutput | tuple[tf.Tensor]: ...
    def build(self, input_shape=...): ...

class TFViTMAEPreTrainedModel(TFPreTrainedModel):
    config_class = ViTMAEConfig
    base_model_prefix = ...
    main_input_name = ...

VIT_MAE_START_DOCSTRING = ...
VIT_MAE_INPUTS_DOCSTRING = ...

@add_start_docstrings(..., VIT_MAE_START_DOCSTRING)
class TFViTMAEModel(TFViTMAEPreTrainedModel):
    def __init__(self, config: ViTMAEConfig, *inputs, **kwargs) -> None: ...
    def get_input_embeddings(self): ...
    @unpack_inputs
    @add_start_docstrings_to_model_forward(VIT_MAE_INPUTS_DOCSTRING)
    @replace_return_docstrings(output_type=TFViTMAEModelOutput, config_class=_CONFIG_FOR_DOC)
    def call(
        self,
        pixel_values: TFModelInputType | None = ...,
        noise: tf.Tensor | None = ...,
        head_mask: np.ndarray | tf.Tensor | None = ...,
        output_attentions: bool | None = ...,
        output_hidden_states: bool | None = ...,
        return_dict: bool | None = ...,
        training: bool = ...,
        interpolate_pos_encoding: bool = ...,
    ) -> TFViTMAEModelOutput | tuple[tf.Tensor]: ...
    def build(self, input_shape=...): ...

class TFViTMAEDecoder(keras.layers.Layer):
    def __init__(self, config, num_patches, **kwargs) -> None: ...
    def build(self, input_shape=...): ...
    def interpolate_pos_encoding(self, embeddings) -> tf.Tensor: ...
    def call(
        self,
        hidden_states,
        ids_restore,
        output_attentions=...,
        output_hidden_states=...,
        return_dict=...,
        interpolate_pos_encoding=...,
    ): ...

@add_start_docstrings(..., VIT_MAE_START_DOCSTRING)
class TFViTMAEForPreTraining(TFViTMAEPreTrainedModel):
    def __init__(self, config) -> None: ...
    def get_input_embeddings(self): ...
    def patchify(self, pixel_values, interpolate_pos_encoding: bool = ...): ...
    def unpatchify(self, patchified_pixel_values, original_image_size: tuple[int, int] | None = ...): ...
    def forward_loss(self, pixel_values, pred, mask, interpolate_pos_encoding: bool = ...): ...
    @unpack_inputs
    @add_start_docstrings_to_model_forward(VIT_MAE_INPUTS_DOCSTRING)
    @replace_return_docstrings(output_type=TFViTMAEForPreTrainingOutput, config_class=_CONFIG_FOR_DOC)
    def call(
        self,
        pixel_values: TFModelInputType | None = ...,
        noise: tf.Tensor | None = ...,
        head_mask: np.ndarray | tf.Tensor | None = ...,
        output_attentions: bool | None = ...,
        output_hidden_states: bool | None = ...,
        return_dict: bool | None = ...,
        training: bool = ...,
        interpolate_pos_encoding: bool = ...,
    ) -> TFViTMAEForPreTrainingOutput | tuple[tf.Tensor]: ...
    def build(self, input_shape=...): ...

__all__ = ["TFViTMAEForPreTraining", "TFViTMAEModel", "TFViTMAEPreTrainedModel"]
