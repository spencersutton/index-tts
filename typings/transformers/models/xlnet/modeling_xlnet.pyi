"""
This type stub file was generated by pyright.
"""

import torch
from dataclasses import dataclass
from typing import Optional, Union
from torch import nn
from ...generation import GenerationMixin
from ...modeling_utils import PreTrainedModel
from ...utils import ModelOutput, auto_docstring
from .configuration_xlnet import XLNetConfig

logger = ...

def build_tf_xlnet_to_pytorch_map(model, config, tf_weights=...): ...
def load_tf_weights_in_xlnet(model, config, tf_path): ...

class XLNetRelativeAttention(nn.Module):
    def __init__(self, config) -> None: ...
    def prune_heads(self, heads): ...
    @staticmethod
    def rel_shift(x, klen=...): ...
    @staticmethod
    def rel_shift_bnij(x, klen=...): ...
    def rel_attn_core(
        self, q_head, k_head_h, v_head_h, k_head_r, seg_mat=..., attn_mask=..., head_mask=..., output_attentions=...
    ): ...
    def post_attention(self, h, attn_vec, residual=...): ...
    def forward(
        self,
        h,
        g,
        attn_mask_h,
        attn_mask_g,
        r,
        seg_mat,
        mems=...,
        target_mapping=...,
        head_mask=...,
        output_attentions=...,
    ): ...

class XLNetFeedForward(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, inp): ...

class XLNetLayer(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(
        self,
        output_h,
        output_g,
        attn_mask_h,
        attn_mask_g,
        r,
        seg_mat,
        mems=...,
        target_mapping=...,
        head_mask=...,
        output_attentions=...,
    ): ...
    def ff_chunk(self, output_x): ...

class XLNetPoolerStartLogits(nn.Module):
    def __init__(self, config: XLNetConfig) -> None: ...
    def forward(
        self, hidden_states: torch.FloatTensor, p_mask: Optional[torch.FloatTensor] = ...
    ) -> torch.FloatTensor: ...

class XLNetPoolerEndLogits(nn.Module):
    def __init__(self, config: XLNetConfig) -> None: ...
    def forward(
        self,
        hidden_states: torch.FloatTensor,
        start_states: Optional[torch.FloatTensor] = ...,
        start_positions: Optional[torch.LongTensor] = ...,
        p_mask: Optional[torch.FloatTensor] = ...,
    ) -> torch.FloatTensor: ...

class XLNetPoolerAnswerClass(nn.Module):
    def __init__(self, config: XLNetConfig) -> None: ...
    def forward(
        self,
        hidden_states: torch.FloatTensor,
        start_states: Optional[torch.FloatTensor] = ...,
        start_positions: Optional[torch.LongTensor] = ...,
        cls_index: Optional[torch.LongTensor] = ...,
    ) -> torch.FloatTensor: ...

class XLNetSequenceSummary(nn.Module):
    def __init__(self, config: XLNetConfig) -> None: ...
    def forward(
        self, hidden_states: torch.FloatTensor, cls_index: Optional[torch.LongTensor] = ...
    ) -> torch.FloatTensor: ...

@auto_docstring
class XLNetPreTrainedModel(PreTrainedModel):
    config: XLNetConfig
    load_tf_weights = ...
    base_model_prefix = ...

@dataclass
@auto_docstring(
    custom_intro="""
    Output type of [`XLNetModel`].
    """
)
class XLNetModelOutput(ModelOutput):
    last_hidden_state: torch.FloatTensor
    mems: Optional[list[torch.FloatTensor]] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
@auto_docstring(
    custom_intro="""
    Output type of [`XLNetLMHeadModel`].
    """
)
class XLNetLMHeadModelOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    mems: Optional[list[torch.FloatTensor]] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
@auto_docstring(custom_intro=...)
class XLNetForSequenceClassificationOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    mems: Optional[list[torch.FloatTensor]] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
@auto_docstring(custom_intro=...)
class XLNetForTokenClassificationOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    mems: Optional[list[torch.FloatTensor]] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
@auto_docstring(custom_intro=...)
class XLNetForMultipleChoiceOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    logits: Optional[torch.FloatTensor] = ...
    mems: Optional[list[torch.FloatTensor]] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
@auto_docstring(custom_intro=...)
class XLNetForQuestionAnsweringSimpleOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    start_logits: Optional[torch.FloatTensor] = ...
    end_logits: Optional[torch.FloatTensor] = ...
    mems: Optional[list[torch.FloatTensor]] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@dataclass
@auto_docstring(custom_intro=...)
class XLNetForQuestionAnsweringOutput(ModelOutput):
    loss: Optional[torch.FloatTensor] = ...
    start_top_log_probs: Optional[torch.FloatTensor] = ...
    start_top_index: Optional[torch.LongTensor] = ...
    end_top_log_probs: Optional[torch.FloatTensor] = ...
    end_top_index: Optional[torch.LongTensor] = ...
    cls_logits: Optional[torch.FloatTensor] = ...
    mems: Optional[list[torch.FloatTensor]] = ...
    hidden_states: Optional[tuple[torch.FloatTensor, ...]] = ...
    attentions: Optional[tuple[torch.FloatTensor, ...]] = ...

@auto_docstring
class XLNetModel(XLNetPreTrainedModel):
    def __init__(self, config) -> None: ...
    def get_input_embeddings(self): ...
    def set_input_embeddings(self, new_embeddings): ...
    def create_mask(self, qlen, mlen): ...
    def cache_mem(self, curr_out, prev_mem): ...
    @staticmethod
    def positional_embedding(pos_seq, inv_freq, bsz=...): ...
    def relative_positional_encoding(self, qlen, klen, bsz=...): ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.Tensor] = ...,
        attention_mask: Optional[torch.Tensor] = ...,
        mems: Optional[torch.Tensor] = ...,
        perm_mask: Optional[torch.Tensor] = ...,
        target_mapping: Optional[torch.Tensor] = ...,
        token_type_ids: Optional[torch.Tensor] = ...,
        input_mask: Optional[torch.Tensor] = ...,
        head_mask: Optional[torch.Tensor] = ...,
        inputs_embeds: Optional[torch.Tensor] = ...,
        use_mems: Optional[bool] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
        **kwargs,
    ) -> Union[tuple, XLNetModelOutput]: ...

@auto_docstring(custom_intro=...)
class XLNetLMHeadModel(XLNetPreTrainedModel, GenerationMixin):
    _tied_weights_keys = ...
    def __init__(self, config) -> None: ...
    def get_output_embeddings(self): ...
    def set_output_embeddings(self, new_embeddings): ...
    def prepare_inputs_for_generation(self, input_ids, past_key_values=..., use_mems=..., **kwargs): ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.Tensor] = ...,
        attention_mask: Optional[torch.Tensor] = ...,
        mems: Optional[torch.Tensor] = ...,
        perm_mask: Optional[torch.Tensor] = ...,
        target_mapping: Optional[torch.Tensor] = ...,
        token_type_ids: Optional[torch.Tensor] = ...,
        input_mask: Optional[torch.Tensor] = ...,
        head_mask: Optional[torch.Tensor] = ...,
        inputs_embeds: Optional[torch.Tensor] = ...,
        labels: Optional[torch.Tensor] = ...,
        use_mems: Optional[bool] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
        **kwargs,
    ) -> Union[tuple, XLNetLMHeadModelOutput]: ...

@auto_docstring(custom_intro=...)
class XLNetForSequenceClassification(XLNetPreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.Tensor] = ...,
        attention_mask: Optional[torch.Tensor] = ...,
        mems: Optional[torch.Tensor] = ...,
        perm_mask: Optional[torch.Tensor] = ...,
        target_mapping: Optional[torch.Tensor] = ...,
        token_type_ids: Optional[torch.Tensor] = ...,
        input_mask: Optional[torch.Tensor] = ...,
        head_mask: Optional[torch.Tensor] = ...,
        inputs_embeds: Optional[torch.Tensor] = ...,
        labels: Optional[torch.Tensor] = ...,
        use_mems: Optional[bool] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
        **kwargs,
    ) -> Union[tuple, XLNetForSequenceClassificationOutput]: ...

@auto_docstring
class XLNetForTokenClassification(XLNetPreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.Tensor] = ...,
        attention_mask: Optional[torch.Tensor] = ...,
        mems: Optional[torch.Tensor] = ...,
        perm_mask: Optional[torch.Tensor] = ...,
        target_mapping: Optional[torch.Tensor] = ...,
        token_type_ids: Optional[torch.Tensor] = ...,
        input_mask: Optional[torch.Tensor] = ...,
        head_mask: Optional[torch.Tensor] = ...,
        inputs_embeds: Optional[torch.Tensor] = ...,
        labels: Optional[torch.Tensor] = ...,
        use_mems: Optional[bool] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
        **kwargs,
    ) -> Union[tuple, XLNetForTokenClassificationOutput]: ...

@auto_docstring
class XLNetForMultipleChoice(XLNetPreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.Tensor] = ...,
        token_type_ids: Optional[torch.Tensor] = ...,
        input_mask: Optional[torch.Tensor] = ...,
        attention_mask: Optional[torch.Tensor] = ...,
        mems: Optional[torch.Tensor] = ...,
        perm_mask: Optional[torch.Tensor] = ...,
        target_mapping: Optional[torch.Tensor] = ...,
        head_mask: Optional[torch.Tensor] = ...,
        inputs_embeds: Optional[torch.Tensor] = ...,
        labels: Optional[torch.Tensor] = ...,
        use_mems: Optional[bool] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
        **kwargs,
    ) -> Union[tuple, XLNetForMultipleChoiceOutput]: ...

@auto_docstring(custom_intro=...)
class XLNetForQuestionAnsweringSimple(XLNetPreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.Tensor] = ...,
        attention_mask: Optional[torch.Tensor] = ...,
        mems: Optional[torch.Tensor] = ...,
        perm_mask: Optional[torch.Tensor] = ...,
        target_mapping: Optional[torch.Tensor] = ...,
        token_type_ids: Optional[torch.Tensor] = ...,
        input_mask: Optional[torch.Tensor] = ...,
        head_mask: Optional[torch.Tensor] = ...,
        inputs_embeds: Optional[torch.Tensor] = ...,
        start_positions: Optional[torch.Tensor] = ...,
        end_positions: Optional[torch.Tensor] = ...,
        use_mems: Optional[bool] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
        **kwargs,
    ) -> Union[tuple, XLNetForQuestionAnsweringSimpleOutput]: ...

@auto_docstring
class XLNetForQuestionAnswering(XLNetPreTrainedModel):
    def __init__(self, config) -> None: ...
    @auto_docstring
    def forward(
        self,
        input_ids: Optional[torch.Tensor] = ...,
        attention_mask: Optional[torch.Tensor] = ...,
        mems: Optional[torch.Tensor] = ...,
        perm_mask: Optional[torch.Tensor] = ...,
        target_mapping: Optional[torch.Tensor] = ...,
        token_type_ids: Optional[torch.Tensor] = ...,
        input_mask: Optional[torch.Tensor] = ...,
        head_mask: Optional[torch.Tensor] = ...,
        inputs_embeds: Optional[torch.Tensor] = ...,
        start_positions: Optional[torch.Tensor] = ...,
        end_positions: Optional[torch.Tensor] = ...,
        is_impossible: Optional[torch.Tensor] = ...,
        cls_index: Optional[torch.Tensor] = ...,
        p_mask: Optional[torch.Tensor] = ...,
        use_mems: Optional[bool] = ...,
        output_attentions: Optional[bool] = ...,
        output_hidden_states: Optional[bool] = ...,
        return_dict: Optional[bool] = ...,
        **kwargs,
    ) -> Union[tuple, XLNetForQuestionAnsweringOutput]: ...

__all__ = [
    "XLNetForMultipleChoice",
    "XLNetForQuestionAnswering",
    "XLNetForQuestionAnsweringSimple",
    "XLNetForSequenceClassification",
    "XLNetForTokenClassification",
    "XLNetLMHeadModel",
    "XLNetModel",
    "XLNetPreTrainedModel",
    "load_tf_weights_in_xlnet",
]
