from dataclasses import dataclass

import torch
from torch import nn

from ...modeling_outputs import DepthEstimatorOutput
from ...modeling_utils import PreTrainedModel
from ...utils import ModelOutput
from .configuration_zoedepth import ZoeDepthConfig

"""PyTorch ZoeDepth model."""
logger = ...

@dataclass
class ZoeDepthDepthEstimatorOutput(ModelOutput):
    loss: torch.FloatTensor | None = ...
    predicted_depth: torch.FloatTensor | None = ...
    domain_logits: torch.FloatTensor | None = ...
    hidden_states: tuple[torch.FloatTensor, ...] | None = ...
    attentions: tuple[torch.FloatTensor, ...] | None = ...

class ZoeDepthReassembleStage(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_states: list[torch.Tensor], patch_height, patch_width) -> list[torch.Tensor]: ...

class ZoeDepthReassembleLayer(nn.Module):
    def __init__(self, config, channels, factor) -> None: ...
    def forward(self, hidden_state):  # -> Any:
        ...

class ZoeDepthFeatureFusionStage(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_states):  # -> list[Any]:
        ...

class ZoeDepthPreActResidualLayer(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_state: torch.Tensor) -> torch.Tensor: ...

class ZoeDepthFeatureFusionLayer(nn.Module):
    def __init__(self, config, align_corners=...) -> None: ...
    def forward(self, hidden_state, residual=...):  # -> Any:
        ...

class ZoeDepthNeck(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_states: list[torch.Tensor], patch_height, patch_width) -> list[torch.Tensor]: ...

class ZoeDepthRelativeDepthEstimationHead(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, hidden_states: list[torch.Tensor]) -> torch.Tensor: ...

def log_binom(n, k, eps=...): ...

class LogBinomialSoftmax(nn.Module):
    def __init__(self, n_classes=..., act=...) -> None: ...
    def forward(self, probabilities, temperature=..., eps=...): ...

class ZoeDepthConditionalLogBinomialSoftmax(nn.Module):
    def __init__(self, config, in_features, condition_dim, n_classes=..., bottleneck_factor=...) -> None: ...
    def forward(self, main_feature, condition_feature):  # -> Any:

        ...

class ZoeDepthSeedBinRegressor(nn.Module):
    def __init__(self, config, n_bins=..., mlp_dim=..., min_depth=..., max_depth=...) -> None: ...
    def forward(self, x):  # -> tuple[Any, Tensor] | tuple[Any, Any]:

        ...

@torch.jit.script
def inv_attractor(dx, alpha: float = ..., gamma: int = ...): ...

class ZoeDepthAttractorLayer(nn.Module):
    def __init__(
        self, config, n_bins, n_attractors=..., min_depth=..., max_depth=..., memory_efficient=...
    ) -> None: ...
    def forward(self, x, prev_bin, prev_bin_embedding=..., interpolate=...):  # -> tuple[Tensor | Any, Tensor]:

        ...

class ZoeDepthAttractorLayerUnnormed(nn.Module):
    def __init__(
        self, config, n_bins, n_attractors=..., min_depth=..., max_depth=..., memory_efficient=...
    ) -> None: ...
    def forward(self, x, prev_bin, prev_bin_embedding=..., interpolate=...):  # -> tuple[Tensor | Any, Tensor | Any]:

        ...

class ZoeDepthProjector(nn.Module):
    def __init__(self, in_features, out_features, mlp_dim=...) -> None: ...
    def forward(self, hidden_state: torch.Tensor) -> torch.Tensor: ...

class ZoeDepthMultiheadAttention(nn.Module):
    def __init__(self, hidden_size, num_attention_heads, dropout) -> None: ...
    def forward(
        self,
        queries: torch.Tensor,
        keys: torch.Tensor,
        values: torch.Tensor,
        attention_mask: torch.FloatTensor | None = ...,
        output_attentions: bool | None = ...,
    ) -> tuple[torch.Tensor]: ...

class ZoeDepthTransformerEncoderLayer(nn.Module):
    def __init__(self, config, dropout=..., activation=...) -> None: ...
    def forward(self, src, src_mask: torch.Tensor | None = ...):  # -> Any:
        ...

class ZoeDepthPatchTransformerEncoder(nn.Module):
    def __init__(self, config) -> None: ...
    def positional_encoding_1d(self, batch_size, sequence_length, embedding_dim, device=..., dtype=...):  # -> Tensor:

        ...
    def forward(self, x):  # -> Any:

        ...

class ZoeDepthMLPClassifier(nn.Module):
    def __init__(self, in_features, out_features) -> None: ...
    def forward(self, hidden_state):  # -> Any:
        ...

class ZoeDepthMultipleMetricDepthEstimationHeads(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, outconv_activation, bottleneck, feature_blocks, relative_depth):  # -> tuple[Tensor, Any]:
        ...

class ZoeDepthMetricDepthEstimationHead(nn.Module):
    def __init__(self, config) -> None: ...
    def forward(self, outconv_activation, bottleneck, feature_blocks, relative_depth):  # -> tuple[Tensor, None]:
        ...

class ZoeDepthPreTrainedModel(PreTrainedModel):
    config: ZoeDepthConfig
    base_model_prefix = ...
    main_input_name = ...
    supports_gradient_checkpointing = ...

class ZoeDepthForDepthEstimation(ZoeDepthPreTrainedModel):
    def __init__(self, config) -> None: ...
    def forward(
        self,
        pixel_values: torch.FloatTensor,
        labels: torch.LongTensor | None = ...,
        output_attentions: bool | None = ...,
        output_hidden_states: bool | None = ...,
        return_dict: bool | None = ...,
    ) -> tuple[torch.Tensor] | DepthEstimatorOutput: ...

__all__ = ["ZoeDepthForDepthEstimation", "ZoeDepthPreTrainedModel"]
