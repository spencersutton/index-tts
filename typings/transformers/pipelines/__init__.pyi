"""
This type stub file was generated by pyright.
"""

import json
import os
import warnings
import tensorflow as tf
import torch
from pathlib import Path
from typing import Any, Literal, Optional, TYPE_CHECKING, Union, overload
from huggingface_hub import model_info
from ..configuration_utils import PretrainedConfig
from ..dynamic_module_utils import get_class_from_dynamic_module
from ..feature_extraction_utils import PreTrainedFeatureExtractor
from ..image_processing_utils import BaseImageProcessor
from ..models.auto.configuration_auto import AutoConfig
from ..models.auto.feature_extraction_auto import AutoFeatureExtractor, FEATURE_EXTRACTOR_MAPPING
from ..models.auto.image_processing_auto import AutoImageProcessor, IMAGE_PROCESSOR_MAPPING
from ..models.auto.modeling_auto import (
    AutoModel,
    AutoModelForAudioClassification,
    AutoModelForCTC,
    AutoModelForCausalLM,
    AutoModelForDepthEstimation,
    AutoModelForDocumentQuestionAnswering,
    AutoModelForImageClassification,
    AutoModelForImageSegmentation,
    AutoModelForImageTextToText,
    AutoModelForImageToImage,
    AutoModelForMaskGeneration,
    AutoModelForMaskedLM,
    AutoModelForObjectDetection,
    AutoModelForQuestionAnswering,
    AutoModelForSemanticSegmentation,
    AutoModelForSeq2SeqLM,
    AutoModelForSequenceClassification,
    AutoModelForSpeechSeq2Seq,
    AutoModelForTableQuestionAnswering,
    AutoModelForTextToSpectrogram,
    AutoModelForTextToWaveform,
    AutoModelForTokenClassification,
    AutoModelForVideoClassification,
    AutoModelForVision2Seq,
    AutoModelForVisualQuestionAnswering,
    AutoModelForZeroShotImageClassification,
    AutoModelForZeroShotObjectDetection,
)
from ..models.auto.processing_auto import AutoProcessor, PROCESSOR_MAPPING
from ..models.auto.tokenization_auto import AutoTokenizer, TOKENIZER_MAPPING
from ..processing_utils import ProcessorMixin
from ..tokenization_utils import PreTrainedTokenizer
from ..utils import (
    CONFIG_NAME,
    HUGGINGFACE_CO_RESOLVE_ENDPOINT,
    cached_file,
    extract_commit_hash,
    find_adapter_config_file,
    is_kenlm_available,
    is_offline_mode,
    is_peft_available,
    is_pyctcdecode_available,
    is_tf_available,
    is_torch_available,
    logging,
)
from .audio_classification import AudioClassificationPipeline
from .automatic_speech_recognition import AutomaticSpeechRecognitionPipeline
from .base import (
    ArgumentHandler,
    CsvPipelineDataFormat,
    JsonPipelineDataFormat,
    PipedPipelineDataFormat,
    Pipeline,
    PipelineDataFormat,
    PipelineException,
    PipelineRegistry,
    get_default_model_and_revision,
    infer_framework_load_model,
)
from .depth_estimation import DepthEstimationPipeline
from .document_question_answering import DocumentQuestionAnsweringPipeline
from .feature_extraction import FeatureExtractionPipeline
from .fill_mask import FillMaskPipeline
from .image_classification import ImageClassificationPipeline
from .image_feature_extraction import ImageFeatureExtractionPipeline
from .image_segmentation import ImageSegmentationPipeline
from .image_text_to_text import ImageTextToTextPipeline
from .image_to_image import ImageToImagePipeline
from .image_to_text import ImageToTextPipeline
from .mask_generation import MaskGenerationPipeline
from .object_detection import ObjectDetectionPipeline
from .question_answering import QuestionAnsweringArgumentHandler, QuestionAnsweringPipeline
from .table_question_answering import TableQuestionAnsweringArgumentHandler, TableQuestionAnsweringPipeline
from .text2text_generation import SummarizationPipeline, Text2TextGenerationPipeline, TranslationPipeline
from .text_classification import TextClassificationPipeline
from .text_generation import TextGenerationPipeline
from .text_to_audio import TextToAudioPipeline
from .token_classification import (
    AggregationStrategy,
    NerPipeline,
    TokenClassificationArgumentHandler,
    TokenClassificationPipeline,
)
from .video_classification import VideoClassificationPipeline
from .visual_question_answering import VisualQuestionAnsweringPipeline
from .zero_shot_audio_classification import ZeroShotAudioClassificationPipeline
from .zero_shot_classification import ZeroShotClassificationArgumentHandler, ZeroShotClassificationPipeline
from .zero_shot_image_classification import ZeroShotImageClassificationPipeline
from .zero_shot_object_detection import ZeroShotObjectDetectionPipeline
from ..models.auto.modeling_tf_auto import (
    TFAutoModel,
    TFAutoModelForCausalLM,
    TFAutoModelForImageClassification,
    TFAutoModelForMaskedLM,
    TFAutoModelForQuestionAnswering,
    TFAutoModelForSeq2SeqLM,
    TFAutoModelForSequenceClassification,
    TFAutoModelForTableQuestionAnswering,
    TFAutoModelForTokenClassification,
    TFAutoModelForVision2Seq,
    TFAutoModelForZeroShotImageClassification,
)
from ..modeling_tf_utils import TFPreTrainedModel
from ..modeling_utils import PreTrainedModel
from ..tokenization_utils_fast import PreTrainedTokenizerFast

if is_tf_available(): ...
if is_torch_available(): ...
if TYPE_CHECKING: ...
logger = ...
TASK_ALIASES = ...
SUPPORTED_TASKS = ...
PIPELINE_REGISTRY = ...

def get_supported_tasks() -> list[str]: ...
def get_task(model: str, token: Optional[str] = ..., **deprecated_kwargs) -> str: ...
def check_task(task: str) -> tuple[str, dict, Any]: ...
def clean_custom_task(task_info): ...
@overload
def pipeline(
    task: None,
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> Pipeline: ...
@overload
def pipeline(
    task: Literal["audio-classification"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> AudioClassificationPipeline: ...
@overload
def pipeline(
    task: Literal["automatic-speech-recognition"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> AutomaticSpeechRecognitionPipeline: ...
@overload
def pipeline(
    task: Literal["depth-estimation"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> DepthEstimationPipeline: ...
@overload
def pipeline(
    task: Literal["document-question-answering"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> DocumentQuestionAnsweringPipeline: ...
@overload
def pipeline(
    task: Literal["feature-extraction"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> FeatureExtractionPipeline: ...
@overload
def pipeline(
    task: Literal["fill-mask"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> FillMaskPipeline: ...
@overload
def pipeline(
    task: Literal["image-classification"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ImageClassificationPipeline: ...
@overload
def pipeline(
    task: Literal["image-feature-extraction"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ImageFeatureExtractionPipeline: ...
@overload
def pipeline(
    task: Literal["image-segmentation"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ImageSegmentationPipeline: ...
@overload
def pipeline(
    task: Literal["image-text-to-text"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ImageTextToTextPipeline: ...
@overload
def pipeline(
    task: Literal["image-to-image"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ImageToImagePipeline: ...
@overload
def pipeline(
    task: Literal["image-to-text"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ImageToTextPipeline: ...
@overload
def pipeline(
    task: Literal["mask-generation"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> MaskGenerationPipeline: ...
@overload
def pipeline(
    task: Literal["object-detection"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ObjectDetectionPipeline: ...
@overload
def pipeline(
    task: Literal["question-answering"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> QuestionAnsweringPipeline: ...
@overload
def pipeline(
    task: Literal["summarization"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> SummarizationPipeline: ...
@overload
def pipeline(
    task: Literal["table-question-answering"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> TableQuestionAnsweringPipeline: ...
@overload
def pipeline(
    task: Literal["text-classification"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> TextClassificationPipeline: ...
@overload
def pipeline(
    task: Literal["text-generation"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> TextGenerationPipeline: ...
@overload
def pipeline(
    task: Literal["text-to-audio"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> TextToAudioPipeline: ...
@overload
def pipeline(
    task: Literal["text2text-generation"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> Text2TextGenerationPipeline: ...
@overload
def pipeline(
    task: Literal["token-classification"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> TokenClassificationPipeline: ...
@overload
def pipeline(
    task: Literal["translation"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> TranslationPipeline: ...
@overload
def pipeline(
    task: Literal["video-classification"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> VideoClassificationPipeline: ...
@overload
def pipeline(
    task: Literal["visual-question-answering"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> VisualQuestionAnsweringPipeline: ...
@overload
def pipeline(
    task: Literal["zero-shot-audio-classification"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ZeroShotAudioClassificationPipeline: ...
@overload
def pipeline(
    task: Literal["zero-shot-classification"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ZeroShotClassificationPipeline: ...
@overload
def pipeline(
    task: Literal["zero-shot-image-classification"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ZeroShotImageClassificationPipeline: ...
@overload
def pipeline(
    task: Literal["zero-shot-object-detection"],
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> ZeroShotObjectDetectionPipeline: ...
def pipeline(
    task: Optional[str] = ...,
    model: Optional[Union[str, PreTrainedModel, TFPreTrainedModel]] = ...,
    config: Optional[Union[str, PretrainedConfig]] = ...,
    tokenizer: Optional[Union[str, PreTrainedTokenizer, PreTrainedTokenizerFast]] = ...,
    feature_extractor: Optional[Union[str, PreTrainedFeatureExtractor]] = ...,
    image_processor: Optional[Union[str, BaseImageProcessor]] = ...,
    processor: Optional[Union[str, ProcessorMixin]] = ...,
    framework: Optional[str] = ...,
    revision: Optional[str] = ...,
    use_fast: bool = ...,
    token: Optional[Union[str, bool]] = ...,
    device: Optional[Union[int, str, torch.device]] = ...,
    device_map: Optional[Union[str, dict[str, Union[int, str]]]] = ...,
    torch_dtype: Optional[Union[str, torch.dtype]] = ...,
    trust_remote_code: Optional[bool] = ...,
    model_kwargs: Optional[dict[str, Any]] = ...,
    pipeline_class: Optional[Any] = ...,
    **kwargs: Any,
) -> Pipeline: ...
