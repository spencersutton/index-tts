"""
This type stub file was generated by pyright.
"""

import contextlib
import doctest
import os
import unittest
from collections import UserDict
from collections.abc import Generator, Iterable, Iterator
from functools import cache
from typing import Any, Optional, Union

from _pytest.doctest import Module
from pytest import DoctestItem
from transformers import Trainer

from .utils import (
    is_accelerate_available,
    is_flax_available,
    is_pytest_available,
    is_tf_available,
    is_torch_available,
    is_torch_hpu_available,
    is_torch_mlu_available,
    is_torch_npu_available,
    is_torch_xla_available,
    is_torch_xpu_available,
)

if is_accelerate_available(): ...
if is_pytest_available(): ...
else:
    Module = ...
    DoctestItem = ...
SMALL_MODEL_IDENTIFIER = ...
DUMMY_UNKNOWN_IDENTIFIER = ...
DUMMY_DIFF_TOKENIZER_IDENTIFIER = ...
USER = ...
ENDPOINT_STAGING = ...
TOKEN = ...
if is_torch_available():
    IS_ROCM_SYSTEM = ...
    IS_CUDA_SYSTEM = ...
    IS_XPU_SYSTEM = ...
else:
    IS_ROCM_SYSTEM = ...
    IS_CUDA_SYSTEM = ...
    IS_XPU_SYSTEM = ...
logger = ...

def parse_flag_from_env(key, default=...):  # -> bool | Literal[1, 0]:
    ...
def parse_int_from_env(key, default=...):  # -> int | None:
    ...

_run_slow_tests = ...
_run_flaky_tests = ...
_run_custom_tokenizers = ...
_run_staging = ...
_run_pipeline_tests = ...
_run_agent_tests = ...

def is_staging_test(test_case):
    """
    Decorator marking a test as a staging test.

    Those tests will run using the staging environment of huggingface.co instead of the real model hub.
    """
    ...

def is_pipeline_test(test_case):
    """
    Decorator marking a test as a pipeline test. If RUN_PIPELINE_TESTS is set to a falsy value, those tests will be
    skipped.
    """
    ...

def is_agent_test(test_case):
    """
    Decorator marking a test as an agent test. If RUN_TOOL_TESTS is set to a falsy value, those tests will be skipped.
    """
    ...

def slow(test_case):
    """
    Decorator marking a test as slow.

    Slow tests are skipped by default. Set the RUN_SLOW environment variable to a truthy value to run them.

    """
    ...

def tooslow(test_case):
    """
    Decorator marking a test as too slow.

    Slow tests are skipped while they're in the process of being fixed. No test should stay tagged as "tooslow" as
    these will not be tested by the CI.

    """
    ...

def skip_if_not_implemented(test_func):  # -> _Wrapped[..., Any, ..., Any]:
    ...
def apply_skip_if_not_implemented(cls):
    """
    Class decorator to apply @skip_if_not_implemented to all test methods.
    """
    ...

def custom_tokenizers(test_case):
    """
    Decorator marking a test for a custom tokenizer.

    Custom tokenizers require additional dependencies, and are skipped by default. Set the RUN_CUSTOM_TOKENIZERS
    environment variable to a truthy value to run them.
    """
    ...

def require_bs4(test_case):
    """
    Decorator marking a test that requires BeautifulSoup4. These tests are skipped when BeautifulSoup4 isn't installed.
    """
    ...

def require_galore_torch(test_case):
    """
    Decorator marking a test that requires GaLore. These tests are skipped when GaLore isn't installed.
    https://github.com/jiaweizzhao/GaLore
    """
    ...

def require_apollo_torch(test_case):
    """
    Decorator marking a test that requires GaLore. These tests are skipped when APOLLO isn't installed.
    https://github.com/zhuhanqing/APOLLO
    """
    ...

def require_torch_optimi(test_case):
    """
    Decorator marking a test that requires torch-optimi. These tests are skipped when torch-optimi isn't installed.
    https://github.com/jxnl/torch-optimi
    """
    ...

def require_lomo(test_case):
    """
    Decorator marking a test that requires LOMO. These tests are skipped when LOMO-optim isn't installed.
    https://github.com/OpenLMLab/LOMO
    """
    ...

def require_grokadamw(test_case):
    """
    Decorator marking a test that requires GrokAdamW. These tests are skipped when GrokAdamW isn't installed.
    """
    ...

def require_schedulefree(test_case):
    """
    Decorator marking a test that requires schedulefree. These tests are skipped when schedulefree isn't installed.
    https://github.com/facebookresearch/schedule_free
    """
    ...

def require_cv2(test_case):
    """
    Decorator marking a test that requires OpenCV.

    These tests are skipped when OpenCV isn't installed.

    """
    ...

def require_levenshtein(test_case):
    """
    Decorator marking a test that requires Levenshtein.

    These tests are skipped when Levenshtein isn't installed.

    """
    ...

def require_nltk(test_case):
    """
    Decorator marking a test that requires NLTK.

    These tests are skipped when NLTK isn't installed.

    """
    ...

def require_accelerate(test_case, min_version: str = ...):
    """
    Decorator marking a test that requires accelerate. These tests are skipped when accelerate isn't installed.
    """
    ...

def require_triton(min_version: str = ...):  # -> Callable[..., Any]:
    """
    Decorator marking a test that requires triton. These tests are skipped when triton isn't installed.
    """
    ...

def require_gguf(test_case, min_version: str = ...):
    """
    Decorator marking a test that requires ggguf. These tests are skipped when gguf isn't installed.
    """
    ...

def require_fsdp(test_case, min_version: str = ...):
    """
    Decorator marking a test that requires fsdp. These tests are skipped when fsdp isn't installed.
    """
    ...

def require_g2p_en(test_case):
    """
    Decorator marking a test that requires g2p_en. These tests are skipped when SentencePiece isn't installed.
    """
    ...

def require_safetensors(test_case):
    """
    Decorator marking a test that requires safetensors. These tests are skipped when safetensors isn't installed.
    """
    ...

def require_rjieba(test_case):
    """
    Decorator marking a test that requires rjieba. These tests are skipped when rjieba isn't installed.
    """
    ...

def require_jieba(test_case):
    """
    Decorator marking a test that requires jieba. These tests are skipped when jieba isn't installed.
    """
    ...

def require_jinja(test_case):
    """
    Decorator marking a test that requires jinja. These tests are skipped when jinja isn't installed.
    """
    ...

def require_tf2onnx(test_case): ...
def require_onnx(test_case): ...
def require_timm(test_case):
    """
    Decorator marking a test that requires Timm.

    These tests are skipped when Timm isn't installed.

    """
    ...

def require_natten(test_case):
    """
    Decorator marking a test that requires NATTEN.

    These tests are skipped when NATTEN isn't installed.

    """
    ...

def require_torch(test_case):
    """
    Decorator marking a test that requires PyTorch.

    These tests are skipped when PyTorch isn't installed.

    """
    ...

def require_torch_greater_or_equal(version: str):  # -> Callable[..., Any]:
    """
    Decorator marking a test that requires PyTorch version >= `version`.

    These tests are skipped when PyTorch version is less than `version`.
    """
    ...

def require_huggingface_hub_greater_or_equal(version: str):  # -> Callable[..., Any]:
    """
    Decorator marking a test that requires huggingface_hub version >= `version`.

    These tests are skipped when huggingface_hub version is less than `version`.
    """
    ...

def require_flash_attn(test_case):
    """
    Decorator marking a test that requires Flash Attention.

    These tests are skipped when Flash Attention isn't installed.

    """
    ...

def require_kernels(test_case):
    """
    Decorator marking a test that requires Flash Attention.

    These tests are skipped when Flash Attention isn't installed.

    """
    ...

def require_flash_attn_3(test_case):
    """
    Decorator marking a test that requires Flash Attention 3.

    These tests are skipped when Flash Attention 3 isn't installed.
    """
    ...

def require_torch_sdpa(test_case):
    """
    Decorator marking a test that requires PyTorch's SDPA.

    These tests are skipped when requirements are not met (torch version).
    """
    ...

def require_read_token(test_case):  # -> type | _Wrapped[..., Any, ..., Any]:
    """
    A decorator that loads the HF token for tests that require to load gated models.
    """
    ...

def require_peft(test_case):
    """
    Decorator marking a test that requires PEFT.

    These tests are skipped when PEFT isn't installed.

    """
    ...

def require_torchvision(test_case):
    """
    Decorator marking a test that requires Torchvision.

    These tests are skipped when Torchvision isn't installed.

    """
    ...

def require_torchcodec(test_case):
    """
    Decorator marking a test that requires Torchcodec.

    These tests are skipped when Torchcodec isn't installed.

    """
    ...

def require_torch_or_tf(test_case):
    """
    Decorator marking a test that requires PyTorch or TensorFlow.

    These tests are skipped when neither PyTorch not TensorFlow is installed.

    """
    ...

def require_intel_extension_for_pytorch(test_case):
    """
    Decorator marking a test that requires Intel Extension for PyTorch.

    These tests are skipped when Intel Extension for PyTorch isn't installed or it does not match current PyTorch
    version.

    """
    ...

def require_tensorflow_probability(test_case):
    """
    Decorator marking a test that requires TensorFlow probability.

    These tests are skipped when TensorFlow probability isn't installed.

    """
    ...

def require_torchaudio(test_case):
    """
    Decorator marking a test that requires torchaudio. These tests are skipped when torchaudio isn't installed.
    """
    ...

def require_tf(test_case):
    """
    Decorator marking a test that requires TensorFlow. These tests are skipped when TensorFlow isn't installed.
    """
    ...

def require_flax(test_case):
    """
    Decorator marking a test that requires JAX & Flax. These tests are skipped when one / both are not installed
    """
    ...

def require_sentencepiece(test_case):
    """
    Decorator marking a test that requires SentencePiece. These tests are skipped when SentencePiece isn't installed.
    """
    ...

def require_sacremoses(test_case):
    """
    Decorator marking a test that requires Sacremoses. These tests are skipped when Sacremoses isn't installed.
    """
    ...

def require_seqio(test_case):
    """
    Decorator marking a test that requires SentencePiece. These tests are skipped when SentencePiece isn't installed.
    """
    ...

def require_scipy(test_case):
    """
    Decorator marking a test that requires Scipy. These tests are skipped when SentencePiece isn't installed.
    """
    ...

def require_tokenizers(test_case):
    """
    Decorator marking a test that requires ðŸ¤— Tokenizers. These tests are skipped when ðŸ¤— Tokenizers isn't installed.
    """
    ...

def require_tensorflow_text(test_case):
    """
    Decorator marking a test that requires tensorflow_text. These tests are skipped when tensroflow_text isn't
    installed.
    """
    ...

def require_keras_nlp(test_case):
    """
    Decorator marking a test that requires keras_nlp. These tests are skipped when keras_nlp isn't installed.
    """
    ...

def require_pandas(test_case):
    """
    Decorator marking a test that requires pandas. These tests are skipped when pandas isn't installed.
    """
    ...

def require_pytesseract(test_case):
    """
    Decorator marking a test that requires PyTesseract. These tests are skipped when PyTesseract isn't installed.
    """
    ...

def require_pytorch_quantization(test_case):
    """
    Decorator marking a test that requires PyTorch Quantization Toolkit. These tests are skipped when PyTorch
    Quantization Toolkit isn't installed.
    """
    ...

def require_vision(test_case):
    """
    Decorator marking a test that requires the vision dependencies. These tests are skipped when torchaudio isn't
    installed.
    """
    ...

def require_ftfy(test_case):
    """
    Decorator marking a test that requires ftfy. These tests are skipped when ftfy isn't installed.
    """
    ...

def require_spacy(test_case):
    """
    Decorator marking a test that requires SpaCy. These tests are skipped when SpaCy isn't installed.
    """
    ...

def require_torch_multi_gpu(test_case):
    """
    Decorator marking a test that requires a multi-GPU CUDA setup (in PyTorch). These tests are skipped on a machine without
    multiple CUDA GPUs.

    To run *only* the multi_gpu tests, assuming all test names contain multi_gpu: $ pytest -sv ./tests -k "multi_gpu"
    """
    ...

def require_torch_multi_accelerator(test_case):
    """
    Decorator marking a test that requires a multi-accelerator (in PyTorch). These tests are skipped on a machine
    without multiple accelerators. To run *only* the multi_accelerator tests, assuming all test names contain
    multi_accelerator: $ pytest -sv ./tests -k "multi_accelerator"
    """
    ...

def require_torch_non_multi_gpu(test_case):
    """
    Decorator marking a test that requires 0 or 1 GPU setup (in PyTorch).
    """
    ...

def require_torch_non_multi_accelerator(test_case):
    """
    Decorator marking a test that requires 0 or 1 accelerator setup (in PyTorch).
    """
    ...

def require_torch_up_to_2_gpus(test_case):
    """
    Decorator marking a test that requires 0 or 1 or 2 GPU setup (in PyTorch).
    """
    ...

def require_torch_up_to_2_accelerators(test_case):
    """
    Decorator marking a test that requires 0 or 1 or 2 accelerator setup (in PyTorch).
    """
    ...

def require_torch_xla(test_case):
    """
    Decorator marking a test that requires TorchXLA (in PyTorch).
    """
    ...

def require_torch_neuroncore(test_case):
    """
    Decorator marking a test that requires NeuronCore (in PyTorch).
    """
    ...

def require_torch_npu(test_case):
    """
    Decorator marking a test that requires NPU (in PyTorch).
    """
    ...

def require_torch_multi_npu(test_case):
    """
    Decorator marking a test that requires a multi-NPU setup (in PyTorch). These tests are skipped on a machine without
    multiple NPUs.

    To run *only* the multi_npu tests, assuming all test names contain multi_npu: $ pytest -sv ./tests -k "multi_npu"
    """
    ...

def require_non_hpu(test_case):
    """
    Decorator marking a test that should be skipped for HPU.
    """
    ...

def require_torch_xpu(test_case):
    """
    Decorator marking a test that requires XPU (in PyTorch).

    These tests are skipped when XPU backend is not available. XPU backend might be available either via stock
    PyTorch (>=2.4) or via Intel Extension for PyTorch. In the latter case, if IPEX is installed, its version
    must match match current PyTorch version.
    """
    ...

def require_non_xpu(test_case):
    """
    Decorator marking a test that should be skipped for XPU.
    """
    ...

def require_torch_multi_xpu(test_case):
    """
    Decorator marking a test that requires a multi-XPU setup (in PyTorch). These tests are skipped on a machine without
    multiple XPUs.

    To run *only* the multi_xpu tests, assuming all test names contain multi_xpu: $ pytest -sv ./tests -k "multi_xpu"
    """
    ...

def require_torch_multi_hpu(test_case):
    """
    Decorator marking a test that requires a multi-HPU setup (in PyTorch). These tests are skipped on a machine without
    multiple HPUs.

    To run *only* the multi_hpu tests, assuming all test names contain multi_hpu: $ pytest -sv ./tests -k "multi_hpu"
    """
    ...

if is_torch_available(): ...
else:
    torch_device = ...
if is_tf_available(): ...
if is_flax_available():
    jax_device = ...
else:
    jax_device = ...

def require_torchdynamo(test_case):
    """Decorator marking a test that requires TorchDynamo"""
    ...

def require_torchao(test_case):
    """Decorator marking a test that requires torchao"""
    ...

def require_torchao_version_greater_or_equal(torchao_version):  # -> Callable[..., Any]:
    ...
def require_torch_tensorrt_fx(test_case):
    """Decorator marking a test that requires Torch-TensorRT FX"""
    ...

def require_torch_gpu(test_case):
    """Decorator marking a test that requires CUDA and PyTorch."""
    ...

def require_torch_mps(test_case):
    """Decorator marking a test that requires CUDA and PyTorch."""
    ...

def require_large_cpu_ram(test_case, memory: float = ...):
    """Decorator marking a test that requires a CPU RAM with more than `memory` GiB of memory."""
    ...

def require_torch_large_gpu(test_case, memory: float = ...):
    """Decorator marking a test that requires a CUDA GPU with more than `memory` GiB of memory."""
    ...

def require_torch_large_accelerator(test_case, memory: float = ...):
    """Decorator marking a test that requires an accelerator with more than `memory` GiB of memory."""
    ...

def require_torch_gpu_if_bnb_not_multi_backend_enabled(test_case):
    """
    Decorator marking a test that requires a GPU if bitsandbytes multi-backend feature is not enabled.
    """
    ...

def require_torch_accelerator(test_case):
    """Decorator marking a test that requires an accessible accelerator and PyTorch."""
    ...

def require_torch_fp16(test_case):
    """Decorator marking a test that requires a device that supports fp16"""
    ...

def require_fp8(test_case):
    """Decorator marking a test that requires supports for fp8"""
    ...

def require_torch_bf16(test_case):
    """Decorator marking a test that requires a device that supports bf16"""
    ...

def require_torch_bf16_gpu(test_case):
    """Decorator marking a test that requires torch>=1.10, using Ampere GPU or newer arch with cuda>=11.0"""
    ...

def require_deterministic_for_xpu(test_case):  # -> _Wrapped[..., Any, ..., Any]:
    ...
def require_torch_tf32(test_case):
    """Decorator marking a test that requires Ampere or a newer GPU arch, cuda>=11 and torch>=1.7."""
    ...

def require_detectron2(test_case):
    """Decorator marking a test that requires detectron2."""
    ...

def require_faiss(test_case):
    """Decorator marking a test that requires faiss."""
    ...

def require_optuna(test_case):
    """
    Decorator marking a test that requires optuna.

    These tests are skipped when optuna isn't installed.

    """
    ...

def require_ray(test_case):
    """
    Decorator marking a test that requires Ray/tune.

    These tests are skipped when Ray/tune isn't installed.

    """
    ...

def require_sigopt(test_case):
    """
    Decorator marking a test that requires SigOpt.

    These tests are skipped when SigOpt isn't installed.

    """
    ...

def require_swanlab(test_case):
    """
    Decorator marking a test that requires swanlab.

    These tests are skipped when swanlab isn't installed.

    """
    ...

def require_trackio(test_case):
    """
    Decorator marking a test that requires trackio.

    These tests are skipped when trackio isn't installed.

    """
    ...

def require_wandb(test_case):
    """
    Decorator marking a test that requires wandb.

    These tests are skipped when wandb isn't installed.

    """
    ...

def require_clearml(test_case):
    """
    Decorator marking a test requires clearml.

    These tests are skipped when clearml isn't installed.

    """
    ...

def require_deepspeed(test_case):
    """
    Decorator marking a test that requires deepspeed
    """
    ...

def require_apex(test_case):
    """
    Decorator marking a test that requires apex
    """
    ...

def require_aqlm(test_case):
    """
    Decorator marking a test that requires aqlm
    """
    ...

def require_vptq(test_case):
    """
    Decorator marking a test that requires vptq
    """
    ...

def require_spqr(test_case):
    """
    Decorator marking a test that requires spqr
    """
    ...

def require_eetq(test_case):
    """
    Decorator marking a test that requires eetq
    """
    ...

def require_av(test_case):
    """
    Decorator marking a test that requires av
    """
    ...

def require_decord(test_case):
    """
    Decorator marking a test that requires decord
    """
    ...

def require_bitsandbytes(test_case):
    """
    Decorator marking a test that requires the bitsandbytes library. Will be skipped when the library or its hard dependency torch is not installed.
    """
    ...

def require_optimum(test_case):
    """
    Decorator for optimum dependency
    """
    ...

def require_tensorboard(test_case):  # -> Callable[[_FT], _FT]:
    """
    Decorator for `tensorboard` dependency
    """
    ...

def require_gptq(test_case):
    """
    Decorator for auto_gptq dependency
    """
    ...

def require_hqq(test_case):
    """
    Decorator for hqq dependency
    """
    ...

def require_auto_awq(test_case):
    """
    Decorator for auto_awq dependency
    """
    ...

def require_auto_round(test_case):
    """
    Decorator for auto_round dependency
    """
    ...

def require_optimum_quanto(test_case):
    """
    Decorator for quanto dependency
    """
    ...

def require_compressed_tensors(test_case):
    """
    Decorator for compressed_tensors dependency
    """
    ...

def require_fbgemm_gpu(test_case):
    """
    Decorator for fbgemm_gpu dependency
    """
    ...

def require_quark(test_case):
    """
    Decorator for quark dependency
    """
    ...

def require_flute_hadamard(test_case):
    """
    Decorator marking a test that requires higgs and hadamard
    """
    ...

def require_fp_quant(test_case):
    """
    Decorator marking a test that requires fp_quant and qutlass
    """
    ...

def require_qutlass(test_case):
    """
    Decorator marking a test that requires qutlass
    """
    ...

def require_phonemizer(test_case):
    """
    Decorator marking a test that requires phonemizer
    """
    ...

def require_pyctcdecode(test_case):
    """
    Decorator marking a test that requires pyctcdecode
    """
    ...

def require_librosa(test_case):
    """
    Decorator marking a test that requires librosa
    """
    ...

def require_liger_kernel(test_case):
    """
    Decorator marking a test that requires liger_kernel
    """
    ...

def require_essentia(test_case):
    """
    Decorator marking a test that requires essentia
    """
    ...

def require_pretty_midi(test_case):
    """
    Decorator marking a test that requires pretty_midi
    """
    ...

def cmd_exists(cmd):  # -> bool:
    ...
def require_usr_bin_time(test_case):
    """
    Decorator marking a test that requires `/usr/bin/time`
    """
    ...

def require_sudachi(test_case):
    """
    Decorator marking a test that requires sudachi
    """
    ...

def require_sudachi_projection(test_case):
    """
    Decorator marking a test that requires sudachi_projection
    """
    ...

def require_jumanpp(test_case):
    """
    Decorator marking a test that requires jumanpp
    """
    ...

def require_cython(test_case):
    """
    Decorator marking a test that requires jumanpp
    """
    ...

def require_tiktoken(test_case):
    """
    Decorator marking a test that requires TikToken. These tests are skipped when TikToken isn't installed.
    """
    ...

def require_speech(test_case):
    """
    Decorator marking a test that requires speech. These tests are skipped when speech isn't available.
    """
    ...

def require_openai(test_case):
    """
    Decorator marking a test that requires openai
    """
    ...

def require_mistral_common(test_case):
    """
    Decorator marking a test that requires mistral-common. These tests are skipped when mistral-common isn't available.
    """
    ...

def get_gpu_count():  # -> int:
    """
    Return the number of available gpus (regardless of whether torch, tf or jax is used)
    """
    ...

def get_tests_dir(append_path=...):  # -> str:
    """
    Args:
        append_path: optional path to append to the tests dir path

    Return:
        The full path to the `tests` dir, so that the tests can be invoked from anywhere. Optionally `append_path` is
        joined after the `tests` dir the former is provided.

    """
    ...

def get_steps_per_epoch(trainer: Trainer) -> int: ...
def evaluate_side_effect_factory(side_effect_values: list[dict[str, float]]) -> Generator[dict[str, float]]:
    """
    Function that returns side effects for the _evaluate method.
    Used when we're unsure of exactly how many times _evaluate will be called.
    """
    ...

def apply_print_resets(buf):  # -> str:
    ...
def assert_screenout(out, what):  # -> None:
    ...
def set_model_tester_for_less_flaky_test(test_case):  # -> None:
    ...
def set_config_for_less_flaky_test(config):  # -> None:
    ...
def set_model_for_less_flaky_test(model):  # -> None:
    ...

class CaptureStd:
    """
    Context manager to capture:

        - stdout: replay it, clean it up and make it available via `obj.out`
        - stderr: replay it and make it available via `obj.err`

    Args:
        out (`bool`, *optional*, defaults to `True`): Whether to capture stdout or not.
        err (`bool`, *optional*, defaults to `True`): Whether to capture stderr or not.
        replay (`bool`, *optional*, defaults to `True`): Whether to replay or not.
            By default each captured stream gets replayed back on context's exit, so that one can see what the test was
            doing. If this is a not wanted behavior and the captured data shouldn't be replayed, pass `replay=False` to
            disable this feature.

    Examples:

    ```python
    # to capture stdout only with auto-replay
    with CaptureStdout() as cs:
        print("Secret message")
    assert "message" in cs.out

    # to capture stderr only with auto-replay
    import sys

    with CaptureStderr() as cs:
        print("Warning: ", file=sys.stderr)
    assert "Warning" in cs.err

    # to capture both streams with auto-replay
    with CaptureStd() as cs:
        print("Secret message")
        print("Warning: ", file=sys.stderr)
    assert "message" in cs.out
    assert "Warning" in cs.err

    # to capture just one of the streams, and not the other, with auto-replay
    with CaptureStd(err=False) as cs:
        print("Secret message")
    assert "message" in cs.out
    # but best use the stream-specific subclasses

    # to capture without auto-replay
    with CaptureStd(replay=False) as cs:
        print("Secret message")
    assert "message" in cs.out
    ```"""
    def __init__(self, out=..., err=..., replay=...) -> None: ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, *exc):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

class CaptureStdout(CaptureStd):
    """Same as CaptureStd but captures only stdout"""
    def __init__(self, replay=...) -> None: ...

class CaptureStderr(CaptureStd):
    """Same as CaptureStd but captures only stderr"""
    def __init__(self, replay=...) -> None: ...

class CaptureLogger:
    """
    Context manager to capture `logging` streams

    Args:
        logger: 'logging` logger object

    Returns:
        The captured output is available via `self.out`

    Example:

    ```python
    >>> from transformers import logging
    >>> from transformers.testing_utils import CaptureLogger

    >>> msg = "Testing 1, 2, 3"
    >>> logging.set_verbosity_info()
    >>> logger = logging.get_logger("transformers.models.bart.tokenization_bart")
    >>> with CaptureLogger(logger) as cl:
    ...     logger.info(msg)
    >>> assert cl.out, msg + "\n"
    ```
    """
    def __init__(self, logger) -> None: ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, *exc):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...

@contextlib.contextmanager
def LoggingLevel(level):  # -> Generator[None, Any, None]:
    """
    This is a context manager to temporarily change transformers modules logging level to the desired value and have it
    restored to the original setting at the end of the scope.

    Example:

    ```python
    with LoggingLevel(logging.INFO):
        AutoModel.from_pretrained("openai-community/gpt2")  # calls logger.info() several times
    ```
    """
    ...

class TemporaryHubRepo:
    """Create a temporary Hub repository and return its `RepoUrl` object. This is similar to
    `tempfile.TemporaryDirectory` and can be used as a context manager. For example:

        with TemporaryHubRepo(token=self._token) as temp_repo:
            ...

    Upon exiting the context, the repository and everything contained in it are removed.

    Example:

    ```python
    with TemporaryHubRepo(token=self._token) as temp_repo:
        model.push_to_hub(tmp_repo.repo_id, token=self._token)
    ```
    """
    def __init__(self, namespace: str | None = ..., token: str | None = ...) -> None: ...
    def __enter__(self):  # -> RepoUrl:
        ...
    def __exit__(self, exc, value, tb):  # -> None:
        ...

@contextlib.contextmanager
def ExtendSysPath(path: str | os.PathLike) -> Iterator[None]:
    """
    Temporary add given path to `sys.path`.

    Usage :

    ```python
    with ExtendSysPath("/path/to/dir"):
        mymodule = importlib.import_module("mymodule")
    ```
    """
    ...

class TestCasePlus(unittest.TestCase):
    """
    This class extends *unittest.TestCase* with additional features.

    Feature 1: A set of fully resolved important file and dir path accessors.

    In tests often we need to know where things are relative to the current test file, and it's not trivial since the
    test could be invoked from more than one directory or could reside in sub-directories with different depths. This
    class solves this problem by sorting out all the basic paths and provides easy accessors to them:

    - `pathlib` objects (all fully resolved):

       - `test_file_path` - the current test file path (=`__file__`)
       - `test_file_dir` - the directory containing the current test file
       - `tests_dir` - the directory of the `tests` test suite
       - `examples_dir` - the directory of the `examples` test suite
       - `repo_root_dir` - the directory of the repository
       - `src_dir` - the directory of `src` (i.e. where the `transformers` sub-dir resides)

    - stringified paths---same as above but these return paths as strings, rather than `pathlib` objects:

       - `test_file_path_str`
       - `test_file_dir_str`
       - `tests_dir_str`
       - `examples_dir_str`
       - `repo_root_dir_str`
       - `src_dir_str`

    Feature 2: Flexible auto-removable temporary dirs which are guaranteed to get removed at the end of test.

    1. Create a unique temporary dir:

    ```python
    def test_whatever(self):
        tmp_dir = self.get_auto_remove_tmp_dir()
    ```

    `tmp_dir` will contain the path to the created temporary dir. It will be automatically removed at the end of the
    test.


    2. Create a temporary dir of my choice, ensure it's empty before the test starts and don't
    empty it after the test.

    ```python
    def test_whatever(self):
        tmp_dir = self.get_auto_remove_tmp_dir("./xxx")
    ```

    This is useful for debug when you want to monitor a specific directory and want to make sure the previous tests
    didn't leave any data in there.

    3. You can override the first two options by directly overriding the `before` and `after` args, leading to the
        following behavior:

    `before=True`: the temporary dir will always be cleared at the beginning of the test.

    `before=False`: if the temporary dir already existed, any existing files will remain there.

    `after=True`: the temporary dir will always be deleted at the end of the test.

    `after=False`: the temporary dir will always be left intact at the end of the test.

    Note 1: In order to run the equivalent of `rm -r` safely, only subdirs of the project repository checkout are
    allowed if an explicit `tmp_dir` is used, so that by mistake no `/tmp` or similar important part of the filesystem
    will get nuked. i.e. please always pass paths that start with `./`

    Note 2: Each test can register multiple temporary dirs and they all will get auto-removed, unless requested
    otherwise.

    Feature 3: Get a copy of the `os.environ` object that sets up `PYTHONPATH` specific to the current test suite. This
    is useful for invoking external programs from the test suite - e.g. distributed training.


    ```python
    def test_whatever(self):
        env = self.get_env()
    ```"""
    def setUp(self):  # -> None:
        ...
    @property
    def test_file_path(self):  # -> str:
        ...
    @property
    def test_file_path_str(self):  # -> str:
        ...
    @property
    def test_file_dir(self):  # -> Path:
        ...
    @property
    def test_file_dir_str(self):  # -> str:
        ...
    @property
    def tests_dir(self):  # -> Path:
        ...
    @property
    def tests_dir_str(self):  # -> str:
        ...
    @property
    def examples_dir(self):  # -> Path:
        ...
    @property
    def examples_dir_str(self):  # -> str:
        ...
    @property
    def repo_root_dir(self):  # -> Path:
        ...
    @property
    def repo_root_dir_str(self):  # -> str:
        ...
    @property
    def src_dir(self):  # -> Path:
        ...
    @property
    def src_dir_str(self):  # -> str:
        ...
    def get_env(self):  # -> dict[str, str]:
        """
        Return a copy of the `os.environ` object that sets up `PYTHONPATH` correctly, depending on the test suite it's
        invoked from. This is useful for invoking external programs from the test suite - e.g. distributed training.

        It always inserts `./src` first, then `./tests` or `./examples` depending on the test suite type and finally
        the preset `PYTHONPATH` if any (all full resolved paths).

        """
        ...

    def get_auto_remove_tmp_dir(self, tmp_dir=..., before=..., after=...):  # -> str:
        """
        Args:
            tmp_dir (`string`, *optional*):
                if `None`:

                   - a unique temporary path will be created
                   - sets `before=True` if `before` is `None`
                   - sets `after=True` if `after` is `None`
                else:

                   - `tmp_dir` will be created
                   - sets `before=True` if `before` is `None`
                   - sets `after=False` if `after` is `None`
            before (`bool`, *optional*):
                If `True` and the `tmp_dir` already exists, make sure to empty it right away if `False` and the
                `tmp_dir` already exists, any existing files will remain there.
            after (`bool`, *optional*):
                If `True`, delete the `tmp_dir` at the end of the test if `False`, leave the `tmp_dir` and its contents
                intact at the end of the test.

        Returns:
            tmp_dir(`string`): either the same value as passed via *tmp_dir* or the path to the auto-selected tmp dir
        """
        ...

    def python_one_liner_max_rss(self, one_liner_str):  # -> int:
        """
        Runs the passed python one liner (just the code) and returns how much max cpu memory was used to run the
        program.

        Args:
            one_liner_str (`string`):
                a python one liner code that gets passed to `python -c`

        Returns:
            max cpu memory bytes used to run the program. This value is likely to vary slightly from run to run.

        Requirements:
            this helper needs `/usr/bin/time` to be installed (`apt install time`)

        Example:

        ```
        one_liner_str = 'from transformers import AutoModel; AutoModel.from_pretrained("google-t5/t5-large")'
        max_rss = self.python_one_liner_max_rss(one_liner_str)
        ```
        """
        ...

    def tearDown(self):  # -> None:
        ...

def mockenv(**kwargs):  # -> _patch_dict:
    """
    this is a convenience wrapper, that allows this ::

    @mockenv(RUN_SLOW=True, USE_TF=False) def test_something():
        run_slow = os.getenv("RUN_SLOW", False) use_tf = os.getenv("USE_TF", False)

    """
    ...

@contextlib.contextmanager
def mockenv_context(*remove, **update):  # -> Generator[None, Any, None]:
    """
    Temporarily updates the `os.environ` dictionary in-place. Similar to mockenv

    The `os.environ` dictionary is updated in-place so that the modification is sure to work in all situations.

    Args:
      remove: Environment variables to remove.
      update: Dictionary of environment variables and values to add/update.
    """
    ...

pytest_opt_registered = ...

def pytest_addoption_shared(parser):  # -> None:
    """
    This function is to be called from `conftest.py` via `pytest_addoption` wrapper that has to be defined there.

    It allows loading both `conftest.py` files at once without causing a failure due to adding the same `pytest`
    option.

    """
    ...

def pytest_terminal_summary_main(tr, id):  # -> None:
    """
    Generate multiple reports at the end of test suite run - each report goes into a dedicated file in the current
    directory. The report files are prefixed with the test suite name.

    This function emulates --duration and -rA pytest arguments.

    This function is to be called from `conftest.py` via `pytest_terminal_summary` wrapper that has to be defined
    there.

    Args:
    - tr: `terminalreporter` passed from `conftest.py`
    - id: unique id like `tests` or `examples` that will be incorporated into the final reports filenames - this is
      needed as some jobs have multiple runs of pytest, so we can't have them overwrite each other.

    NB: this functions taps into a private _pytest API and while unlikely, it could break should pytest do internal
    changes - also it calls default internal methods of terminalreporter which can be hijacked by various `pytest-`
    plugins and interfere.

    """
    ...

class _RunOutput:
    def __init__(self, returncode, stdout, stderr) -> None: ...

def execute_subprocess_async(cmd, env=..., stdin=..., timeout=..., quiet=..., echo=...) -> _RunOutput: ...
def pytest_xdist_worker_id():  # -> int:
    """
    Returns an int value of worker's numerical id under `pytest-xdist`'s concurrent workers `pytest -n N` regime, or 0
    if `-n 1` or `pytest-xdist` isn't being used.
    """
    ...

def get_torch_dist_unique_port():  # -> int:
    """
    Returns a port number that can be fed to `torch.distributed.launch`'s `--master_port` argument.

    Under `pytest-xdist` it adds a delta number based on a worker id so that concurrent tests don't try to use the same
    port at once.
    """
    ...

def nested_simplify(
    obj, decimals=...
):  # -> list[list[Any] | tuple[list[Any] | tuple[Any, ...] | Any | dict[Any, Any] | str | int | int64 | float, ...] | Any | dict[Any, Any] | str | int | int64 | float] | tuple[list[Any] | tuple[Any, ...] | Any | dict[Any, Any] | str | int | int64 | float, ...] | dict[Any, Any] | str | int | int64 | float:
    """
    Simplifies an object by rounding float numbers, and downcasting tensors/numpy arrays to get simple equality test
    within tests.
    """
    ...

def check_json_file_has_correct_format(file_path):  # -> None:
    ...
def to_2tuple(x):  # -> tuple[Any, Any]:
    ...

class SubprocessCallException(Exception): ...

def run_command(command: list[str], return_stdout=...):  # -> str | bytes | None:
    """
    Runs `command` with `subprocess.check_output` and will potentially return the `stdout`. Will also properly capture
    if an error occurred while running `command`
    """
    ...

class RequestCounter:
    """
    Helper class that will count all requests made online.

    Might not be robust if urllib3 changes its logging format but should be good enough for us.

    Usage:
    ```py
    with RequestCounter() as counter:
        _ = AutoTokenizer.from_pretrained("hf-internal-testing/tiny-random-bert")
    assert counter["GET"] == 0
    assert counter["HEAD"] == 1
    assert counter.total_calls == 1
    ```
    """
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, *args, **kwargs) -> None: ...
    def __getitem__(self, key: str) -> int: ...
    @property
    def total_calls(self) -> int: ...

def is_flaky(
    max_attempts: int = ..., wait_before_retry: float | None = ..., description: str | None = ...
):  # -> Callable[..., _Wrapped[..., Any, ..., Any]]:
    """
    To decorate flaky tests. They will be retried on failures.

    Please note that our push tests use `pytest-rerunfailures`, which prompts the CI to rerun certain types of
    failed tests. More specifically, if the test exception contains any substring in `FLAKY_TEST_FAILURE_PATTERNS`
    (in `.circleci/create_circleci_config.py`), it will be rerun. If you find a recurrent pattern of failures,
    expand `FLAKY_TEST_FAILURE_PATTERNS` in our CI configuration instead of using `is_flaky`.

    Args:
        max_attempts (`int`, *optional*, defaults to 5):
            The maximum number of attempts to retry the flaky test.
        wait_before_retry (`float`, *optional*):
            If provided, will wait that number of seconds before retrying the test.
        description (`str`, *optional*):
            A string to describe the situation (what / where / why is flaky, link to GH issue/PR comments, errors,
            etc.)
    """
    ...

def hub_retry(
    max_attempts: int = ..., wait_before_retry: float | None = ...
):  # -> Callable[..., _Wrapped[..., Any, ..., Any]]:
    """
    To decorate tests that download from the Hub. They can fail due to a
    variety of network issues such as timeouts, connection resets, etc.

    Args:
        max_attempts (`int`, *optional*, defaults to 5):
            The maximum number of attempts to retry the flaky test.
        wait_before_retry (`float`, *optional*, defaults to 2):
            If provided, will wait that number of seconds before retrying the test.
    """
    ...

def run_first(test_case):
    """
    Decorator marking a test with order(1). When pytest-order plugin is installed, tests marked with this decorator
    are guaranteed to run first.

    This is especially useful in some test settings like on a Gaudi instance where a Gaudi device can only be used by a
    single process at a time. So we make sure all tests that run in a subprocess are launched first, to avoid device
    allocation conflicts.
    """
    ...

def run_test_in_subprocess(test_case, target_func, inputs=..., timeout=...):  # -> None:
    """
    To run a test in a subprocess. In particular, this can avoid (GPU) memory issue.

    Args:
        test_case (`unittest.TestCase`):
            The test that will run `target_func`.
        target_func (`Callable`):
            The function implementing the actual testing logic.
        inputs (`dict`, *optional*, defaults to `None`):
            The inputs that will be passed to `target_func` through an (input) queue.
        timeout (`int`, *optional*, defaults to `None`):
            The timeout (in seconds) that will be passed to the input and output queues. If not specified, the env.
            variable `PYTEST_TIMEOUT` will be checked. If still `None`, its value will be set to `600`.
    """
    ...

def run_test_using_subprocess(func):  # -> _Wrapped[..., Any, ..., None]:
    """
    To decorate a test to run in a subprocess using the `subprocess` module. This could avoid potential GPU memory
    issues (GPU OOM or a test that causes many subsequential failing with `CUDA error: device-side assert triggered`).
    """
    ...

def preprocess_string(string, skip_cuda_tests):  # -> str:
    """Prepare a docstring or a `.md` file to be run by doctest.

    The argument `string` would be the whole file content if it is a `.md` file. For a python file, it would be one of
    its docstring. In each case, it may contain multiple python code examples. If `skip_cuda_tests` is `True` and a
    cuda stuff is detective (with a heuristic), this method will return an empty string so no doctest will be run for
    `string`.
    """
    ...

class HfDocTestParser(doctest.DocTestParser):
    """
    Overwrites the DocTestParser from doctest to properly parse the codeblocks that are formatted with black. This
    means that there are no extra lines at the end of our snippets. The `# doctest: +IGNORE_RESULT` marker is also
    added anywhere a `load_dataset` call is made as a print would otherwise fail the corresponding line.

    Tests involving cuda are skipped base on a naive pattern that should be updated if it is not enough.
    """

    _EXAMPLE_RE = ...
    skip_cuda_tests: bool = ...
    def parse(self, string, name=...):  # -> list[str | Example]:
        """
        Overwrites the `parse` method to incorporate a skip for CUDA tests, and remove logs and dataset prints before
        calling `super().parse`
        """
        ...

class HfDoctestModule(Module):
    """
    Overwrites the `DoctestModule` of the pytest package to make sure the HFDocTestParser is used when discovering
    tests.
    """
    def collect(self) -> Iterable[DoctestItem]:
        class MockAwareDocTestFinder(doctest.DocTestFinder):
            """A hackish doctest finder that overrides stdlib internals to fix a stdlib bug.

            https://github.com/pytest-dev/pytest/issues/3456 https://bugs.python.org/issue25532
            """

            ...

if is_torch_available():
    BACKEND_MANUAL_SEED = ...
    BACKEND_EMPTY_CACHE = ...
    BACKEND_DEVICE_COUNT = ...
    BACKEND_RESET_MAX_MEMORY_ALLOCATED = ...
    BACKEND_MAX_MEMORY_ALLOCATED = ...
    BACKEND_RESET_PEAK_MEMORY_STATS = ...
    BACKEND_MEMORY_ALLOCATED = ...
    BACKEND_SYNCHRONIZE = ...
    BACKEND_TORCH_ACCELERATOR_MODULE = ...
else:
    BACKEND_MANUAL_SEED = ...
    BACKEND_EMPTY_CACHE = ...
    BACKEND_DEVICE_COUNT = ...
    BACKEND_RESET_MAX_MEMORY_ALLOCATED = ...
    BACKEND_RESET_PEAK_MEMORY_STATS = ...
    BACKEND_MAX_MEMORY_ALLOCATED = ...
    BACKEND_MEMORY_ALLOCATED = ...
    BACKEND_SYNCHRONIZE = ...
    BACKEND_TORCH_ACCELERATOR_MODULE = ...
if is_torch_hpu_available(): ...
if is_torch_mlu_available(): ...
if is_torch_npu_available(): ...
if is_torch_xpu_available(): ...
if is_torch_xla_available(): ...

def backend_manual_seed(device: str, seed: int): ...
def backend_empty_cache(device: str): ...
def backend_device_count(device: str): ...
def backend_reset_max_memory_allocated(device: str): ...
def backend_reset_peak_memory_stats(device: str): ...
def backend_max_memory_allocated(device: str): ...
def backend_memory_allocated(device: str): ...
def backend_synchronize(device: str): ...
def backend_torch_accelerator_module(device: str): ...

if is_torch_available(): ...

def compare_pipeline_output_to_hub_spec(output, hub_spec):  # -> None:
    ...
@require_torch
def cleanup(device: str, gc_collect=...):  # -> None:
    ...

DeviceProperties = tuple[str | None, int | None, int | None]
PackedDeviceProperties = tuple[str | None, None | int | tuple[int, int]]

@cache
def get_device_properties() -> DeviceProperties:
    """
    Get environment device properties.
    """
    ...

def unpack_device_properties(properties: PackedDeviceProperties | None = ...) -> DeviceProperties:
    """
    Unpack a `PackedDeviceProperties` tuple into consistently formatted `DeviceProperties` tuple. If properties is None, it is fetched.
    """
    ...

class Expectations(UserDict[PackedDeviceProperties, Any]):
    def get_expectation(self) -> Any:
        """
        Find best matching expectation based on environment device properties.
        """
        ...

    def unpacked(self) -> list[tuple[DeviceProperties, Any]]: ...
    @staticmethod
    def is_default(expectation_key: PackedDeviceProperties) -> bool:
        """
        This function returns True if the expectation_key is the Default expectation (None, None).
        When an Expectation dict contains a Default value, it is generally because the test existed before Expectations.
        When we modify a test to use Expectations for a specific hardware, we don't want to affect the tests on other
        hardwares. Thus we set the previous value as the Default expectation with key (None, None) and add a value for
        the specific hardware with key (hardware_type, (major, minor)).
        """
        ...

    @staticmethod
    def score(properties: DeviceProperties, other: DeviceProperties) -> float:
        """
        Returns score indicating how similar two instances of the `Properties` tuple are.
        Rules are as follows:
            * Matching `type` adds one point, semi-matching `type` adds 0.1 point (e.g. cuda and rocm).
            * If types match, matching `major` adds another point, and then matching `minor` adds another.
            * The Default expectation (None, None) is worth 0.5 point, which is better than semi-matching. More on this
            in the `is_default` function.
        """
        ...

    def find_expectation(self, properties: DeviceProperties = ...) -> Any:
        """
        Find best matching expectation based on provided device properties. We score each expectation, and to
        distinguish between expectations with the same score, we use the major and minor version numbers, prioritizing
        most recent versions.
        """
        ...

    def __repr__(self):  # -> str:
        ...

def torchrun(script: str, nproc_per_node: int, is_torchrun: bool = ..., env: dict | None = ...):  # -> None:
    """Run the `script` using `torchrun` command for multi-processing in a subprocess. Captures errors as necessary."""
    ...
