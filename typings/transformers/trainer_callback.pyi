"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import Optional, Union
from .training_args import TrainingArguments

logger = ...

@dataclass
class TrainerState:
    epoch: Optional[float] = ...
    global_step: int = ...
    max_steps: int = ...
    logging_steps: int = ...
    eval_steps: int = ...
    save_steps: int = ...
    train_batch_size: Optional[int] = ...
    num_train_epochs: int = ...
    num_input_tokens_seen: int = ...
    total_flos: float = ...
    log_history: list[dict[str, float]] = ...
    best_metric: Optional[float] = ...
    best_global_step: Optional[int] = ...
    best_model_checkpoint: Optional[str] = ...
    is_local_process_zero: bool = ...
    is_world_process_zero: bool = ...
    is_hyper_param_search: bool = ...
    trial_name: Optional[str] = ...
    trial_params: dict[str, Union[str, float, int, bool]] = ...
    stateful_callbacks: list[TrainerCallback] = ...
    def __post_init__(self): ...
    def save_to_json(self, json_path: str): ...
    @classmethod
    def load_from_json(cls, json_path: str): ...
    def compute_steps(self, args, max_steps): ...
    def init_training_references(self, trainer, max_steps, num_train_epochs, trial): ...

class ExportableState:
    def state(self) -> dict: ...
    @classmethod
    def from_state(cls, state): ...

@dataclass
class TrainerControl(ExportableState):
    should_training_stop: bool = ...
    should_epoch_stop: bool = ...
    should_save: bool = ...
    should_evaluate: bool = ...
    should_log: bool = ...
    def state(self) -> dict: ...

class TrainerCallback:
    def on_init_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_train_begin(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_train_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_epoch_begin(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_epoch_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_step_begin(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_pre_optimizer_step(
        self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs
    ): ...
    def on_optimizer_step(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_substep_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_step_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_evaluate(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_predict(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, metrics, **kwargs): ...
    def on_save(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_log(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_prediction_step(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...

class CallbackHandler(TrainerCallback):
    def __init__(self, callbacks, model, processing_class, optimizer, lr_scheduler) -> None: ...
    def add_callback(self, callback): ...
    def pop_callback(self, callback): ...
    def remove_callback(self, callback): ...
    @property
    def callback_list(self): ...
    def on_init_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_train_begin(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_train_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_epoch_begin(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_epoch_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_step_begin(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_pre_optimizer_step(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_optimizer_step(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_substep_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_step_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_evaluate(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, metrics): ...
    def on_predict(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, metrics): ...
    def on_save(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def on_log(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, logs): ...
    def on_prediction_step(self, args: TrainingArguments, state: TrainerState, control: TrainerControl): ...
    def call_event(self, event, args, state, control, **kwargs): ...

class DefaultFlowCallback(TrainerCallback):
    def on_step_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...
    def on_epoch_end(self, args: TrainingArguments, state: TrainerState, control: TrainerControl, **kwargs): ...

class ProgressCallback(TrainerCallback):
    def __init__(self, max_str_len: int = ...) -> None: ...
    def on_train_begin(self, args, state, control, **kwargs): ...
    def on_step_end(self, args, state, control, **kwargs): ...
    def on_prediction_step(self, args, state, control, eval_dataloader=..., **kwargs): ...
    def on_evaluate(self, args, state, control, **kwargs): ...
    def on_predict(self, args, state, control, **kwargs): ...
    def on_log(self, args, state, control, logs=..., **kwargs): ...
    def on_train_end(self, args, state, control, **kwargs): ...

class PrinterCallback(TrainerCallback):
    def on_log(self, args, state, control, logs=..., **kwargs): ...

class EarlyStoppingCallback(TrainerCallback, ExportableState):
    def __init__(self, early_stopping_patience: int = ..., early_stopping_threshold: Optional[float] = ...) -> None: ...
    def check_metric_value(self, args, state, control, metric_value): ...
    def on_train_begin(self, args, state, control, **kwargs): ...
    def on_evaluate(self, args, state, control, metrics, **kwargs): ...
    def state(self) -> dict: ...
