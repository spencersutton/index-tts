from collections import OrderedDict
from collections.abc import Callable, MutableMapping
from contextlib import contextmanager
from dataclasses import dataclass
from enum import StrEnum
from typing import Any, ContextManager, TypedDict

import torch

from .import_utils import is_torch_available, requires

"""
Generic utilities
"""
_CAN_RECORD_REGISTRY = ...
logger = ...
if is_torch_available(): ...

class cached_property(property):
    def __get__(self, obj, objtype=...):  # -> Self | Any:
        ...

def strtobool(val):  # -> Literal[1, 0]:

    ...
def infer_framework_from_repr(x):  # -> Literal['pt', 'tf', 'jax', 'np', 'mlx'] | None:

    ...
def is_tensor(x):  # -> bool:

    ...
def is_numpy_array(x):  # -> bool:

    ...
def is_torch_tensor(x):  # -> bool:

    ...
def is_torch_device(x):  # -> bool:

    ...
def is_torch_dtype(x):  # -> bool:

    ...
def is_tf_tensor(x):  # -> bool:

    ...
def is_tf_symbolic_tensor(x):  # -> bool:

    ...
def is_jax_tensor(x):  # -> bool:

    ...
def is_mlx_array(x):  # -> bool:

    ...
def to_py_obj(
    obj,
):  # -> int | float | dict[Any, int | float | dict[Any, int | float | dict[Any, Any] | Any | list[int | float | dict[Any, Any] | Any | list[Any] | complex] | complex] | Any | list[int | float | dict[Any, Any] | Any | list[Any] | complex] | complex] | Any | list[int | float | dict[Any, Any] | Any | list[Any] | complex] | complex:

    ...
def to_numpy(obj):  # -> dict[Any, dict[Any, Any] | NDArray[Any] | Any] | NDArray[Any]:

    ...

class ModelOutput(OrderedDict):
    def __init_subclass__(cls) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __post_init__(self):  # -> None:

        ...
    def __delitem__(self, *args, **kwargs) -> None: ...
    def setdefault(self, *args, **kwargs): ...
    def pop(self, *args, **kwargs): ...
    def update(self, *args, **kwargs): ...
    def __getitem__(self, k):  # -> Any:
        ...
    def __setattr__(self, name, value) -> None:  # -> None:
        ...
    def __setitem__(self, key, value) -> None:  # -> None:
        ...
    def __reduce__(self):  # -> str | tuple[Any, ...] | tuple[str | Any, tuple[Any, ...], *tuple[str | Any, ...]]:
        ...
    def to_tuple(self) -> tuple[Any]: ...

if is_torch_available(): ...

class ExplicitEnum(StrEnum): ...

class PaddingStrategy(ExplicitEnum):
    LONGEST = ...
    MAX_LENGTH = ...
    DO_NOT_PAD = ...

class TensorType(ExplicitEnum):
    PYTORCH = ...
    TENSORFLOW = ...
    NUMPY = ...
    JAX = ...
    MLX = ...

class ContextManagers:
    def __init__(self, context_managers: list[ContextManager]) -> None: ...
    def __enter__(self):  # -> None:
        ...
    def __exit__(self, *args, **kwargs):  # -> None:
        ...

def can_return_loss(model_class):  # -> bool:

    ...
def find_labels(model_class):  # -> list[str]:

    ...
def flatten_dict(d: MutableMapping, parent_key: str = ..., delimiter: str = ...):  # -> dict[str | Any, Any]:

    ...
@contextmanager
def working_or_temp_dir(working_dir, use_temp_dir: bool = ...):  # -> Generator[str | Any, Any, None]:
    ...
def transpose(array, axes=...):  # -> NDArray[Any]:

    ...
def reshape(array, newshape):  # -> ndarray[tuple[int], dtype[Any]]:

    ...
def squeeze(array, axis=...): ...
def expand_dims(array, axis):  # -> NDArray[Any]:

    ...
def tensor_size(array):  # -> int:

    ...
def infer_framework(model_class):  # -> Literal['tf', 'pt', 'flax']:

    ...
def torch_int(x):  # -> int | Tensor:

    ...
def torch_float(x):  # -> int | Tensor:

    ...
def filter_out_non_signature_kwargs(extra: list | None = ...):  # -> Callable[..., _Wrapped[..., Any, ..., Any]]:

    ...

class TransformersKwargs(TypedDict, total=False):
    num_items_in_batch: torch.Tensor | None
    output_hidden_states: bool | None
    output_attentions: bool | None
    output_router_logits: bool | None
    cumulative_seqlens_q: torch.LongTensor | None
    cumulative_seqlens_k: torch.LongTensor | None
    max_length_q: int | None
    max_length_k: int | None

def is_timm_config_dict(config_dict: dict[str, Any]) -> bool: ...
def is_timm_local_checkpoint(pretrained_model_path: str) -> bool: ...
def set_attribute_for_modules(module: torch.nn.Module, key: str, value: Any):  # -> None:

    ...
def del_attribute_from_modules(module: torch.nn.Module, key: str):  # -> None:

    ...
def can_return_tuple(func):  # -> _Wrapped[..., Any, ..., Any | tuple[Any, ...]]:

    ...

@dataclass
@requires(backends=("torch",))
class OutputRecorder:
    target_class: type[torch.nn.Module]
    index: int | None = ...
    layer_name: str | None = ...
    class_name: str | None = ...

def check_model_inputs(func):  # -> _Wrapped[..., Any, ..., Any]:

    ...

class GeneralInterface(MutableMapping):
    _global_mapping = ...
    def __init__(self) -> None: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None:  # -> None:
        ...
    def __delitem__(self, key) -> None:  # -> None:
        ...
    def __iter__(self):  # -> Iterator[Any]:
        ...
    def __len__(self) -> int:  # -> int:
        ...
    @classmethod
    def register(cls, key: str, value: Callable):  # -> None:
        ...
    def valid_keys(self) -> list[str]: ...
